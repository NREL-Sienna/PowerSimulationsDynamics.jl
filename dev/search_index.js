var documenterSearchIndex = {"docs":
[{"location":"Examples/example_data/#Tutorial-0:-Data-creation","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data creation","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"This tutorial briefly introduces how to create a system using PowerSystems.jl data structures. The tutorial will guide you to create the JSON data file for the tutorial 1. We start by calling PowerSystems.jl:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"using PowerSystems\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_data/#Step-1:-System-description","page":"Tutorial 0: Data Creation","title":"Step 1: System description","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Next we need to define the different elements required to run a simulation. To run a simulation in PowerSimulationsDynamics, it is required to define a System that contains the following components:","category":"page"},{"location":"Examples/example_data/#Static-Components:","page":"Tutorial 0: Data Creation","title":"Static Components:","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"We called static components to those that are used to run a Power Flow problem. Basically those are:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Vector of Bus elements, that define all the buses in the network.\nVector of Branch elements, that define all the branches elements (that connect two buses) in the network.\nVector of StaticInjection elements, that define all the devices connected to buses that can inject (or withdraw) power. These static devices, typically generators, in PowerSimulationsDynamics are used to solve the Power Flow problem that determines the active and reactive power provided for each device.\nVector of PowerLoad elements, that define all the loads connected to buses that can withdraw current. These are also used to solve the Power Flow. In addition, note that PowerSimulationsDynamics will convert ConstantPower loads to RLC loads for transient simulations.\nVector of Source elements, that define source components behind a reactance that can inject or withdraw current.\nThe base of power used to define per unit values, in MVA as a Float64 value.\nThe base frequency used in the system, in Hz as a Float64 value.","category":"page"},{"location":"Examples/example_data/#Dynamic-Components:","page":"Tutorial 0: Data Creation","title":"Dynamic Components:","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Dynamic components are those that define differential equations to run a transient simulation. Basically those are:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Vector of DynamicInjection elements. These components must be attached to a StaticInjection that connects the power flow solution to the dynamic formulation of such device. DynamicInjection can be DynamicGenerator or DynamicInverter, and its specific formulation (i.e. differential equations) will depend on the specific components that define such device.\n(Optional) Selecting which of the Lines (of the Branch vector) elements must be modeled of DynamicLines elements, that can be used to model lines with differential equations.","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"To start we will define the data structures for the network.","category":"page"},{"location":"Examples/example_data/#OMIB-case:-Data-creation","page":"Tutorial 0: Data Creation","title":"OMIB case: Data creation","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"The following describes the system creation for the OMIB case.","category":"page"},{"location":"Examples/example_data/#Static-System-creation","page":"Tutorial 0: Data Creation","title":"Static System creation","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"There are plenty of ways to define a static system (for Power Flow purposes), but the recommended option for users is to use a PTI data format (.raw file) or a Matpower data format (.m file), since parsers are available. The following OMIB.raw file is used to create the OMIB system:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"0, 100, 33, 0, 0, 60  / 24-Apr-2020 17:05:49 - MATPOWER 7.0.1-dev\n\n\n     101, 'BUS 1       ',       230, 3,    1,    1, 1,        1.05,           0, 1.06, 0.94, 1.06, 0.94\n     102, 'BUS 2       ',       230, 2,    1,    1, 1,        1.04,           0, 1.06, 0.94, 1.06, 0.94\n0 / END OF BUS DATA, BEGIN LOAD DATA\n0 / END OF LOAD DATA, BEGIN FIXED SHUNT DATA\n0 / END OF FIXED SHUNT DATA, BEGIN GENERATOR DATA\n     102,  1,        50,         0,       100,      -100,     1.00, 0,     100, 0, 1, 0, 0, 1, 1, 100,       100,         0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1\n0 / END OF GENERATOR DATA, BEGIN BRANCH DATA\n     101,      102, 1,    0.00,     0.05,   0.000,     100,     100,     100, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1\n0 / END OF BRANCH DATA, BEGIN TRANSFORMER DATA\n0 / END OF TRANSFORMER DATA, BEGIN AREA DATA\n0 / END OF AREA DATA, BEGIN TWO-TERMINAL DC DATA\n0 / END OF TWO-TERMINAL DC DATA, BEGIN VOLTAGE SOURCE CONVERTER DATA\n0 / END OF VOLTAGE SOURCE CONVERTER DATA, BEGIN IMPEDANCE CORRECTION DATA\n0 / END OF IMPEDANCE CORRECTION DATA, BEGIN MULTI-TERMINAL DC DATA\n0 / END OF MULTI-TERMINAL DC DATA, BEGIN MULTI-SECTION LINE DATA\n0 / END OF MULTI-SECTION LINE DATA, BEGIN ZONE DATA\n0 / END OF ZONE DATA, BEGIN INTER-AREA TRANSFER DATA\n0 / END OF INTER-AREA TRANSFER DATA, BEGIN OWNER DATA\n0 / END OF OWNER DATA, BEGIN FACTS CONTROL DEVICE DATA\n0 / END OF FACTS CONTROL DEVICE DATA, BEGIN SWITCHED SHUNT DATA\n0 / END OF SWITCHED SHUNT DATA, BEGIN GNE DEVICE DATA\n0 / END OF GNE DEVICE DATA, BEGIN INDUCTION MACHINE DATA\n0 / END OF INDUCTION MACHINE DATA\nQ","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Based on the description provided in PTI files, this is a two-bus system, on which the bus 101 (bus 1) is the reference bus at 1.05 pu, and bus 102 (bus 2) is PV bus, to be set at 1.04 pu. There is one 100 MVA generator connected at bus 2, producing 50 MW. There is an equivalent line connecting buses 1 and 2 with a reactance of 005 pu.","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"#To create the system you need to pass the location of the RAW file\nfile_dir = \"OMIB.raw\"\nomib_sys = System(omib_file_dir)","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Note that this system does not have an injection device in bus 1 (the reference bus). We can add a source with small impedance directly using a function like:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"function add_source_to_ref(sys::System)\n    for g in get_components(StaticInjection, sys)\n        isa(g, ElectricLoad) && continue\n        g.bus.bustype == BusTypes.REF &&\n            error(\"A device is already attached to the REF bus\")\n    end\n\n    slack_bus = [b for b in get_components(Bus, sys) if b.bustype == BusTypes.REF][1]\n    inf_source = Source(\n        name = \"InfBus\", #name\n        available = true, #availability\n        activepower = 0.0,\n        reactivepower = 0.0,\n        bus = slack_bus, #bus\n        X_th = 5e-6, #Xth\n    )\n    add_component!(sys, inf_source)\n    return\nend\n\nadd_source_to_ref(omib_sys)","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"This function attempts to add a infinite source with X_th = 5cdot 10^-6 pu if no other device is already attached to the reference bus.","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"The system can be explored directly using functions like:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"collect(get_components(Source, omib_sys))\ncollect(get_components(Generators, omib_sys))","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"By exploring those it can be seen that the generators are named as: generator-bus_number-id. Then, the generator attached at bus 2 is simply named generator-102-1.","category":"page"},{"location":"Examples/example_data/#Dynamic-Injections","page":"Tutorial 0: Data Creation","title":"Dynamic Injections","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"We are now interested in attaching to the system the dynamic component that will be modeling our dynamic generator. Later versions will include a parser for .dyr files.","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Dynamic generator devices are composed by 5 components, namely, machine, shaft, avr, tg and pss. So we will be adding functions to create all of its components and the generator itself:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"#Machine\nmachine_classic() = BaseMachine(\n    0.0, #R\n    0.2995, #Xd_p\n    0.7087, #eq_p\n)\n\n#Shaft\nshaft_damping() = SingleMass(\n    3.148, #H\n    2.0, #D\n)\n\n#AVR\navr_none() = AVRFixed(0.0)\n#TG\ntg_none() = TGFixed(1.0) #efficiency\n#PSS\npss_none() = PSSFixed(0.0)\n\nfunction dyn_gen_classic(generator)\n    return DynamicGenerator(\n        generator,\n        1.0, #ω_ref\n        machine_classic(), #machine\n        shaft_damping(), #shaft\n        avr_none(), #avr\n        tg_none(), #tg\n        pss_none(), #pss\n    )\nend","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"The last function receives a static generator, and creates a DynamicGenerator based on that specific static generator, with the specific components defined previously. This is a classic machine model without AVR, Turbine Governor and PSS.","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Then we can simply create the dynamic generator as:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"#Collect the static gen in the system\nstatic_gen = get_component(Generator, omib_sys, \"generator-102-1\")\n#Creates the dynamic generator\ndyn_gen = dyn_gen_classic(static_gen)\n#Add the dynamic generator the system\nadd_component!(omib_sys, dyn_gen)","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Then we can simply export our system data to a json file that can be later read as:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"to_json(omib_sys, \"omib_sys.json\")","category":"page"},{"location":"Examples/example_data/#Dynamic-Lines-case:-Data-creation","page":"Tutorial 0: Data Creation","title":"Dynamic Lines case: Data creation","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"We will now create a three bus system with one inverter and one generator. In order to do so, we will parse the following ThreebusInverter.raw network:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"0, 100, 33, 0, 0, 60  / 24-Apr-2020 19:28:39 - MATPOWER 7.0.1-dev\n\n\n     101, 'BUS 1       ',       138, 3,    1,    1, 1,           1.02,        0,  1.1,  0.9,  1.1,  0.9\n     102, 'BUS 2       ',       138, 2,    1,    1, 1,           1.0142,           0,  1.1,  0.9,  1.1,  0.9\n     103, 'BUS 3       ',       138, 2,    1,    1, 1,           1.0059,           0,  1.1,  0.9,  1.1,  0.9\n0 / END OF BUS DATA, BEGIN LOAD DATA\n     101,  1, 1,    1,    1,       50,       10, 0, 0, 0, 0, 1, 1, 0\n     102,  1, 1,    1,    1,       100,      30, 0, 0, 0, 0, 1, 1, 0\n     103,  1, 1,    1,    1,       30,       10, 0, 0, 0, 0, 1, 1, 0\n0 / END OF LOAD DATA, BEGIN FIXED SHUNT DATA\n0 / END OF FIXED SHUNT DATA, BEGIN GENERATOR DATA\n     102,  1,       70,         0,       100,      -100,   1.0142, 0,     100, 0, 1, 0, 0, 1, 1, 100,       318,         0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1\n     103,  1,       80,         0,       100,      -100,   1.0059, 0,     100, 0, 1, 0, 0, 1, 1, 100,       318,         0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1\n0 / END OF GENERATOR DATA, BEGIN BRANCH DATA\n     101,      103, 1,  0.01000,     0.12,      0.2,     250,     250,     250, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1\n     101,      102, 1,  0.01000,     0.12,      0.2,     250,     250,     250, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1\n     102,      103, 1,  0.02000,     0.9,      1.0,     250,     250,     250, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1\n0 / END OF BRANCH DATA, BEGIN TRANSFORMER DATA\n0 / END OF TRANSFORMER DATA, BEGIN AREA DATA\n0 / END OF AREA DATA, BEGIN TWO-TERMINAL DC DATA\n0 / END OF TWO-TERMINAL DC DATA, BEGIN VOLTAGE SOURCE CONVERTER DATA\n0 / END OF VOLTAGE SOURCE CONVERTER DATA, BEGIN IMPEDANCE CORRECTION DATA\n0 / END OF IMPEDANCE CORRECTION DATA, BEGIN MULTI-TERMINAL DC DATA\n0 / END OF MULTI-TERMINAL DC DATA, BEGIN MULTI-SECTION LINE DATA\n0 / END OF MULTI-SECTION LINE DATA, BEGIN ZONE DATA\n0 / END OF ZONE DATA, BEGIN INTER-AREA TRANSFER DATA\n0 / END OF INTER-AREA TRANSFER DATA, BEGIN OWNER DATA\n0 / END OF OWNER DATA, BEGIN FACTS CONTROL DEVICE DATA\n0 / END OF FACTS CONTROL DEVICE DATA, BEGIN SWITCHED SHUNT DATA\n0 / END OF SWITCHED SHUNT DATA, BEGIN GNE DEVICE DATA\n0 / END OF GNE DEVICE DATA, BEGIN INDUCTION MACHINE DATA\n0 / END OF INDUCTION MACHINE DATA\nQ","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"That describes a three bus connected system, with generators connected at bus 2 and 3, and loads in three buses. We can load the system and attach an infinite source on the reference bus:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"sys_file_dir = \"ThreeBusInverter.raw\")\nthreebus_sys = System(sys_file_dir)\nadd_source_to_ref(threebus_sys)","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"We will connect a One-d-one-q machine at bus 102, and a Virtual Synchronous Generator Inverter at bus 103. An inverter is composed by a converter, outer control, inner control, dc source, frequency estimator and a filter.","category":"page"},{"location":"Examples/example_data/#Dynamic-Inverter-definition","page":"Tutorial 0: Data Creation","title":"Dynamic Inverter definition","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"We will create specific functions to create the components of the inverter as follows:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"#Define converter as an AverageConverter\nconverter_high_power() = AverageConverter(rated_voltage = 138.0, rated_current = 100.0)\n\n#Define Outer Control as a composition of Virtual Inertia + Reactive Power Droop\nfunction outer_control()\n    function virtual_inertia()\n        return VirtualInertia(Ta = 2.0, kd = 400.0, kω = 20.0)\n    end\n    function reactive_droop()\n        return ReactivePowerDroop(kq = 0.2, ωf = 1000.0)\n    end\n    return OuterControl(virtual_inertia(), reactive_droop())\nend\n\n#Define an Inner Control as a Voltage+Current Controler with Virtual Impedance:\ninner_control() = CurrentControl(\n    kpv = 0.59,     #Voltage controller proportional gain\n    kiv = 736.0,    #Voltage controller integral gain\n    kffv = 0.0,     #Binary variable enabling the voltage feed-forward in output of current controllers\n    rv = 0.0,       #Virtual resistance in pu\n    lv = 0.2,       #Virtual inductance in pu\n    kpc = 1.27,     #Current controller proportional gain\n    kic = 14.3,     #Current controller integral gain\n    kffi = 0.0,     #Binary variable enabling the current feed-forward in output of current controllers\n    ωad = 50.0,     #Active damping low pass filter cut-off frequency\n    kad = 0.2,      #Active damping gain\n)\n\n#Define DC Source as a FixedSource:\ndc_source_lv() = FixedDCSource(voltage = 600.0)\n\n#Define a Frequency Estimator as a PLL based on Vikram Kaura and Vladimir Blaskoc 1997 paper:\npll() = KauraPLL(\n    ω_lp = 500.0, #Cut-off frequency for LowPass filter of PLL filter.\n    kp_pll = 0.084,  #PLL proportional gain\n    ki_pll = 4.69,   #PLL integral gain\n)\n\n#Define an LCL filter:\nfilt() = LCLFilter(lf = 0.08, rf = 0.003, cf = 0.074, lg = 0.2, rg = 0.01)\n\n#Construct the Inverter:\nfunction inv_case78(static_device)\n    return DynamicInverter(\n        static_device,\n        1.0, # ω_ref,\n        converter_high_power(), #converter\n        outer_control(), #outer control\n        inner_control(), #inner control voltage source\n        dc_source_lv(), #dc source\n        pll(), #pll\n        filt(), #filter\n    )\nend","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"The last function receives a static device, typically a generator, and defines a dynamic inverter based on the components already defined.","category":"page"},{"location":"Examples/example_data/#Dynamic-Generator-definition","page":"Tutorial 0: Data Creation","title":"Dynamic Generator definition","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"Similarly we will construct a dynamic generator as follows:","category":"page"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"#Create the machine\nmachine_oneDoneQ() = OneDOneQMachine(\n    0.0, #R\n    1.3125, #Xd\n    1.2578, #Xq\n    0.1813, #Xd_p\n    0.25, #Xq_p\n    5.89, #Td0_p\n    0.6, #Tq0_p\n)\n\n#Shaft\nshaft_no_damping() = SingleMass(\n    3.01, #H (M = 6.02 -> H = M/2)\n    0.0,\n) #D\n\n#AVR: Type I: Resembles a DC1 AVR\navr_type1() = AVRTypeI(\n    20.0, #Ka - Gain\n    0.01, #Ke\n    0.063, #Kf\n    0.2, #Ta\n    0.314, #Te\n    0.35, #Tf\n    0.001, #Tr\n    5.0, #Vrmax\n    -5.0, #Vrmin\n    0.0039, #Ae - 1st ceiling coefficient\n    1.555, #Be - 2nd ceiling coefficient\n)\n\n#No TG\ntg_none() = TGFixed(1.0) #efficiency\n\n#No PSS\npss_none() = PSSFixed(0.0) #Vs\n\n#Construct the generator\nfunction dyn_gen_second_order(generator)\n    return DynamicGenerator(\n        generator,\n        1.0, # ω_ref,\n        machine_oneDoneQ(), #machine\n        shaft_no_damping(), #shaft\n        avr_type1(), #avr\n        tg_none(), #tg\n        pss_none(), #pss\n    )\nend","category":"page"},{"location":"Examples/example_data/#Add-the-components-to-the-system","page":"Tutorial 0: Data Creation","title":"Add the components to the system","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"for g in get_components(Generator, threebus_sys)\n    #Find the generator at bus 102\n    if get_number(get_bus(g)) == 102\n        #Create the dynamic generator\n        case_gen = dyn_gen_second_order(g)\n        #Attach the dynamic generator to the system\n        add_component!(threebus_sys, case_gen)\n    #Find the generator at bus 103\n    elseif get_number(get_bus(g)) == 103\n        #Create the dynamic inverter\n        case_inv = inv_case78(g)\n        #Attach the dynamic inverter to the system\n        add_component!(threebus_sys, case_inv)\n    end\nend","category":"page"},{"location":"Examples/example_data/#Save-the-system-in-a-JSON-file","page":"Tutorial 0: Data Creation","title":"Save the system in a JSON file","text":"","category":"section"},{"location":"Examples/example_data/","page":"Tutorial 0: Data Creation","title":"Tutorial 0: Data Creation","text":"to_json(threebus_sys, \"threebus_sys.json\")","category":"page"},{"location":"Models/srf/#Reference-Frames","page":"Reference Frames","title":"Reference Frames","text":"","category":"section"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"Each dynamic device is defined in its own dq synchronous reference frame (SRF). It is important to note that there are several conventions to do reference frame transformations.","category":"page"},{"location":"Models/srf/#Synchronous-Machines","page":"Reference Frames","title":"Synchronous Machines","text":"","category":"section"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"The grid is modeled in its own real-imaginary (RI) reference frame. With such, this follows the standard convention that for a voltage angle theta = 0, there is no imaginary part and hence v_h = v_r + j0. Traditionally, the reference frame dq with rotor angle delta for synchronous machines connected to a bus v_hangle theta = v_r + jv_i follows the following convention for transformation of per-unit RMS phasors:","category":"page"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-(delta- pi2) tag1a \nv_d =  v_h sin(delta - theta) tag1b \nv_q = v_h cos(delta - theta) tag1c  \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag1d  \nendalign","category":"page"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"Note that hence in a bus of 10angle 0, a rotor angle of delta = 0 implies that v_q = 10 and v_d = 00. This transformation is the one that can be found in most books of Power Systems, such as Kundur, Sauer Pai and in Milano too, and is the convention used in the software to model dynamic models of synchronous machines in their own reference frame.","category":"page"},{"location":"Models/srf/#Inverters","page":"Reference Frames","title":"Inverters","text":"","category":"section"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"The previously convention is not the standard one used for modeling inverters. Most of inverter and phase-lock loop (PLL) models follow the next convention:","category":"page"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-delta tag2a  \nv_d =  v_h cos(delta - theta) tag2b \nv_q = -v_h sin(delta - theta) tag2c \nendalign","category":"page"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"That, contrary to the previous case, when delta = theta = 0 implies that v_d = 10 and v_q = 00. This yields the typical PLL conditions that steer v_q to 0 when delta locks in theta, or when both SRF lock between each other. ","category":"page"},{"location":"Models/srf/#Transformation-used","page":"Reference Frames","title":"Transformation used","text":"","category":"section"},{"location":"Models/srf/","page":"Reference Frames","title":"Reference Frames","text":"Given the predominancy of both convention in current work, the software uses both conventions depending on the device modeled. For synchronous machines we used the standard convention (1a)-(1d), while for inverter models we use the predominant convention used nowadays in such models, i.e. (2a)-(2c).","category":"page"},{"location":"Examples/example_lines/#Tutorial:-Dynamic-Lines","page":"Tutorial 2: Dynamic Lines","title":"Tutorial: Dynamic Lines","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial will introduce an example of considering dynamic lines in PowerSimulationsDynamics. Note that this tutorial is for PowerSimulationsDynamics.","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial presents a simulation of a three-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1, a one d- one q- machine on bus 2 and an inverter of 19 states, as a virtual synchronous machine at bus 3. The perturbation will be the trip of two of the three circuits (triplicating its resistance and impedance) of the line that connects bus 1 and bus 3. This case also consider a dynamic line model for connection between buses 2 and 3. We will compare it against a system without dynamic lines.","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"It is recommended to check Tutorial 1: OMIB first, since that includes more details and explanations on all definitions and functions.","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"This tutorial can be found on PowerSimulationsDynamics/Examples repository.","category":"page"},{"location":"Examples/example_lines/#Step-1:-Package-Initialization","page":"Tutorial 2: Dynamic Lines","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"using PowerSimulationsDynamics\nusing PowerSystems\nusing Sundials\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_lines/#Step-2:-Data-creation","page":"Tutorial 2: Dynamic Lines","title":"Step 2: Data creation","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"We will load two systems already defined in Tutorial 0:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"threebus_sys = System(\"threebus_sys.json\")","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"In addition, we will create a new copy of the system on which we will simulate the same case, but will consider dynamic lines:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"threebus_sys_dyn = deepcopy(threebus_sys)","category":"page"},{"location":"Examples/example_lines/#Step-3:-Create-the-fault-and-simulation-on-the-Static-Lines-system","page":"Tutorial 2: Dynamic Lines","title":"Step 3: Create the fault and simulation on the Static Lines system","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"First, we construct the perturbation, by properly computing the new Ybus on the system:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Make a copy of the original system\nsys2 = deepcopy(threebus_sys)\n#Triplicates the impedance of the line named \"1\"\nfault_branches = get_components(ACBranch, sys2)\nfor br in fault_branches\n    if get_name(br) == \"1\"\n        br.r = 3 * br.r\n        br.x = 3 * br.x\n        b_new = (from = br.b.from / 3, to = br.b.to / 3)\n        br.b = b_new\n    end\nend\n#Obtain the new Ybus\nYbus_fault = Ybus(sys2).data\n#Define Fault: Change of YBus\nYbus_change = PowerSimulationsDynamics.ThreePhaseFault(\n    1.0, #change at t = 1.0\n    Ybus_fault, #New YBus\n)","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"Now, we construct the simulation:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Time span of our simulation\ntspan = (0.0, 30.0)\n\n#Define Simulation\nsim = Simulation(\n    pwd(), #folder to output results\n    threebus_sys, #system\n    tspan, #time span\n    Ybus_change, #Type of perturbation\n)","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"We can obtain the initial conditions as:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Will print the initial states. It also give the symbols used to describe those states.\nprint_device_states(sim)\n#Will export a dictionary with the initial condition values to explore\nx0_init = get_initial_conditions(sim)","category":"page"},{"location":"Examples/example_lines/#Step-4:-Run-the-simulation-of-the-Static-Lines-System","page":"Tutorial 2: Dynamic Lines","title":"Step 4: Run the simulation of the Static Lines System","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Run the simulation\nrun_simulation!(sim, #simulation structure\n                IDA(), #Sundials DAE Solver\n                dtmax = 0.02, #Maximum step size\n)","category":"page"},{"location":"Examples/example_lines/#Step-5:-Store-the-solution","page":"Tutorial 2: Dynamic Lines","title":"Step 5: Store the solution","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"series2 = get_voltagemag_series(sim, 102)\nzoom = [\n        (series2[1][ix], series2[2][ix])\n        for (ix, s) in enumerate(series2[1]) if (s > 0.90 && s < 1.6)\n    ];","category":"page"},{"location":"Examples/example_lines/#Step-3.1:-Create-the-fault-and-simulation-on-the-Dynamic-Lines-system","page":"Tutorial 2: Dynamic Lines","title":"Step 3.1: Create the fault and simulation on the Dynamic Lines system","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"An important aspect to consider is that DynamicLines must not be considered in the computation of the Ybus. First we construct the Dynamic Line, by finding the Line named \"3\", and then adding it to the system.","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"# get component return the Branch on threebus_sys_dyn named \"3\"\ndyn_branch = DynamicBranch(get_component(Branch, threebus_sys_dyn, \"3\"))\n# Adding a dynamic line will inmediately remove the static line from the system.\nadd_component!(threebus_sys_dyn, dyn_branch)","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"Similarly, we construct the Ybus fault by creating a copy of the original system, but removing the Line \"3\" to avoid considering it in the Ybus:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Make a copy of the original system\nsys3 = deepcopy(threebus_sys)\n#Remove Line \"3\"\nremove_component!(Line, sys3, \"3\")\n#Triplicates the impedance of the line named \"1\"\nfault_branches2 = get_components(Line, sys3)\nfor br in fault_branches2\n    if get_name(br) == \"1\"\n        br.r = 3 * br.r\n        br.x = 3 * br.x\n        b_new = (from = br.b.from / 3, to = br.b.to / 3)\n        br.b = b_new\n    end\nend\n#Obtain the new Ybus\nYbus_fault_dyn = Ybus(sys3).data\n#Define Fault: Change of YBus\nYbus_change_dyn = PowerSimulationsDynamics.ThreePhaseFault(\n    1.0, #change at t = 1.0\n    Ybus_fault_dyn, #New YBus\n)","category":"page"},{"location":"Examples/example_lines/#Step-4.1:-Run-the-simulation-of-the-Dynamic-Lines-System","page":"Tutorial 2: Dynamic Lines","title":"Step 4.1: Run the simulation of the Dynamic Lines System","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Run the simulation\nrun_simulation!(sim, #simulation structure\n                IDA(), #Sundials DAE Solver\n                dtmax = 0.02, #Maximum step size\n)","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"Now, we construct the simulation:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Time span of our simulation\ntspan = (0.0, 30.0)\n\n#Define Simulation\nsim_dyn = Simulation(\n    pwd(), #folder to output results\n    threebus_sys_dyn, #system\n    tspan, #time span\n    Ybus_change_dyn, #Type of perturbation\n)","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"We can obtain the initial conditions as:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"#Will print the initial states. It also give the symbols used to describe those states.\nprint_device_states(sim_dyn)\n#Will export a dictionary with the initial condition values to explore\nx0_init_dyn = get_initial_conditions(sim_dyn)","category":"page"},{"location":"Examples/example_lines/#Step-5.1:-Store-the-solution","page":"Tutorial 2: Dynamic Lines","title":"Step 5.1: Store the solution","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"series2_dyn = get_voltagemag_series(sim_dyn, 102)\nzoom_dyn = [\n        (series2_dyn[1][ix], series2_dyn[2][ix])\n        for (ix, s) in enumerate(series2_dyn[1]) if (s > 0.90 && s < 1.6)\n    ];","category":"page"},{"location":"Examples/example_lines/#Step-6.1:-Compare-the-solutions:","page":"Tutorial 2: Dynamic Lines","title":"Step 6.1: Compare the solutions:","text":"","category":"section"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"We can observe the effect of Dynamic Lines","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"using Plots\nplot(series2_dyn, label=\"V_gen_dyn\")\nplot!(series2, label=\"V_gen_st\", xlabel=\"Time [s]\", ylabel = \"Voltage [pu]\")","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"<img src=\"../../assets/voltage_lines.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"⠀ that looks quite similar. The differences can be observed in the zoom plot:","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"plot(zoom_dyn, label=\"V_gen_dyn\")\nplot!(zoom, label=\"V_gen_st\", xlabel=\"Time [s]\", ylabel = \"Voltage [pu]\")","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"<img src=\"../../assets/voltage_zoom_lines.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_lines/","page":"Tutorial 2: Dynamic Lines","title":"Tutorial 2: Dynamic Lines","text":"⠀","category":"page"},{"location":"docs/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"docs/#Requirements","page":"Documentation","title":"Requirements","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Pkg.add(\"Documenter\")","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"pip install ghp-import","category":"page"},{"location":"docs/#Run","page":"Documentation","title":"Run","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"cd docs\nmake html\nopen build/index.html","category":"page"},{"location":"Models/network/#Network-model","page":"Network","title":"Network model","text":"","category":"section"},{"location":"Models/network/","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in PowerSimulationsDynamics.jl. This is based on a standard current injection model as defined in Federico Milano's book: Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"Models/network/","page":"Network","title":"Network","text":"In simple terms, PowerSimulationsDynamics.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"Models/network/","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolx\n endalign","category":"page"},{"location":"Models/network/","page":"Network","title":"Network","text":"where boldsymboli is the vector of the sum of complex current injections from devices, boldsymbolx is the vector of states and boldsymbolv is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"Models/network/#Static-Branches-(or-simply-Branches)","page":"Network","title":"Static Branches (or simply Branches)","text":"","category":"section"},{"location":"Models/network/#Lines","page":"Network","title":"Lines","text":"","category":"section"},{"location":"Models/network/","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"Models/network/","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"Models/network/#Two-Windings-Transformers","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"Models/network/","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"Models/network/#Dynamic-Branches","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"Models/network/","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"Models/network/","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdi_elldt = (v_n - v_m) - (r+jl) i_ell \n     fracc_nOmega_b fracdv_ndt =  i_n^textcap - jc_nv_n   \n      fracc_mOmega_b fracdv_mdt = i_m^textcap - jc_mv_m\nendalign","category":"page"},{"location":"Models/network/","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"Models/small/#Small-Signal-Analysis","page":"Small Signal","title":"Small Signal Analysis","text":"","category":"section"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"Here we discuss the method used to do a small signal analysis on the DAE system defined in PowerSimulationsDynamics.jl. The package defines algebraic variables for both real and imaginary voltages on all buses (except if they have a dynamic line connected, on which the voltage of those buses are treated as differential variables). In addition, each dynamic device can add differential variables (or states) that are concatenated to construct the system of differential algebraic equations.","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"We define y as the vector of algebraic variables, x as the vector of differential variables (states) and p the parameters of the system, we can define g(yxp) as the vector of algebraic equations and f(yxp) as the vector of differential equations. With that, the non-linear differential algebraic system of equations can be written as:","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  dotx\n  endarrayright = leftbeginarrayc\n  g(yxp) \n   f(yxp) endarrayright\nendalign","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"For small signal analysis, we are interested in the stability around an equilbrium point y_eqx_eq that satisfies dotx = 0 or equivalently f(y_eqx_eqp) = 0, while obviously satisfying g(y_eq x_eq p) = 0. To do that we use a first order approximation:","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  Deltadotx\n  endarrayright = underbraceleftbeginarray\n  g(y_eqx_eqp) \n   f(y_eqx_eqp) endarrayright_ = 0\n + Jy_eq x_eq p leftbeginarrayc\n Delta y \n  Delta x\n  endarrayright\n  endalign","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"The first to note is that the jacobian matrix can be splitted in 4 blocks depending on the specific variables we are taking the partial derivatives:","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJy_eq x_eq p =\nleftbeginarraycc\n g_y  g_x \n f_y  f_x \n  endarrayright\nendalign","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"For small signal analyses, we are interested in the stability of the differential states, while still considering that those need to evolve in the manifold defined by the linearized algebraic equations. Assuming that g_y is not singular (see chapter 7 of Federico Milano's book: \"Power System Modelling and Scripting\" or the following paper) we can eliminate the algebraic variables to obtain the reduced jacobian:","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJ_textred = f_x - f_y g_y^-1 g_x\nendalign","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"that defines our reduced system for the differential variables","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nDelta dotx = J_textred Delta x\nendalign","category":"page"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"on which we can compute its eigenvalues to analyze local stability.","category":"page"},{"location":"Models/small/#Automatic-Differentiation","page":"Small Signal","title":"Automatic Differentiation","text":"","category":"section"},{"location":"Models/small/","page":"Small Signal","title":"Small Signal","text":"Once an equilibrium point is found, the complete jacobian of the non-linear system can be obtained using automatic differentiation in Julia. In particular, the package ForwardDiff.jl is used to obtain the jacobian of the non-linear algebraic system of equations. PowerSimulationsDynamics.jl handles the resulting jacobian and reports the reduced jacobian and the corresponding eigenvalues and eigenvectors.","category":"page"},{"location":"Models/gens/#Generator-Models","page":"Generator","title":"Generator Models","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"Here we discuss the structure and models used to model generators in PowerSimulationsDynamics.jl. Each generator is a data structure that is defined by the following components:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"The following figure summarizes the components of a generator and which variables they share:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"<img src=\"../../assets/gen_metamodel.png\" width=\"75%\"/>","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"⠀","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"Models are based from Federico Milano's book: \"Power System Modelling and Scripting\" and Prabha Kundur's book: \"Power System's Stability and Control\" and structures are defined in PowerSystems.jl abbreviated as PSY.","category":"page"},{"location":"Models/gens/#Machines","page":"Generator","title":"Machines","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"Models/gens/#Classical-Model-(Zero-Order)-[BaseMachine]","page":"Generator","title":"Classical Model (Zero Order) [BaseMachine]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"Models/gens/#One-d-One-q-Model-(2th-Order)-[OneDOneQMachine]","page":"Generator","title":"One d- One q- Model (2th Order) [OneDOneQMachine]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"Models/gens/#Marconato-Machine-(6th-Order)-[MarconatoMachine]","page":"Generator","title":"Marconato Machine (6th Order) [MarconatoMachine]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"Models/gens/#Simplified-Marconato-Machine-(4th-Order)-[SimpleMarconatoMachine]","page":"Generator","title":"Simplified Marconato Machine (4th Order) [SimpleMarconatoMachine]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"Models/gens/#Anderson-Fouad-Machine-(6th-Order)-[AndersonFouadMachine]","page":"Generator","title":"Anderson-Fouad Machine (6th Order) [AndersonFouadMachine]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"Models/gens/#Simplified-Anderson-Fouad-Machine-(4th-Order)-[SimpleAFMachine]","page":"Generator","title":"Simplified Anderson-Fouad Machine (4th Order) [SimpleAFMachine]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"Models/gens/#Shafts","page":"Generator","title":"Shafts","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"Models/gens/#Rotor-Mass-Shaft-[SingleMass]","page":"Generator","title":"Rotor Mass Shaft [SingleMass]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag8a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag8b\nendalign","category":"page"},{"location":"Models/gens/#Five-Mass-Shaft-[FiveMassShaft]","page":"Generator","title":"Five-Mass Shaft [FiveMassShaft]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag9a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag9b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag9c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag9d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag9e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag9f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag9g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag9h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag9i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag9j\nendalign","category":"page"},{"location":"Models/gens/#Automatic-Voltage-Regulators-(AVR)","page":"Generator","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"AVR are used to determine the voltage in the field winding v_f in the model.","category":"page"},{"location":"Models/gens/#Fixed-AVR-[AVRFixed]","page":"Generator","title":"Fixed AVR [AVRFixed]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"Models/gens/#Simple-AVR-[AVRSimple]","page":"Generator","title":"Simple AVR [AVRSimple]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag10a\nendalign","category":"page"},{"location":"Models/gens/#AVR-Type-I-[AVRTypeI]","page":"Generator","title":"AVR Type I [AVRTypeI]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag11a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag11b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag11c \ndotv_m = frac1T_r (v_h - v_m) tag11d\nendalign","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"with the ceiling function:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"Models/gens/#AVR-Type-II-[AVRTypeII]","page":"Generator","title":"AVR Type II [AVRTypeII]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag12a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag12b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag12c \ndotv_m = frac1T_r (v_h - v_m) tag12d\nendalign","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"Models/gens/#Power-System-Stabilizers-(PSS)","page":"Generator","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"PSS are used to add an additional signal v_s to the field voltage: v_f = v_f^textavr + v_s.","category":"page"},{"location":"Models/gens/#Fixed-PSS-[PSSFixed]","page":"Generator","title":"Fixed PSS [PSSFixed]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"Models/gens/#Simple-PSS-[PSSSimple]","page":"Generator","title":"Simple PSS [PSSSimple]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is simply a proportional controller over the frequency and electrical power:","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag12a\nendalign","category":"page"},{"location":"Models/gens/#Prime-Movers-and-Turbine-Governors-(TG)","page":"Generator","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"Models/gens/#Fixed-TG-[TGFixed]","page":"Generator","title":"Fixed TG [TGFixed]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"Models/gens/#TG-Type-I-[TGTypeI]","page":"Generator","title":"TG Type I [TGTypeI]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag13a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag13b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag13c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag13d\nendalign","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"with","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 1)\nendalign*","category":"page"},{"location":"Models/gens/#TG-Type-II-[TGTypeII]","page":"Generator","title":"TG Type II [TGTypeII]","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag14a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag14b\nendalign","category":"page"},{"location":"Models/gens/#Reference","page":"Generator","title":"Reference","text":"","category":"section"},{"location":"Models/gens/","page":"Generator","title":"Generator","text":"For constructors check the API on PowerSystems.jl documentation","category":"page"},{"location":"Examples/example_OMIB/#Tutorial:-One-Machine-against-Infinite-Bus-(OMIB)","page":"Tutorial 1: OMIB","title":"Tutorial: One Machine against Infinite Bus (OMIB)","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial will introduce you to the functionality of PowerSimulationsDynamics for running Power System Simulations. Note that this tutorial is for PowerSimulationsDynamics. Current version already have a dedicated function to find an equilibrium point using a Power Flow method without relying in a guess of the initial condition.","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial presents a simulation of a two-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1 and a classic machine on bus 2. The perturbation will be the trip of one of the two circuits (doubling its resistance and impedance) of the line that connects both buses.","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This tutorial can be found on PowerSimulationsDynamics/Examples repository.","category":"page"},{"location":"Examples/example_OMIB/#Step-1:-Package-Initialization","page":"Tutorial 1: OMIB","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The first step consists in initialize all packages that will be used to run the simulation. All the necessary packages are listed:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"using PowerSimulationsDynamics\nusing PowerSystems\nusing Sundials\nconst PSY = PowerSystems","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"PowerSystems is used to properly define the data structure, while Sundials is used to solve the problem defined in PowerSimulationsDynamics. We use PSY to abbreviate the PowerSystems.jl package.","category":"page"},{"location":"Examples/example_OMIB/#Step-2:-Load-the-system","page":"Tutorial 1: OMIB","title":"Step 2: Load the system","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"We will load the system using the JSON file created in Tutorial 0:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"omib_sys = System(\"omib_sys.json\")","category":"page"},{"location":"Examples/example_OMIB/#Step-3:-Build-the-simulation-and-initializing-the-problem","page":"Tutorial 1: OMIB","title":"Step 3: Build the simulation and initializing the problem","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The next step is to create the simulation structure. This will create the indexing of our system that will be used to formulate the differential-algebraic system of equations. To do so, it is required to specify the perturbation that will occur in the system. PowerSimulationsDynamics support two types of perturbations:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Three Phase Fault\nChange in Reference Parameter","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"In here, he will use a Three Phase Fault, that is modeled by modifying the admittance matrix of the system. To do so we create a ThreePhaseFault perturbation as follows:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Compute the Y_bus after fault\n#Collect the branch of the system as:\nfault_branch = deepcopy(collect(get_components(Branch, omib_sys))[1])\n#Duplicates the impedance of the reactance\nfault_branch.x = fault_branch.x * 2\n#Obtain the new Ybus of the faulted system\nYbus_fault = Ybus([fault_branch], get_components(Bus, omib_sys))[:, :]\n\n#Construct the perturbation\nperturbation_Ybus = ThreePhaseFault(\n    1.0, #change will occur at t = 1.0s\n    Ybus_fault, #new Ybus\n)","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"With this, we are ready to create our simulation structure. To construct our simulation we use:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Time span of our simulation\ntspan = (0.0, 30.0)\n\n#Define Simulation\nsim = Simulation(\n    pwd(),\n    sys, #system\n    tspan, #time span\n    perturbation_Ybus, #Type of perturbation\n)","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"This will correctly initialize the system. It essentially will run a power flow and update V_ref, P_ref and hence eq_p (the internal voltage) to match the solution of the power flow. It will also initialize the states in the equilibrium.","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Will print the initial states. It also give the symbols used to describe those states.\nprint_device_states(sim)\n#Will export a dictionary with the initial condition values to explore\nx0_init = get_initial_conditions(sim)","category":"page"},{"location":"Examples/example_OMIB/#Step-4:-Run-the-Simulation","page":"Tutorial 1: OMIB","title":"Step 4: Run the Simulation","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"Finally, to run the simulation we simply use:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"#Solve problem\nrun_simulation!(sim, #simulation structure\n                IDA(), #Sundials DAE Solver\n                dtmax=0.02); #Arguments: Maximum timestep allowed","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"In some cases, the dynamic time step used for the simulation may fail. In such case, the keyword argument dtmax can be used to limit the maximum time step allowed for the simulation.","category":"page"},{"location":"Examples/example_OMIB/#Step-5:-Exploring-the-solution","page":"Tutorial 1: OMIB","title":"Step 5: Exploring the solution","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"After running the simulation, our simulation structure sim will have the solution. For that sim.solution can be used to explore the solution structure. In this case sim.solution.t returns the vector of time, while sim.solution.u return the array of states. In addition, PowerSimulationsDynamics have two functions to obtain different states of the solution:","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"get_state_series(sim, (\"generator-102-1\", :δ)): can be used to obtain the solution as a tuple of time and the required state. In this case, we are obtaining the rotor angle :δ of the generator named \"generator-102-1\".\nget_voltagemag_series(sim, 102): can be used to obtain the voltage magnitude as a tuple of time and voltage. In this case, we are obtaining the voltage magnitude at bus 102 (where the generator is located).","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"using Plots\nangle = get_state_series(sim, (\"generator-102-1\", :δ))\nplot(angle, xlabel=\"time\", ylabel=\"rotor angle [rad]\", label=\"rotor angle\")\n\nvolt = get_voltagemag_series(sim, 102)\nplot(volt, xlabel=\"time\", ylabel=\"Voltage [pu]\", label=\"V_2\")","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"<img src=\"../../assets/rotor_angle_OMIB.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"⠀","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"<img src=\"../../assets/voltage_OMIB.png\" width=\"75%\"/>","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"⠀","category":"page"},{"location":"Examples/example_OMIB/#Optional:-Small-Signal-Analysis","page":"Tutorial 1: OMIB","title":"Optional: Small Signal Analysis","text":"","category":"section"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"PowerSimulationsDynamics uses automatic differentiation to compute the reduced Jacobian of the system for the differential states. This can be used to analyze the local stability of the linearized system.","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"small_sig = small_signal_analysis(sim)","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"The small_sig result can report the reduced jacobian for delta and omega, and can also be used to report the eigenvalues of the reduced linearized system.","category":"page"},{"location":"Examples/example_OMIB/","page":"Tutorial 1: OMIB","title":"Tutorial 1: OMIB","text":"small_sig.reduced_jacobian\n\nsmall_sig.eigenvalues","category":"page"},{"location":"Models/inverters/#Inverter-Models","page":"Inverter","title":"Inverter Models","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"Here we discuss the structure and models used to model inverters in PowerSimulationsDynamics.jl. Each inverter is a data structure that is defined by the following components:","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"<img src=\"../../assets/inv_metamodel.png\" width=\"75%\"/>","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"⠀","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"Models are based from the paper: \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\" from S. D'Arco, J.A. Suul and O.B. Fosso, and structures are defined in PowerSystems.jl abbreviated as PSY.","category":"page"},{"location":"Models/inverters/#DC-Source","page":"Inverter","title":"DC Source","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"Models/inverters/#Fixed-DC-Source-[FixedDCSource]","page":"Inverter","title":"Fixed DC Source [FixedDCSource]","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"Models/inverters/#Frequency-Estimators","page":"Inverter","title":"Frequency Estimators","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"Models/inverters/#Phase-Locked-Loop-(PLL)-for-VSM-[KauraPLL]","page":"Inverter","title":"Phase-Locked Loop (PLL) for VSM [KauraPLL]","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control deltatheta_textolc and the PLL one deltatheta_textpll. The notation used a deltatheta to refer as the variation of the respective angle theta with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\n\ndotv_dtextpll = omega_textlp left v_dtextout - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndotdeltatheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\ndeltaomega_textpll = k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e \nv_dtextout + jv_qtextout = (v_r + v_i)e^-deltatheta_textpll  tag1f\nendalign","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring.","category":"page"},{"location":"Models/inverters/#Outer-Loop-Controls","page":"Inverter","title":"Outer Loop Controls","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"This component defines controllers for both active and reactive power","category":"page"},{"location":"Models/inverters/#Virtual-Inertia-and-Q-droop-[OuterControl]","page":"Inverter","title":"Virtual Inertia and Q-droop [OuterControl]","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. The constructor is OuterControl{VirtualInertia, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\n    dotdeltaomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textolc - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag2a \n    dotdeltatheta_textolc = Omega_b deltaomega_textolc tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\n    p_e = v_di_d + v_qi_q tag2d \n    q_e = v_qi_d - v_di_q tag2e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2f\nendalign","category":"page"},{"location":"Models/inverters/#Inner-Loop-Controls","page":"Inverter","title":"Inner Loop Controls","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"This component defines voltage and current controllers to generate the reference signal for the converter.","category":"page"},{"location":"Models/inverters/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-[CurrentControl]","page":"Inverter","title":"Integrated Virtual Impedance, Voltage and Current Controller [CurrentControl]","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag3a \n    dotxi_q = v_qtextvi^textref - v_q tag3b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag3c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag3d \n    dotphi_d = omega_textad(v_d - phi_d) tag3e \n    dotphi_q = omega_textad(v_q - phi_q) tag3f\nendalign*","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"with","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag3g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag3h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_qright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag3i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag3j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag3k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag3l\nendalign","category":"page"},{"location":"Models/inverters/#Converter","page":"Inverter","title":"Converter","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"Models/inverters/#Average-Model-[AverageConverter]","page":"Inverter","title":"Average Model [AverageConverter]","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"The average model simply output the desired reference signal since:","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag4a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag4b\nendalign","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"Models/inverters/#Filters","page":"Inverter","title":"Filters","text":"","category":"section"},{"location":"Models/inverters/#LCL-Filter-[LCLFilter]","page":"Inverter","title":"LCL Filter [LCLFilter]","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_d and v_q are voltages in the capacitor, while v_d^textgrid and v_q^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"beginalign\n    doti_dtextcv = fracOmega_bl_fleft( v_d^textcv - v_d  - r_f i_dtextcv + omega_textgrid l_f i_qtextcv right) tag5a \n    doti_qtextcv = fracOmega_bl_fleft( v_q^textcv - v_q  - r_f i_qtextcv - omega_textgrid l_f i_dtextcv right) tag5b \n    dotv_d =  fracOmega_bc_fleft( i_d^textcv - i_d + omega_textgrid c_f v_q right) tag5c \n    dotv_q =  fracOmega_bc_fleft( i_q^textcv - i_q - omega_textgrid c_f v_d right) tag5d \n    doti_d = fracOmega_bl_gleft( v_d^textcv - v_d^textgrid - r_g i_d + omega_textgrid l_g i_qtextcv right) tag5e \n    doti_q = fracOmega_bl_gleft( v_q^textcv - v_q^textgrid - r_g i_q - omega_textgrid l_g i_dtextcv right) tag5f\nendalign","category":"page"},{"location":"Models/inverters/#Reference","page":"Inverter","title":"Reference","text":"","category":"section"},{"location":"Models/inverters/","page":"Inverter","title":"Inverter","text":"For constructors check the API on PowerSystems.jl documentation","category":"page"},{"location":"api/LITS/#PowerSimulationsDynamics","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"","category":"section"},{"location":"api/LITS/","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/LITS/","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"API documentation","category":"page"},{"location":"api/LITS/","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"Pages = [\"PowerSimulationsDynamics.md\"]","category":"page"},{"location":"api/LITS/#Index","page":"PowerSimulationsDynamics","title":"Index","text":"","category":"section"},{"location":"api/LITS/","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"Pages = [\"PowerSimulationsDynamics.md\"]","category":"page"},{"location":"api/LITS/#Exported","page":"PowerSimulationsDynamics","title":"Exported","text":"","category":"section"},{"location":"api/LITS/","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"Modules = [PowerSimulationsDynamics]\nPrivate = false","category":"page"},{"location":"api/LITS/#PowerSimulationsDynamics.get_initial_conditions-Tuple{Simulation}","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.get_initial_conditions","text":"Returns a Dictionary with the resulting initial conditions of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.get_voltagemag_series-Tuple{Simulation,Int64}","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.get_voltagemag_series","text":"Function to obtain the voltage magnitude series out of the DAE Solution. It receives the solution, the dynamical system and the bus number.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.print_device_states-Tuple{Simulation}","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.print_device_states","text":"Function to print initial states. It receives the vector of initial states and the dynamical system.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.print_init_states-Tuple{Simulation}","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.print_init_states","text":"Function to print initial states. It receives the vector of initial states and the dynamical system.\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#Internal","page":"PowerSimulationsDynamics","title":"Internal","text":"","category":"section"},{"location":"api/LITS/","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics","text":"Modules = [PowerSimulationsDynamics]\nPublic = false","category":"page"},{"location":"api/LITS/#PowerSimulationsDynamics.configure_logging-Tuple{}","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,PowerSystems.DynamicGenerator{PowerSystems.AndersonFouadMachine,S,A,TG,P}}} where P<:PowerSystems.PSS where TG<:PowerSystems.TurbineGov where A<:PowerSystems.AVR where S<:PowerSystems.Shaft","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,PowerSystems.DynamicGenerator{PowerSystems.BaseMachine,S,A,TG,P}}} where P<:PowerSystems.PSS where TG<:PowerSystems.TurbineGov where A<:PowerSystems.AVR where S<:PowerSystems.Shaft","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 0-state synchronous (classic model) machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,PowerSystems.DynamicGenerator{PowerSystems.MarconatoMachine,S,A,TG,P}}} where P<:PowerSystems.PSS where TG<:PowerSystems.TurbineGov where A<:PowerSystems.AVR where S<:PowerSystems.Shaft","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,PowerSystems.DynamicGenerator{PowerSystems.OneDOneQMachine,S,A,TG,P}}} where P<:PowerSystems.PSS where TG<:PowerSystems.TurbineGov where A<:PowerSystems.AVR where S<:PowerSystems.Shaft","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,PowerSystems.DynamicGenerator{PowerSystems.SimpleAFMachine,S,A,TG,P}}} where P<:PowerSystems.PSS where TG<:PowerSystems.TurbineGov where A<:PowerSystems.AVR where S<:PowerSystems.Shaft","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any,PowerSystems.DynamicGenerator{PowerSystems.SimpleMarconatoMachine,S,A,TG,P}}} where P<:PowerSystems.PSS where TG<:PowerSystems.TurbineGov where A<:PowerSystems.AVR where S<:PowerSystems.Shaft","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/LITS/#PowerSimulationsDynamics.kirchoff_laws!-NTuple{6,Any}","page":"PowerSimulationsDynamics","title":"PowerSimulationsDynamics.kirchoff_laws!","text":"Kirchoff law for buses.\nI_gen_r[j]: Real current injection from all generators connected at bus j.\n            It is zero if no generator is connected at bus j.\nI_gen_i[j]: Real current injection from all generators connected at bus j.\n            It is zero if no generator is connected at bus j.\n\n\n\n\n\n","category":"method"},{"location":"#PowerSimulationsDynamics.jl","page":"Home","title":"PowerSimulationsDynamics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerSimulationsDynamics.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install it by typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PowerSimulationsDynamics","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once installed, the PowerSimulationsDynamics package can by used by typing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PowerSimulationsDynamics","category":"page"},{"location":"#Structure","page":"Home","title":"Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following figure shows the interactions between PowerSimulationsDynamics.jl, PowerSystems.jl, DifferentialEquations.jl and the integrators. The architecture of PowerSimulationsDynamics.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated through DifferentialEquations.jl's common-interface enabling the use of any solver available in Julia. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular SUNDIALS since it has exceptional features applicable to large models — for instance, interfacing with distributed linear-solvers and GPU arrays. In addition, automatic differentiation is implemented using ForwardDiff.jl to obtain jacobians to perform small signal analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img src=\"./assets/SoftwareLoop.png\" width=\"65%\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"⠀","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"Examples/example_data.md\",\n  \"Examples/example_OMIB.md\",\n  \"Examples/example_lines.md\",\n  \"Models/network.md\",\n  \"Models/srf.md\",\n  \"Models/gens.md\",\n  \"Models/inverters.md\",\n  \"Models/small.md\",\n]","category":"page"}]
}
