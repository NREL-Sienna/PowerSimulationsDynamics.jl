var documenterSearchIndex = {"docs":
[{"location":"execute/#Executing-a-Simulation","page":"Simulation Execution","title":"Executing a Simulation","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"After constructing the System data from PowerSystems.jl with its dynamic components, a Simulation structure must be constructed. Check the API for Simulation and Simulation! for its construction and available arguments.","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Once a Simulation is constructed and properly initialized, the execute! command is used to run the Simulation. If no perturbation was included, then a steady state simulation will be run over the time span defined. See the API of execute! for more details.","category":"page"},{"location":"execute/#Solvers","page":"Simulation Execution","title":"Solvers","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Solvers must be chosen accordingly depending on the type of model used in the Simulation. For example, a Residual model can be executed using Sundials IDA solver:","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"using Sundials\nsim = Simulation(\n    ResidualModel,\n    sys,\n    pwd(),\n    (0.0, 20.0),\n    perturbation,\n)\nexecute!(sim, IDA())","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Results can be explored using:","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"results = read_results(sim)","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Similarly, a Mass Matrix model can be executed using Rodas4 solver.","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"using OrdinaryDiffEq\nsim2 = Simulation(\n    ResidualModel,\n    sys,\n    pwd(),\n    (0.0, 20.0),\n    perturbation,\n)\nexecute!(sim2, Rodas4())","category":"page"},{"location":"execute/#Exploring-the-Solution","page":"Simulation Execution","title":"Exploring the Solution","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Once a Simulation is executed and the results are stored via results = read_results(sim), the following functions can be used to explore the Simulation solution:","category":"page"},{"location":"execute/#Show-initial-conditions","page":"Simulation Execution","title":"Show initial conditions","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function show_states_initial_value(results) can be used to display the initial condition of the voltages and dynamic states of each dynamic component.","category":"page"},{"location":"execute/#Explore-bus-voltages","page":"Simulation Execution","title":"Explore bus voltages","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function get_voltage_magnitude_series(results, BusNumber) can be used to obtain the voltage magnitude time series of the specified bus. Similarly, get_voltage_angle_series(results, BusNumber) can be used to obtain the voltage angle time series of the specified bus.","category":"page"},{"location":"execute/#Explore-output-currents","page":"Simulation Execution","title":"Explore output currents","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The functions get_real_current_series(results, \"DeviceName\") and get_imaginary_current_series(results, \"DeviceName\") can be used to obtain the output current time series of the specified device.","category":"page"},{"location":"execute/#Explore-output-power","page":"Simulation Execution","title":"Explore output power","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The functions get_activepower_series(results, \"DeviceName\") and get_reactivepower_series(results, \"DeviceName\") can be used to obtain the output power time series of the specified device.","category":"page"},{"location":"execute/#Explore-dynamic-states","page":"Simulation Execution","title":"Explore dynamic states","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function get_state_series(results, (\"DeviceName\", :StateSymbol) can be used to obtain the specified state time series of the specified device.","category":"page"},{"location":"execute/#Explore-Reference-Setpoints","page":"Simulation Execution","title":"Explore Reference Setpoints","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function get_setpoints(sim) can be used to obtain the reference setpoints of each dynamic device. Note: If a setpoint was changed via a perturbation, this function will return the modified setpoint.","category":"page"},{"location":"execute/#Keyword-Arguments","page":"Simulation Execution","title":"Keyword Arguments","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Any solver option available in DifferentialEquations.jl can be passed as keyword arguments in the execute! function. Please see the Common Solver Options in the DifferentialEquations.jl documentation for more details.","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Most common solver options used are dtmax to control the maximum dt for adaptive timestepping. abstol and reltol are also commonly used to control the tolerance in the adaptive timestepping. saveat is also used to store the results at a specified time stamps. For example, the following code is valid to further specify your solver options:","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"execute!(sim, IDA(), dtmax = 0.01, abstol = 1e-9, reltol = 1e-6, saveat = 0.01)","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"In addition, the keyword argument enable_progress_bar = false can be used to disable the progress bar.","category":"page"},{"location":"component_models/inner_control/#Inner-Loop-Controls","page":"Inner Control","title":"Inner Loop Controls","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"This component defines voltage and current controllers to generate the reference signal for the converter. Although in many controls the current and voltage control are separate blocks we propose a more general control approach that considers them as a joint control logic.","category":"page"},{"location":"component_models/inner_control/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-[VoltageModeControl]","page":"Inner Control","title":"Integrated Virtual Impedance, Voltage and Current Controller [VoltageModeControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag1a \n    dotxi_q = v_qtextvi^textref - v_q tag1b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag1c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag1d \n    dotphi_d = omega_textad(v_d - phi_d) tag1e \n    dotphi_q = omega_textad(v_q - phi_q) tag1f\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag1g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag1h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_dright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag1i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag1j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag1k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag1l\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here the transformation to the dq reference frame is using the outer-loop reference angle as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\nv_d + jv_q = (v_r + jv_i)e^-jdeltatheta_olc \ni_d + ji_q = (i_r + ji_i)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"that again v_r + jv_i could be in the capacitor or the last branch of the filter (i.e. the point of common coupling). For LCL filters it is considered in the capacitor. In the case of the converter, the transformation is directly","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/#Current-Mode-Controller-[CurrentModeControl]","page":"Inner Control","title":"Current Mode Controller [CurrentModeControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives the current reference (in dq axis) from an outer loop controller that outputs current references such as the PI outer controller used for grid following inverters. A PI current controller is used to generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag2a \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag2b \nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d tag2b \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q tag2c\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The transformation for the converter current is computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jtheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here theta_olc is the outer-loop angle. In the case of grid-following models, this angle is equal to the angle provided from the PLL.","category":"page"},{"location":"component_models/inner_control/#Generic-Renewable-Inner-Controller-Type-B-[RECurrentControlB]","page":"Inner Control","title":"Generic Renewable Inner Controller Type B [RECurrentControlB]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"This models the inner control part of the REECB model. The equations (without limiters) when Q_Flag = 1 are:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    T_rv dotV_texttflt = V_t - dotV_texttflt tag3a \n    dotxi_icv = V_textocqcmd tag3b\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"on which V_textocqcmd comes from the Outer Controller and the output current commands I_textpcmd and I_textqcmd are computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    I_textpcmd = I_textoc pcmd tag3c \n    I_textqcmd = I_icv + I_textqinj tag3d \n    I_icv = K_vp V_textocqcmd + K_vi xi_icv tag3e \n    I_textqinj = K_qv (V_textref0 - V_texttflt) tag3f\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The equations when Q_Flag = 0 are:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    T_rv dotV_texttflt = V_t - dotV_texttflt tag3g \n    T_iq dotI_icv = I_textocqcmd - I_icv tag3h\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"on which I_textocqcmd comes from the Outer Controller and the output current commands I_textpcmd and I_textqcmd are computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    I_textpcmd = I_textoc pcmd tag3i \n    I_textqcmd = I_icv + I_textqinj tag3j \n    I_textqinj = K_qv (V_textref0 - V_texttflt) tag3k\nendalign","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"You can access example data in the Power Systems Test Data Repository, the data can be downloaded with the PowerSystems.jl submodule UtilsData. Some systems are already provided in PowerSystemCaseBuilder.","category":"page"},{"location":"quick_start_guide/#Loading-data","page":"Quick Start Guide","title":"Loading data","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Data can be loaded from a pss/e raw file and a pss/e dyr file.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerSystems, PowerSimulationsDynamics, PowerSystemCaseBuilder, Sundials, Plots, Logging\nlogger = configure_logging(console_level = Logging.Error, file_level = Logging.Info)\nomib_sys = PowerSystemCaseBuilder.build_system(\n                PowerSystemCaseBuilder.PSSETestSystems,\n                \"psse_OMIB_sys\",\n                )","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For more details about loading data and adding more dynamic components check the Creating a System with Dynamic devices section of the documentation in PowerSystems.jl.","category":"page"},{"location":"quick_start_guide/#Define-the-Simulation","page":"Quick Start Guide","title":"Define the Simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"time_span = (0.0, 30.0)\nperturbation_trip = BranchTrip(1.0, Line, \"BUS 1-BUS 2-i_1\")\nsim = Simulation!(ResidualModel, omib_sys, pwd(), time_span, perturbation_trip)","category":"page"},{"location":"quick_start_guide/#Explore-initial-conditions-for-the-simulation","page":"Quick Start Guide","title":"Explore initial conditions for the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"x0_init = read_initial_conditions(sim)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"show_states_initial_value(sim)","category":"page"},{"location":"quick_start_guide/#Obtain-small-signal-results-for-initial-conditions","page":"Quick Start Guide","title":"Obtain small signal results for initial conditions","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    small_sig = small_signal_analysis(sim)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Show eigenvalues for operating point","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    small_sig.eigenvalues","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Show reduced jacobian for operating point","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    small_sig.reduced_jacobian","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Explore participation factors. In this case for state ω","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    part_factors = small_sig.participation_factors\n    part_factors[\"generator-102-1\"][:ω]","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"This means that the state ω of the generator at bus 102, participates 50% in eigenvalue 1 and 50% in eigenvalue 2.","category":"page"},{"location":"quick_start_guide/#Execute-the-simulation","page":"Quick Start Guide","title":"Execute the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    execute!(sim, IDA(), dtmax = 0.02, saveat = 0.02, enable_progress_bar = false)","category":"page"},{"location":"quick_start_guide/#Make-a-plot-of-the-results","page":"Quick Start Guide","title":"Make a plot of the results","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"results = read_results(sim)\nangle = get_state_series(results, (\"generator-102-1\", :δ));\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"gen-102-1\");","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"If you miss PSS/e's plotting aesthetics and want something that resembles that, you can use UnicodePlots.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using UnicodePlots\nunicodeplots()\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"gen-102-1\");","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"component_models/filters/#Filters","page":"Filter","title":"Filters","text":"","category":"section"},{"location":"component_models/filters/#LCL-Filter-[LCLFilter]","page":"Filter","title":"LCL Filter [LCLFilter]","text":"","category":"section"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_r and v_i are voltages in the capacitor, while v_r^textgrid and v_i^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign\n    doti_rtextcv = fracOmega_bl_fleft( v_r^textcv - v_r  - r_f i_rtextcv + omega_textgrid l_f i_itextcv right) tag1a \n    doti_itextcv = fracOmega_bl_fleft( v_i^textcv - v_i  - r_f i_itextcv - omega_textgrid l_f i_rtextcv right) tag1b \n    dotv_r =  fracOmega_bc_fleft( i_r^textcv - i_r + omega_textgrid c_f v_i right) tag1c \n    dotv_i =  fracOmega_bc_fleft( i_i^textcv - i_i - omega_textgrid c_f v_r right) tag1d \n    doti_r = fracOmega_bl_gleft( v_r - v_r^textgrid - r_g i_r + omega_textgrid l_g i_itextcv right) tag1e \n    doti_i = fracOmega_bl_gleft( v_i - v_i^textgrid - r_g i_i - omega_textgrid l_g i_rtextcv right) tag1f\nendalign","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"on which","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign*\nv_r^textcv + jv_i^textcv = (v_d^textcv + jv_q^textcv)e^jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"that comes from the converter model.","category":"page"},{"location":"component_models/filters/#RL-Filter-[RLFilter]","page":"Filter","title":"RL Filter [RLFilter]","text":"","category":"section"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"The algebraic RL filter is used to connect the output of the converter through a RL series filter using algebraic phasor equations. The equations for the output current are:","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign\n    i_r + ji_i = frac(v_r^textcv + j v_i^textcv) - (v_r^textgrid + jv_i^textgrid)r_f + jl_f tag2a\nendalign","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"on which v_r^textcv + jv_i^textcv comes from the converter model.","category":"page"},{"location":"component_models/turbine_gov/#Prime-Movers-and-Turbine-Governors-(TG)","page":"Turbine and Governor","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"component_models/turbine_gov/#Fixed-TG-[TGFixed]","page":"Turbine and Governor","title":"Fixed TG [TGFixed]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-I-[TGTypeI]","page":"Turbine and Governor","title":"TG Type I [TGTypeI]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag1a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag1b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag1c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag1d\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 10)\nendalign*","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-II-[TGTypeII]","page":"Turbine and Governor","title":"TG Type II [TGTypeII]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag2a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag2b\nendalign","category":"page"},{"location":"component_models/turbine_gov/#TGOV1-[SteamTurbineGov1]","page":"Turbine and Governor","title":"TGOV1 [SteamTurbineGov1]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This represents a classical Steam-Turbine Governor, known as TGOV1.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_1 (textref_in - x_g1) tag3a \ndotx_g2 = frac1T_3 left(x_g1^textsat left(1 - fracT_2T_3right) - x_g2right) tag3b\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ntextref_in = frac1R (P_ref - (omega - 10)) tag3c \nx_g1^textsat = left beginarraycl\n                        x_g1  text if  V_min le x_g1 le V_max\n                        V_max  text if  x_g1  V_max \n                        V_min  text if  x_g1  V_min\n                    endarray right tag3d \ntau_m = x_g2 + fracT_2T_3 x_g1 - D_T(omega - 10) tag3e\nendalign","category":"page"},{"location":"component_models/turbine_gov/#GAST-[GasTG]","page":"Turbine and Governor","title":"GAST [GasTG]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor represents the Gas Turbine representation, known as GAST.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_1 (x_in - x_g1) tag4a \ndotx_g2 = frac1T_2 left(x_g1^textsat - x_g2right) tag4b \ndotx_g3 = frac1T_3 (x_g2 - x_g3) tag4c\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nx_in = minleftP_ref - frac1R(omega - 10) A_T + K_T (A_T - x_g3) right tag4d \nx_g1^textsat = left beginarraycl\n                        x_g1  text if  V_min le x_g1 le V_max\n                        V_max  text if  x_g1  V_max \n                        V_min  text if  x_g1  V_min\n                    endarray right tag4e \ntau_m = x_g2  - D_T(omega - 10) tag4f\nendalign","category":"page"},{"location":"component_models/turbine_gov/#HYGOV-[HydroTurbineGov]","page":"Turbine and Governor","title":"HYGOV [HydroTurbineGov]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This represents a classical hydro governor, known as HYGOV.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nT_fdotx_g1 = P_in - x_g1 tag5a \ndotx_g2 = x_g1 tag5b\nT_g dotx_g3 = c - x_g3 tag5c\ndotx_g4 = frac1 - hT_w tag5d\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nP_in = P_ref - Delta omega - R x_g2 tag5e \nc = fracx_g1r + fracx_g2rT_r tag5f \nh = left(fracx_g4x_g3right)^2 tag5g\ntau_m = hcdot A_t(x_g4 - q_NL) - D_turb Deltaomega cdot x_g3 tag5h\nendalign","category":"page"},{"location":"small/#Small-Signal-Analysis","page":"Small Signal","title":"Small Signal Analysis","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Here we discuss the method used to do a small signal analysis on the DAE system defined in PowerSimulationsDynamics.jl. The package defines algebraic variables for both real and imaginary voltages on all buses (except if they have a dynamic line connected, on which the voltage of those buses are treated as differential variables). In addition, each dynamic device can add differential variables (or states) that are concatenated to construct the system of differential algebraic equations.","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Note: The validation of small signal results is still work in progress due to the differences in the way that different software packages perform the calculations.","category":"page"},{"location":"small/#Automatic-Differentiation","page":"Small Signal","title":"Automatic Differentiation","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Once an equilibrium point is found, the complete jacobian of the non-linear system can be obtained using automatic differentiation in Julia. In particular, the package ForwardDiff.jl is used to obtain the jacobian of the non-linear algebraic system of equations. PowerSimulationsDynamics.jl handles the resulting jacobian and reports the reduced jacobian and the corresponding eigenvalues and eigenvectors.","category":"page"},{"location":"small/#Jacobian-Reduction","page":"Small Signal","title":"Jacobian Reduction","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"We define y as the vector of algebraic variables, x as the vector of differential variables (states) and p the parameters of the system, we can define g(yxp) as the vector of algebraic equations and f(yxp) as the vector of differential equations. With that, the non-linear differential algebraic system of equations can be written as:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  dotx\n  endarrayright = leftbeginarrayc\n  g(yxp) \n   f(yxp) endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analysis, we are interested in the stability around an equilbrium point y_eqx_eq that satisfies dotx = 0 or equivalently f(y_eqx_eqp) = 0, while obviously satisfying g(y_eq x_eq p) = 0. To do that we use a first order approximation:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  Deltadotx\n  endarrayright = underbraceleftbeginarray\n  g(y_eqx_eqp) \n   f(y_eqx_eqp) endarrayright_ = 0\n + Jy_eq x_eq p leftbeginarrayc\n Delta y \n  Delta x\n  endarrayright\n  endalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"The first to note is that the jacobian matrix can be splitted in 4 blocks depending on the specific variables we are taking the partial derivatives:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJy_eq x_eq p =\nleftbeginarraycc\n g_y  g_x \n f_y  f_x \n  endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analyses, we are interested in the stability of the differential states, while still considering that those need to evolve in the manifold defined by the linearized algebraic equations. Assuming that g_y is not singular (see chapter 7 of Federico Milano's book: Power System Modelling and Scripting or the following paper) we can eliminate the algebraic variables to obtain the reduced jacobian:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJ_textred = f_x - f_y g_y^-1 g_x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"that defines our reduced system for the differential variables","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nDelta dotx = J_textred Delta x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"on which we can compute its eigenvalues to analyze local stability.","category":"page"},{"location":"small/#Accessing-the-Jacobian-function","page":"Small Signal","title":"Accessing the Jacobian function","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"You can retrieve the Jacobian function for a simulation using the get_jacobian function as follows:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian = function get_jacobian(ResidualModel, system)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"optionally you can pass the number of iterations to check for sparsity as follows:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian = function get_jacobian(ResidualModel, system, 0)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"if you specify 0, the jacobian function will use a full matrix.","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"The return of get_jacobian is known as a functor in Julia and can be used to make evaluations. Currently, any function can be evaluated with the following inputs:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(x)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version of the function is type unstable should only be used for non-critial ops. It works to get the eigenvalues given an operating point x","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(JM, x)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version evaluates in place the value of the jacobian for an operating point x and writes to the matrix JM","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(JM, x, p, t)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version complied with the requirements to be used in DiffEq for ODE solvers. p and t aren't used they just mean to match the interfaces. See DiffEqDocs","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(JM, dx, x, p, gamma, t)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version complied with the requirements to be used in DiffEq for DAE solvers. p and t aren't used they just mean to match the interfaces. It assumes that the jacobian has the form:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\n  JM = gamma * I + J(x)\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"See DiffEqDocs for additional details.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Here we discuss the models used to describe load modeling in PowerSimulationsDynamics.jl.  In a similar fashion of other devices, loads will withdraw power (i.e. current) from the current-injection balances at the nodal level. Based on the specified parameters and model chosen, the equations for computing such withdrawal will change.","category":"page"},{"location":"component_models/loads/#Static-Loads-(or-Algebraic-Loads)","page":"Load Models","title":"Static Loads (or Algebraic Loads)","text":"","category":"section"},{"location":"component_models/loads/#ZIP-Exponential-Load-Model","page":"Load Models","title":"ZIP + Exponential Load Model","text":"","category":"section"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"PowerSimulationsDynamics.jl uses all the static ZIP and exponential loads at each bus to obtain a single structure that creates an aggregate ZIP load model and a collection of all exponential loads.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The ZIP load model given by:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nP_textzip = P_textpower + P_textcurrent cdot fracVV_0 + P_textimpedance cdot left(fracVV_0right)^2 tag1a\nQ_textzip = Q_textpower + Q_textcurrent  cdot fracVV_0 + Q_textimpedance cdot left(fracVV_0right)^2tag1b\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"with V = sqrtV_r^2 + V_i^2 and V_0 the voltage magnitude from the power flow solution.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The current taken for the load is computed as:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textzip = frac(P_textzip + j Q_textzip)^*(V_r + j V_i)^*tag1c \nI_textzip = fracP_textzip - j Q_textzipV_r - j V_itag1d\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"For constant impedance load, the current obtained is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textre^z = frac1V_0^2 cdot (V_r cdot P_textimpedance + V_i cdot Q_textimpedance)tag1e \nI_textim^z = frac1V_0^2 cdot (V_i cdot P_textimpedance - V_r cdot Q_textimpedance)tag1f\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"For constant current load, the current obtained is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textre^i  = frac1V_0 cdot fracV_r * P_textcurrent + V_i * Q_textcurrentV tag1g\nI_textim^i  = frac1V_0 cdot fracV_i * P_textcurrent - V_r * Q_textcurrentV tag1h\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"For constant power load, the current obtained is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textre^p  =  fracV_r cdot P_textpower + V_i cdot Q_textpowerV^2 tag1i \nI_textim^p =  fracV_i cdot P_textpower - V_r cdot Q_textpowerV^2 tag1j\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Then the total current withdrawed from the ZIP load model is simply","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textzip^textre  =  I_textre^z + I_textre^i + I_textre^p tag1k \nI_textzip^textim  =  I_textim^z + I_textim^i + I_textim^p tag1l\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"On the case of Exponential Loads, the model is given by:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nP_textexp = P_0 cdot left(fracVV_0right)^alpha tag1m\nQ_textexp = Q_0 cdot left(fracVV_0right)^beta tag1n\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The current taken for the load is computed as:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textexp = frac(P_textexp + j Q_textexp)^*(V_r + j V_i)^* tag1o \nI_textexp = fracP_textexp - j Q_textexpV_r - j V_i tag1p\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"that results:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textexp^textre  = V_r cdot P_0 cdot fracV^alpha - 2V_0^alpha + V_i cdot Q_0 cdot fracV^beta - 2V_0^beta tag1q\nI_textexp^textim  = V_i cdot P_0 cdot fracV^alpha - 2V_0^alpha - V_r cdot Q_0 cdot fracV^beta - 2V_0^beta tag1r\nendalign","category":"page"},{"location":"component_models/loads/#Dynamic-loads","page":"Load Models","title":"Dynamic loads","text":"","category":"section"},{"location":"component_models/loads/#th-order-Single-Cage-Induction-Machine-[SingleCageInductionMachine]","page":"Load Models","title":"5th-order Single Cage Induction Machine [SingleCageInductionMachine]","text":"","category":"section"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The following model is used to model a 5th-order induction machine with a quadratic relationship speed-torque. Refer to \"Analysis of Electric Machinery and Drive Systems\" by Paul Krause, Oleg Wasynczuk and Scott Sudhoff for the equations derivation","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\ndotpsi_qs = Omega_b (v_qs - omega_textsys psi_ds - R_s i_qs) tag2a\ndotpsi_ds = Omega_b (v_ds + omega_textsys psi_qs - R_s i_ds) tag2b \ndotpsi_qr = Omega_b left(v_qr - (omega_textsys - omega_r) psi_dr + fracR_rX_lr (psi_mq - psi_qr)right) tag2c\ndotpsi_dr = Omega_b left(v_dr + (omega_textsys - omega_r) psi_qr + fracR_rX_lr (psi_md - psi_dr)right) tag2d\ndotomega_r = frac12H (tau_e - tau_m0(A omega_r^2 + B omega_r + C)) tag2e\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"where:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nX_ad = X_aq = left(frac1X_m + frac1X_ls + frac1X_lrright)^-1 \nv_qs = V_i^textbus \nv_ds = V_r^textbus \nv_qr = v_dr = 0 \npsi_mq = X_aq left(fracpsi_qsX_ls+ fracpsi_qrX_lrright) \npsi_md = X_ad left(fracpsi_dsX_ls+ fracpsi_drX_lrright) \ni_qs = frac1X_ls (psi_qs - psi_mq) \ni_ds = frac1X_ls (psi_ds - psi_md) \ntau_e = psi_ds i_qs - psi_qs i_ds \nendalign*","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Finally, the withdrawed current from the bus is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nI_r = left(fracS_textmotorS_textbaseright) (i_ds - v_qs B_sh) \nI_i = left(fracS_textmotorS_textbaseright) (i_qs + v_ds B_sh) \nendalign*","category":"page"},{"location":"component_models/loads/#rd-order-Single-Cage-Induction-Machine-[SimplifiedSingleCageInductionMachine]","page":"Load Models","title":"3rd-order Single Cage Induction Machine [SimplifiedSingleCageInductionMachine]","text":"","category":"section"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The following models approximates the stator fluxes dynamics of the 5th-order model by using algebraic equations.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\ndotpsi_qr = Omega_b left(v_qr - (omega_textsys - omega_r) psi_dr - R_r i_qr right) tag3a \ndotpsi_dr = Omega_b left(v_dr + (omega_textsys - omega_r) psi_qr - R_r i_drright) tag3b \ndotomega_r = frac12H (tau_e - tau_m0(A omega_r^2 + B omega_r + C)) tag3c\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"where","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nv_qs = V_i^textbus \nv_ds = V_r^textbus \nv_qr = v_dr = 0 \ni_qs = frac1R_s^2 + omega_textsys^2 X_p^2 left( (R_s v_qs - omega_textsys X_p v_ds) - left(R_s omega_textsys fracX_mX_rr psi_dr + omega_textsys^2 X_p fracX_mX_rr psi_qr right) right) \ni_ds = frac1R_s^2 + omega_textsys^2 X_p^2 left( (R_s v_ds + omega_textsys X_p v_qs) - left(-R_s omega_textsys fracX_mX_rr psi_qr + omega_textsys^2 X_p fracX_mX_rr psi_dr right) right) \ni_qr = frac1X_rr (psi_qr - X_m i_qs) \ni_dr = frac1X_rr (psi_dr - X_m i_ds) \ntau_e = psi_qr i_dr - psi_dr i_qr \nendalign*","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Finally, the withdrawed current from the bus is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nI_r = left(fracS_textmotorS_textbaseright) (i_ds - v_qs B_sh) \nI_i = left(fracS_textmotorS_textbaseright) (i_qs + v_ds B_sh) \nendalign*","category":"page"},{"location":"component_models/freq_esti/#Frequency-Estimators","page":"Frequency Estimators","title":"Frequency Estimators","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"component_models/freq_esti/#Fixed-Frequency-[FixedFrequency]","page":"Frequency Estimators","title":"Fixed Frequency [FixedFrequency]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This is a simple model that set the measured frequency to a desired constant value (i.e. does not measure the frequency) omega_pll = omega_textfix (usually omega_textfix = 10 p.u.). Used by default when grid-forming  inverters do not use frequency estimators. ","category":"page"},{"location":"component_models/freq_esti/#Phase-Locked-Loop-(PLL)-for-VSM-[KauraPLL]","page":"Frequency Estimators","title":"Phase-Locked Loop (PLL) for VSM [KauraPLL]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control theta_textolc and the PLL one theta_textpll. The notation used a deltatheta refers as the variation of the respective angle theta^textgrid with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\n\ndotv_dtextpll = omega_textlp left v_dtextout - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndottheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"with","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndeltaomega_textpll = 10 - omega_textsys + k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e \nomega_textpll = deltaomega_textpll + omega_textsys tag1f \nv_dtextout + jv_qtextout = (v_r + jv_i)e^-deltatheta_textpll  tag1g\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring (i.e. point of common coupling), that could be in the capacitor of an LCL filter or the last branch of such filter.","category":"page"},{"location":"component_models/freq_esti/#Reduced-Order-Phase-Locked-Loop-(PLL)-[ReducedOrderPLL]","page":"Frequency Estimators","title":"Reduced Order Phase-Locked Loop (PLL) [ReducedOrderPLL]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"The following equations presents a simplified PLL used to estimate the frequency and PLL angle of the grid. The model attempts to steer the voltage in the q-axis to zero (i.e. lock the q-axis to zero) using a PI controller. With that the equations are given by:","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag2a \ndotvarepsilon_textpll = v_qtextpll tag2b \ndottheta_textpll = Omega_b delta omega_textpll tag2c\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"with","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndeltaomega_textpll = 10 - omega_textsys + k_ptextpll v_qtextpll + k_itextpll varepsilon_textpll tag2d \nomega_textpll = deltaomega_textpll + omega_textsys tag2e \nv_dtextout + jv_qtextout = (v_r + jv_i)e^-deltatheta_textpll  tag2f\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring (i.e. point of common coupling), that could be in the capacitor of an LCL filter or the last branch of such filter.","category":"page"},{"location":"code_base_developer_guide/developer/#Guidelines-for-Developers","page":"Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to contribute to PowerSimulationsDynamics.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Simulation-Models","page":"Models","title":"Simulation Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PowerSimulations dynamics supports two formulations for the simulation model and define different methods for each simulation model. You can pass ResidualModel or MassMatrixModel to a call to Simulation to define the preferred formulation.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In this way, we provide a common set of development requirements for contributors of new models that maintains the same flexibility in choosing the solving algorithm.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"MassMatrixModel: Defines models that can be solved using Mass-Matrix Solvers. The model is formulated as follows:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nMfracdx(t)dt = f(x(t))\nendalign","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At this stage we have not conducted extensive tests with all the solvers in DifferentialEquations most of our tests use Rodas5().","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"ResidualModel: Define models that can be solved using Implicit ODE solvers and also the solver IDA from Sundials. The model is formulated to solved the following problem:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nr(t) = fracdx(t)dt - f(x(t))\nendalign","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At this stage we have not conducted extensive tests with all the solvers in DifferentialEquations if you are solving a larger system use IDA().","category":"page"},{"location":"models/#The-dynamic-system-model-in-PowerSimulationsDynamics","page":"Models","title":"The dynamic system model in PowerSimulationsDynamics","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"In order to support both formulations, the default implementation of the ResidualModel solves the following problem:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nr(t) = Mfracdx(t)dt - f(x(t))\nendalign","category":"page"},{"location":"models/#Solution-approaches","page":"Models","title":"Solution approaches","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PowerSimulationsDynamics.jl construct the entire function that is passed to DifferentialEquations to solve it using different solvers. This is called the Simultaneous-solution approach to numerically integrate over time. It gives the user the flexibility to model devices with a combination of differential and algebraic states. In addition, it gives the flexibility to model the network using an algebraic or differential model.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"On the other hand, industrial tools such as PSS/E uses a Partitioned-solution approach, on which the network must be modeled using an algebraic approach, and the differential equations and algebraic equations are solved sequentially. This method is usually faster if the heuristics for convergence when solving sequentially are properly tuned. However, boundary techniques must be considered when the connection with the devices and network is not converging when applying the partitioned-solution approach.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The difference in solution methods can complicate the validation and comparison between software tools. In addition it can affect the computational properties due to reliance of heuristics. These solution aspects are important to consider when using different tools for simulating power systems dynamics.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"For more details, check Brian Stott paper \"Power system dynamic response calculations\".","category":"page"},{"location":"models/#Generator-Models","page":"Models","title":"Generator Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model generators in PowerSimulationsDynamics.jl. See PowerSystems.jl dynamic devices for details.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Each generator is a data structure composed of the following components defined in PowerSystems.jl:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The implementation of Synchronous generators as components uses the following structure to share values across components.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://github.com/NREL-SIIP/PowerSystems.jl/blob/master/docs/src/assets/gen_metamodel.png?raw=true\" width=\"75%\">","category":"page"},{"location":"models/#Inverter-Models","page":"Models","title":"Inverter Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model inverters in PowerSimulationsDynamics.jl. See PowerSystems.jl dynamic devices for details. One of the key contributions in this software package is a separation of the components in a way that resembles current practices for synchronoues machine modeling.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://github.com/NREL-SIIP/PowerSystems.jl/blob/master/docs/src/assets/inv_metamodel.png?raw=true\" width=\"75%\">","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"models/#Reference","page":"Models","title":"Reference","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"For models, check the library in PowerSystems.jl","category":"page"},{"location":"component_models/avr/#Automatic-Voltage-Regulators-(AVR)","page":"AVR","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"AVR are used to determine the voltage in the field winding v_f (or V_f) in the model.","category":"page"},{"location":"component_models/avr/#Fixed-AVR-[AVRFixed]","page":"AVR","title":"Fixed AVR [AVRFixed]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"component_models/avr/#Simple-AVR-[AVRSimple]","page":"AVR","title":"Simple AVR [AVRSimple]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag1a\nendalign","category":"page"},{"location":"component_models/avr/#AVR-Type-I-[AVRTypeI]","page":"AVR","title":"AVR Type I [AVRTypeI]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag2a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag2b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag2c \ndotv_m = frac1T_r (v_h - v_m) tag2d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with the ceiling function:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#AVR-Type-II-[AVRTypeII]","page":"AVR","title":"AVR Type II [AVRTypeII]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag3a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag3b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag3c \ndotv_m = frac1T_r (v_h - v_m) tag3d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#Excitation-System-AC1A-[ESAC1A]","page":"AVR","title":"Excitation System AC1A [ESAC1A]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 5-states IEEE Type AC1A Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag4a \ndotV_r1 = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_r1right) tag4b \ndotV_r2 = frac1T_a (K_a V_out - V_r2) tag4c \ndotV_e = frac1T_e (V_r - V_FE) tag4d \ndotV_r3 = frac1T_f left( - fracK_fT_fV_FE - V_r3 right) tag4e \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nI_N = fracK_cV_e X_adI_fd \nV_FE = K_d X_adI_fd + K_e V_e + S_e V_e \nS_e = Bfrac(V_e-A)^2V_e \nV_F1 = V_r3 + fracK_fT_f V_FE \nV_in = V_ref - V_m - V_F1 \nV_out = V_r1 + fracT_cT_b V_in \nV_f = V_e f(I_N) \nf(I_N) = leftbeginarraycl\n    1  text if I_N le 0 \n    1 - 0577 I_N  text if  0  I_N le 0433 \n    sqrt075 - I_N^2  text if  0433  I_N le 075 \n    1732(1-I_N)  text if  075   I_N le 1 \n    0  text if  I_N  1 endarray right\nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which X_adI_fd is the field current coming from the generator and V_h is the terminal voltage, and AB are the saturation coefficients computed using the E_1 E_2 S_e(E_1) S_e(E_2) data.","category":"page"},{"location":"component_models/avr/#Simplified-Excitation-System-[SEXS]","page":"AVR","title":"Simplified Excitation System [SEXS]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model for the 2 states excitation system SEXS:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_f = frac1T_e (V_LL - V_f) tag5a \ndotV_r = frac1T_b leftleft(1 - fracT_aT_bright) V_in - V_r right tag5b\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nV_in = V_ref + V_s - V_h \nV_LL = V_r + fracT_aT_bV_in \nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which V_h is the terminal voltage and V_s is the PSS output signal.","category":"page"},{"location":"component_models/avr/#Excitation-System-ST1-[EXST1]","page":"AVR","title":"Excitation System ST1 [EXST1]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 4-states IEEE Type ST1 Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag6a \ndotV_rll = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_rllright) tag6b \ndotV_r = frac1T_a (V_LL - V_r) tag6c \ndotV_fb = frac1T_f left( - fracK_fT_fV_r - V_fb right) tag6d \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with ","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nV_in = V_ref - V_m - y_hp \nV_LL = V_r + fracT_cT_b V_in \ny_hp = V_fb + fracK_fT_f V_r \nV_f = V_r \nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which V_h is the terminal voltage.","category":"page"},{"location":"component_models/avr/#Excitation-System-EXAC1-[EXAC1]","page":"AVR","title":"Excitation System EXAC1 [EXAC1]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 5-states IEEE Type EXAC1 Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag7a \ndotV_r1 = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_r1right) tag7b \ndotV_r2 = frac1T_a (K_a V_out - V_r2) tag7c \ndotV_e = frac1T_e (V_r - V_FE) tag7d \ndotV_r3 = frac1T_f left( - fracK_fT_fV_FE - V_r3 right) tag7e \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nI_N = fracK_cV_e X_adI_fd \nV_FE = K_d X_adI_fd + K_e V_e + S_e V_e \nS_e = Bfrac(V_e-A)^2V_e \nV_F1 = V_r3 + fracK_fT_f V_FE \nV_in = V_ref - V_m - V_F1 \nV_out = V_r1 + fracT_cT_b V_in \nV_f = V_e f(I_N) \nf(I_N) = leftbeginarraycl\n    1  text if I_N le 0 \n    1 - 0577 I_N  text if  0  I_N le 0433 \n    sqrt075 - I_N^2  text if  0433  I_N le 075 \n    1732(1-I_N)  text if  075   I_N le 1 \n    0  text if  I_N  1 endarray right\nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which X_adI_fd is the field current coming from the generator and V_h is the terminal voltage, and AB are the saturation coefficients computed using the E_1 E_2 S_e(E_1) S_e(E_2) data.","category":"page"},{"location":"component_models/outer_control/#Outer-Loop-Controls","page":"Outer Control","title":"Outer Loop Controls","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This component defines controllers for both active and reactive power. The joint design is based on the fact that many novel control techniques can be based on joint control of active and reactive power.","category":"page"},{"location":"component_models/outer_control/#Virtual-Inertia-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Virtual Inertia and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. The constructor is OuterControl{VirtualInertia, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textolc - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag1a \n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag1b \n    dotq_m = omega_f (q_e - q_m) tag1c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag1d \n    q_e = v_ii_r - v_ri_i tag1e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag1f\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/outer_control/#Active-Power-Droop-(P-droop)-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Active Power Droop (P-droop) and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a Ptext-f droop model to represent how active power is going to be deployed. The constructor is OuterControl{ActivePowerControl, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power. Both active and reactive power are measured via a low-pass filter:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag2a \n    dotp_m = omega_z (p_e - p_m) tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag2d \n    q_e = v_ii_r - v_ri_i tag2e \n    omega_textolc = omega_textref + R_p (p_textref - p_m) tag2f \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2g\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Virtual-Oscillator-Controllers-[OuterControl]","page":"Outer Control","title":"Active and Reactive Virtual Oscillator Controllers [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents a Virtual Oscillator Controller for both active and reactive power to generate the voltage references that will be used in the Voltage Controller. The contructor is OuterControl{ActiveVirtualOscillator, ReactiveVirtualOscillator} It defines a new SRF denoted as theta_textolc and a voltage reference E_textolc. The equations are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag3a \n    dotE_olc = Omega_b left(frack_1E_oc (-sin(gamma) (p_textref - p_e) + cos(gamma)(q_textref - q_e)) + k_2 (V_textref - E_oc^2)E_oc right) tag3b \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    gamma = psi - fracpi2 tag3c \n    omega_textolc =  omega_textsys + frack_1E_oc^2 left(cos(gamma) (p_textref - p_e) + sin(gamma)(q_textref - q_e) right) tag3d \n    p_e = v_ri_r + v_ii_i tag3e \n    q_e = v_ii_r - v_ri_i tag3f \nendalign","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Power-PI-Controllers-(Grid-Following)-[OuterControl]","page":"Outer Control","title":"Active and Reactive Power PI Controllers (Grid Following) [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents a PI controller for both active and reactive power to generate the current references that will be used in the Current Controller of the inner control CurrentModeControl. The constructor is OuterControl{ActivePowerPI, ReactivePowerPI}. The equations are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotsigma_p = p_textref - p_m tag4a \n    dotp_m = omega_z (p_e - p_m) tag4b \n    dotsigma_q = q_textref - q_m tag4c \n    dotq_m = omega_f (q_e - p_m) tag4d \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag4e \n    q_e = v_ii_r - v_ri_i tag4f \n    omega_textolc = omega_textpll tag4g \n    theta_textolc = theta_textpll tag4h \n    i_textdcv^textref = k_p^q (q_textref - q_m) + k_i^q sigma_q tag4i \n    i_textqcv^textref = k_p^p (p_textref - p_m) + k_i^p sigma_p tag4j \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This models requires a PLL to have a SRF for an internal dq reference frame. Contrary to the Grid-Forming model, it cannot work without a PLL. Since this Outer Control outputs a current reference, it can only be used with a current mode inner control (i.e. that receives  a current reference instead of a voltage reference).","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Generic-Renewable-Controller-Type-AB-[OuterControl]","page":"Outer Control","title":"Active and Reactive Generic Renewable Controller Type AB [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents an outer controller for both active and reactive power from generic industrial models REPCA and REECB to generate the current references that will be used in the Current Controller of the inner control RECurrentControlB. The constructor is OuterControl{ActiveRenewableControllerAB, ReactiveRenewableControllerAB}. The equations will depend on the flags used.","category":"page"},{"location":"component_models/outer_control/#Active-part","page":"Outer Control","title":"Active part","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of F_Flag = 1 the equations (without limits and freezing) are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotp_textflt = frac1T_p (p_e - p_textflt) tag5a \n    dotxi_P = p_texterr tag5b \n    dotp_textext = frac1T_g (K_pg p_texterr + K_ig xi_P) tag5c \n    dotp_textord = frac1T_textpord (p_textext - p_textord) tag5d\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag5e \n    p_texterr = p_textref + p_textdroop - p_textflt tag5f \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of F_Flag = 0 the equations (without limits) are simply","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotp_textord = frac1T_textpord (p_textref - p_textord) tag5g\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The current command going to the Inner Loop is computed as:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    I_textocpcmd = fracp_textordV_texttflt tag5h\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"on which V_texttflt is the filtered terminal bus voltage coming from the inner controller.","category":"page"},{"location":"component_models/outer_control/#Reactive-part","page":"Outer Control","title":"Reactive part","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of VC_Flag = 0, Ref_Flag = 0, PF_Flag = 0, V_Flag = 1 the equations (without limits and freezing) are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotq_textflt = frac1T_textfltr (q_e - q_textflt) tag5i \n    dotxi_textqoc = q_texterr tag5j \n    dotq_LL = frac1T_fv(Q_textpi ( 1 - T_ftT_fv) - q_LL) tag5k \n    dotxi_Q = V_textpiin tag5l \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    q_e = v_ii_r - v_ri_i tag5m \n    q_texterr = q_textref - q_flt tag5n \n    Q_textpi = K_p q_texterr + K_i xi_textqoc tag5o \n    Q_textext = q_LL + fracT_ftT_fv Q_textpi tag5p \n    V_textpiin = Q_textext - q_e tag5q \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The output to the inner controller are V_textocqcmd if the Q_Flag = 1 on the Inner Controller, or I_textocqcmd if Q_Flag = 0:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    V_textocqcmd = (K_qp V_textpiin + K_qi xi_Q) - V_texttflt tag5r \n    I_textocqmcd = fracQ_textextmax(V_texttflt 001) tag5s\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of VC_Flag = 0, Ref_Flag = 0, PF_Flag = 0, V_Flag = 1 the equations (without limits and freezing) are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotq_textflt = frac1T_textfltr (q_e - q_textflt) tag5t \n    dotxi_textqoc = q_texterr tag5u \n    dotq_LL = frac1T_fv(Q_textpi ( 1 - T_ftT_fv) - q_LL) tag5v \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The remaining models for other flags will be included when implemented in PowerSimulationsDynamics.jl.","category":"page"},{"location":"perturbations/#Perturbations","page":"Perturbations","title":"Perturbations","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Perturbations are used to alter the system from its steady state operation. If a Simulation is properly initialized, all states will remain fixed in their initial condition if no perturbation is applied to the system.","category":"page"},{"location":"perturbations/#List-of-perturbations","page":"Perturbations","title":"List of perturbations","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"NetworkSwitch: allows to modify directly the admittance matrix, Ybus, used in the Simulation.\nBranchTrip: completely disconnects a branch from the system.\nBranchImpedanceChange: change the impedance of a branch by a user defined multiplier. \nGeneratorTrip: allows to disconnect a Dynamic Generation unit from the system.\nControlReferenceChange: allows to change the reference setpoint provided by a generator/inverter.\nLoadChange: allows to change the active or reactive power setpoint from a load.\nLoadTrip: allows the user to disconnect a load from the system.\nSourceBusVoltageChange: allows to change the reference setpoint provided by a voltage source.","category":"page"},{"location":"perturbations/#Examples","page":"Perturbations","title":"Examples","text":"","category":"section"},{"location":"perturbations/#Example-1:-Circuit-Disconnection-using-NetworkSwitch","page":"Perturbations","title":"Example 1: Circuit Disconnection using NetworkSwitch","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider a two bus system connected via a double circuit line, on which each circuit has parameters, r = 0.0, x = 0.1, b = 0.0 per unit, then the admittance matrix of the original system is given by:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"yb = [0.0 - 20.0im 0.0 + 20.0im\n      0.0 + 20.0im 0.0 - 20.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Triping one circuit can be modeled by doubling the impedance, i.e., dividing by 2 the admittance:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb = [0.0 - 10.0im 0.0 + 10.0im\n          0.0 + 10.0im 0.0 - 10.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Then, this perturbation ocurring at t = 10 seconds can be included as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"ns1 = NetworkSwitch(1.0, new_yb)","category":"page"},{"location":"perturbations/#Example-2:-Three-Phase-Fault-using-NetworkSwitch","page":"Perturbations","title":"Example 2: Three Phase Fault using NetworkSwitch","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Another perturbation that can be modeled is a three phase fault at Bus 1 with impedance r_f = 0.0001, x_f = 0.0 per unit, then the admittance of this new system is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb2 = [10000.0 - 20.0im  0.0 + 20.0im\n           0.0 + 20.0im  0.0 - 20.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Then, this perturbation ocurring at t = 10 seconds can be included as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"ns2 = NetworkSwitch(1.0, new_yb2)","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Now, consider that the fault is cleared at t = 105 seconds by disconnecting the Circuit 2 of the line. This can be modeled with the single circuit admittance matrix:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb3 = [0.0 - 10.0im 0.0 + 10.0im\n           0.0 + 10.0im 0.0 - 10.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"and the perturbation as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"ns3 = NetworkSwitch(1.05, new_yb3)","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Then, the entire perturbation for the Simulation can be included in a vector of perturbations as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"three_fault = [ns2, ns3]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"that can be passed as a perturbation argument in the Simulation construction.","category":"page"},{"location":"perturbations/#Example-3:-BranchTrip","page":"Perturbations","title":"Example 3: BranchTrip","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider the following 2 bus system defined by:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"buses = [\n    Bus(1, \"nodeA\", \"REF\", 0, 1.0, (min = 0.9, max = 1.05), 230, nothing, nothing),\n    Bus(2, \"nodeB\", \"PV\", 0, 1.0, (min = 0.9, max = 1.05), 230, nothing, nothing),\n]\n\nline1 = Line(\n        \"Circuit1\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = buses[1], to = buses[2]),\n        0.00,\n        0.1,\n        (from = 0.0, to = 0.0),\n        2.0,\n        (min = -0.7, max = 0.7),\n    )\nline2 = Line(\n        \"Circuit2\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = buses[1], to = buses[2]),\n        0.0,\n        0.1,\n        (from = 0.0, to = 0.0),\n        2.0,\n        (min = -0.7, max = 0.7),\n    )\n\nsys = System(100.0, buses, [], [], [line1, line2])","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"A Branch Trip of Circuit 2 at time t = 10 seconds, can be implemented as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"b_trip = BranchTrip(1.0, Line, \"Circuit2\")","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Note: Islanding is currently not supported in PowerSimulationsDynamics.jl. If a BranchTrip isolates a generation unit, the system may diverge due to the isolated generator.","category":"page"},{"location":"perturbations/#Example-4:-BranchImpedanceChange","page":"Perturbations","title":"Example 4: BranchImpedanceChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Following the same example as before, it is possible to amplify the impedance of a single circuit by 2.0 (that would represent that this Circuit is actually composed by 2 circuits) using the following perturbation:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"b_change = BranchImpedanceChange(1.0, Line, \"Circuit2\", 2.0)","category":"page"},{"location":"perturbations/#Example-5:-GeneratorTrip","page":"Perturbations","title":"Example 5: GeneratorTrip","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a generator at bus 102, named \"generator-102-1\" in your system called sys. The constructor to trip it from the system is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"g = get_component(DynamicGenerator, sys, \"generator-102-1\")\ng_trip = GeneratorTrip(1.0, g)","category":"page"},{"location":"perturbations/#Example-6:-ControlReferenceChange","page":"Perturbations","title":"Example 6: ControlReferenceChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a generator at bus 102, named \"generator-102-1\" in your system called sys. The constructor to change is active power reference to 0.5 is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"g = get_component(DynamicGenerator, sys, \"generator-102-1\")\ncrc = ControlReferenceChange(1.0, g, :P_ref, 0.5)","category":"page"},{"location":"perturbations/#Example-7:-LoadChange","page":"Perturbations","title":"Example 7: LoadChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a load at bus 103, named \"load-103-1\" in your system called sys. The constructor to change is active power reference to 0.8 per unit at t = 10 seconds is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"l_device = get_component(ElectricLoad, sys, \"load-103-1\")\nl_change = LoadChange(1.0, l_device, :P_ref, 0.8)","category":"page"},{"location":"perturbations/#Example-8:-LoadTrip","page":"Perturbations","title":"Example 8: LoadTrip","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a load at bus 103, named \"load-103-1\" in your system called sys. The constructor to disconnect such load at t = 10 seconds is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"l_device = get_component(ElectricLoad, sys, \"load-103-1\")\nl_trip = LoadTrip(1.0, l_device)","category":"page"},{"location":"perturbations/#Example-9:-SourceBusVoltageChange","page":"Perturbations","title":"Example 9: SourceBusVoltageChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a voltage source at bus 101, named \"source-101-1\" in your system called sys. The constructor to change is voltage magnitude reference to 1.02 per unit at t = 10 seconds is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"s_device = get_component(Source, sys, \"source-101-1\")\ns_change = SourceBusVoltageChange(1.0, s_device, 1, 1.02)","category":"page"},{"location":"component_models/machines/#Machines","page":"Machine","title":"Machines","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"component_models/machines/#Classical-Model-(Zero-Order)-[BaseMachine]","page":"Machine","title":"Classical Model (Zero Order) [BaseMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"component_models/machines/#One-d-One-q-Model-(2nd-Order)-[OneDOneQMachine]","page":"Machine","title":"One d- One q- Model (2nd Order) [OneDOneQMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"component_models/machines/#Marconato-Machine-(6th-Order)-[MarconatoMachine]","page":"Machine","title":"Marconato Machine (6th Order) [MarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Simplified-Marconato-Machine-(4th-Order)-[SimpleMarconatoMachine]","page":"Machine","title":"Simplified Marconato Machine (4th Order) [SimpleMarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Anderson-Fouad-Machine-(6th-Order)-[AndersonFouadMachine]","page":"Machine","title":"Anderson-Fouad Machine (6th Order) [AndersonFouadMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"component_models/machines/#Simplified-Anderson-Fouad-Machine-(4th-Order)-[SimpleAFMachine]","page":"Machine","title":"Simplified Anderson-Fouad Machine (4th Order) [SimpleAFMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"component_models/machines/#Round-Rotor-Machine-(4th-Order)-[RoundRotorQuadratic,-RoundRotorExponential]","page":"Machine","title":"Round Rotor Machine (4th Order) [RoundRotorQuadratic, RoundRotorExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENROU/GENROE models implemented in PSLF/PSSE/PowerWorld. Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q). Round rotor machines must satisfy x_d = x_q.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag7a\ndote_d = frac1T_q0 left-X_aqI_1q right tag7b\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag7c \ndotpsi_kq = frac1T_q0 left-psi_kq + e_d + (x_q-x_l)i_q right tag7d \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag7e\ngamma_q1 = fracx_q - x_lx_q - x_l tag7f\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag7g\ngamma_q2 = fracx_q - x_q(x_q - x_l)^2 tag7h\ngamma_qd = fracx_q - x_lx_d - x_l tag7i\npsi_q = gamma_q1 e_d + psi_kq (1 - gamma_q1) tag7j\npsi_d = gamma_d1 e_q + gamma_d2 (x_d - x_l) psi_kd tag7k\npsi = sqrt(psi_d)^2 + (psi_q)^2 tag7l\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag7m\nX_adI_fd = e_q + (x_d - x_d) (gamma_d1 i_d - gamma_d2 psi_kd + gamma_d2 + e_q) + textSe(psi) psi_d tag7n\nX_aqI_1q = e_d + (x_q - x_q) (gamma_q2 e_d - gamma_q2psi_kq - gamma_q1 i_q) + textSe(psi) psi_q gamma_qd tag7o \ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag7p\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENROU and GENROE occurs in which additive saturation function textSe(psi) is used. Input data is provided by the saturation values at psi = 10 and psi = 12 p.u. For the GENROU model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = fracB(psi - A)^2 psi tag7q\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENROE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = B(psi)^A tag7r\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/machines/#Salient-Pole-Machine-(3rd-Order)-[SalientPoleQuadratic,-SalientPoleExponential]","page":"Machine","title":"Salient Pole Machine (3rd Order) [SalientPoleQuadratic, SalientPoleExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENSAL/GENSAE models implemented in PSLF/PSSE/PowerWorld. Similar to the GENROU Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q).","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag8a\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag8b \ndotpsi_q = frac1T_q0 left-psi_q - (x_q-x_q)i_q right tag8c \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag8d\ngamma_q1 = fracx_q - x_lx_q - x_l tag8e\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag8f\npsi_d = gamma_d1 e_q + gamma_q1 psi_kd tag8g\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag8h\nX_adI_fd = e_q + textSe(e_q) e_q + (x_d - x_d) (i_d + gamma_d2 (e_q - psi_kd - (x_d - x_l)i_d) tag8i\ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag8j\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENSAL and GENSAE occurs in which additive saturation function textSe(e_q) is used. Input data is provided by the saturation values at e_q = 10 and e_q = 12 p.u. For the GENSAL model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(e_q) = fracB(e_q - A)^2 e_q tag8k\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENSAE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(e_q) = B(e_q)^A tag8l\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/shafts/#Shafts","page":"Shaft","title":"Shafts","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"component_models/shafts/#Rotor-Mass-Shaft-[SingleMass]","page":"Shaft","title":"Rotor Mass Shaft [SingleMass]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag1a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag1b\nendalign","category":"page"},{"location":"component_models/shafts/#Five-Mass-Shaft-[FiveMassShaft]","page":"Shaft","title":"Five-Mass Shaft [FiveMassShaft]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag2a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag2b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag2c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag2d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag2e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag2f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag2g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag2h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag2i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag2j\nendalign","category":"page"},{"location":"api/public/#PowerSimulationsDynamics","page":"Public API Reference","title":"PowerSimulationsDynamics","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#PowerSimulationsDynamics.BranchImpedanceChange","page":"Public API Reference","title":"PowerSimulationsDynamics.BranchImpedanceChange","text":"mutable struct BranchImpedanceChange <: Perturbation\n    time::Float64\n    branch_type::Type{<:PSY.ACBranch}\n    branch_name::String\n    multiplier::Float64\nend\n\nA BranchImpedanceChange change the impedance of a branch by a user defined multiplier. Currently there is only support for static branches disconnection, PowerSystems.Line and PowerSystems.Transformer2W. Future releases will provide support for a Dynamic Line disconnection.\n\nArguments:\n\ntime::Float64 : Defines when the Branch Impedance Change will happen. This time should be inside the time span considered in the Simulation\nbranch_tipe::Type{<:PowerSystems.ACBranch} : Type of branch modified\nbranch_name::String : User defined name for identifying the branch\nmultiplier::Float64 : User defined value for impedance multiplier.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.BranchTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.BranchTrip","text":"mutable struct BranchTrip <: Perturbation\n    time::Float64\n    branch_type::Type{<:PowerSystems.ACBranch}\n    branch_name::String\nend\n\nA BranchTrip completely disconnects a branch from the system. Currently there is only support for static branches disconnection, PowerSystems.Line and PowerSystems.Transformer2W. Future releases will provide support for a Dynamic Line disconnection. Note: Islanding is currently not supported in PowerSimulationsDynamics.jl. If a BranchTrip isolates a generation unit, the system may diverge due to the isolated generator.\n\nArguments:\n\ntime::Float64 : Defines when the Branch Trip will happen. This time should be inside the time span considered in the Simulation\nbranch_tipe::Type{<:PowerSystems.ACBranch} : Type of branch disconnected\nbranch_name::String : User defined name for identifying the branch\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.ControlReferenceChange","page":"Public API Reference","title":"PowerSimulationsDynamics.ControlReferenceChange","text":"mutable struct ControlReferenceChange <: Perturbation\n    time::Float64\n    device::PowerSystems.DynamicInjection\n    signal::Symbol\n    ref_value::Float64\nend\n\nA ControlReferenceChange allows to change the reference setpoint provided by a generator/inverter.\n\nArguments:\n\ntime::Float64 : Defines when the Control Reference Change will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.DynamicInjection} : Dynamic device modified\nsignal::Symbol : determines which reference setpoint will be modified. The accepted signals are:\n:P_ref: Modifies the active power reference setpoint.\n:V_ref: Modifies the voltage magnitude reference setpoint (if used).\n:Q_ref: Modifies the reactive power reference setpoint (if used).\n:ω_ref: Modifies the frequency setpoint.\nref_value::Float64 : User defined value for setpoint reference.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.GeneratorTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.GeneratorTrip","text":"mutable struct GeneratorTrip <: Perturbation\n    time::Float64\n    device::PowerSystems.DynamicInjection\nend\n\nA GeneratorTrip allows to disconnect a Dynamic Generation unit from the system at a specified time.\n\nArguments:\n\ntime::Float64 : Defines when the Generator Trip will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.DynamicInjection} : Device to be disconnected\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.LoadChange","page":"Public API Reference","title":"PowerSimulationsDynamics.LoadChange","text":"mutable struct LoadChange <: Perturbation\n    time::Float64\n    device::PowerSystems.ElectricLoad\n    signal::Symbol\n    ref_value::Float64\nend\n\nA LoadChange allows to change the active or reactive power setpoint from a load.\n\nArguments:\n\ntime::Float64 : Defines when the Load Change will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.ElectricLoad} : Dynamic device modified\nsignal::Symbol : determines which reference setpoint will be modified. The accepted signals are:\n:P_ref: Modifies the active power reference setpoint.\n:Q_ref: Modifies the reactive power reference setpoint.\nref_value::Float64 : User defined value for setpoint reference.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.LoadTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.LoadTrip","text":"mutable struct LoadTrip <: Perturbation\n    time::Float64\n    device::PowerSystems.ElectricLoad\nend\n\nA LoadTrip allows the user to disconnect a load from the system.\n\nArguments:\n\ntime::Float64 : Defines when the Generator Trip will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.ElectricLoad} : Device to be disconnected\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.MassMatrixModel-Union{Tuple{Ctype}, Tuple{Any, Vector{Float64}, Type{Ctype}}} where Ctype<:PowerSimulationsDynamics.SimCache","page":"Public API Reference","title":"PowerSimulationsDynamics.MassMatrixModel","text":"Instantiate a MassMatrixModel for ODE inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.NetworkSwitch","page":"Public API Reference","title":"PowerSimulationsDynamics.NetworkSwitch","text":"function NetworkSwitch(\n    time::Float64,\n    ybus::SparseArrays.SparseMatrixCSC{Complex{Float64}, Int},\n)\n\nAllows to modify directly the admittance matrix, Ybus, used in the Simulation. This allows the user to perform branch modifications, three phase faults (with impedance larger than zero) or branch trips, as long as the new Ybus provided captures that perturbation.\n\nArguments:\n\ntime::Float64 : Defines when the Network Switch will happen. This time should be inside the time span considered in the Simulation\nybus::SparseArrays.SparseMatrixCSC{Complex{Float64}, Int} : Complex admittance matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.PerturbState","page":"Public API Reference","title":"PowerSimulationsDynamics.PerturbState","text":"function PerturbState(\n    time::Float64,\n    index::Int,\n    value::Float64,\n)\n\nAllows the user to modify the state index by adding value. The user should modify dynamic states only, since algebraic state may require to do a reinitialization.\n\nArguments:\n\ntime::Float64 : Defines when the modification of the state will happen. This time should be inside the time span considered in the Simulation.\nindex::Int : Defines which state index you want to modify\nvalue::Float64 : Defines how much the state will increase in value\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.ResidualModel-Union{Tuple{Ctype}, Tuple{Any, Vector{Float64}, Type{Ctype}}} where Ctype<:PowerSimulationsDynamics.SimCache","page":"Public API Reference","title":"PowerSimulationsDynamics.ResidualModel","text":"Instantiate an ResidualModel for ODE inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.ResidualModel-Union{Tuple{Ctype}, Tuple{T}, Tuple{PowerSimulationsDynamics.SimulationInputs, Vector{T}, Type{Ctype}}} where {T<:Float64, Ctype<:PowerSimulationsDynamics.JacobianCache}","page":"Public API Reference","title":"PowerSimulationsDynamics.ResidualModel","text":"Instantiate an ResidualModel for ForwardDiff calculations\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.Simulation-Union{Tuple{T}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}, Vector{<:PowerSimulationsDynamics.Perturbation}}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation","text":"function Simulation\n    ::SimulationModel\n    system::PowerSystems.System\n    simulation_folder::String\n    tspan::NTuple{2, Float64},\n    perturbations::Vector{<:Perturbation} = Vector{Perturbation}();\n    kwargs...,\nend\n\nBuilds the simulation object and conducts the indexing process. The initial conditions are stored in the system.\n\nArguments:\n\n::SimulationModel : Type of Simulation Model. ResidualModel or MassMatrixModel. See Models Section for more details\nsystem::PowerSystems.System : System data\nsimulation_folder::String : Folder directory\ntspan::NTuple{2, Float64} : Time span for simulation\nperturbations::Vector{<:Perturbation} : Vector of Perturbations for the Simulation. Default: No Perturbations\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\ninitial_conditions::Vector{Float64} : Allows the user to pass a vector with the initial condition values desired in the simulation. If initialize_simulation = true, these values are used as a first guess and overwritten.\nfrequency_reference : Default ReferenceBus. Determines which frequency model is used for the network. Currently there are two options available:\nConstantFrequency assumes that the network frequency is 1.0 per unit at all times.\nReferenceBus will use the frequency state of a Dynamic Generator (rotor speed) or Dynamic Inverter (virtual speed) connected to the Reference Bus (defined in the Power Flow data) as the network frequency. If multiple devices are connected to such bus, the device with larger base power will be used as a reference. If a Voltage Source is connected to the Reference Bus, then a ConstantFrequency model will be used.\nsystem_to_file::Bool : Default false. Serializes the initialized system\nconsole_level::Logging : Default Logging.Warn. Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\nfile_level::Logging : Default Logging.Info. Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\ndisable_timer_output::Bool : Default false. Allows the user to display timer information about the construction and initilization of the Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.SourceBusVoltageChange","page":"Public API Reference","title":"PowerSimulationsDynamics.SourceBusVoltageChange","text":"mutable struct SourceBusVoltageChange <: Perturbation\n    time::Float64\n    device::PSY.Source\n    signal::Symbol\n    ref_value::Float64\nend\n\nA SourceBusVoltageChange allows to change the reference setpoint provided by a voltage source.\n\nArguments:\n\ntime::Float64 : Defines when the Control Reference Change will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.Source} : Device modified\nsignal::Symbol : determines which reference setpoint will be modified. The accepted signals are:\n:V_ref Modifies the internal voltage magnitude reference setpoint.\n:θ_ref  Modifies the internal voltage angle reference setpoint.\nref_value::Float64 : User defined value for setpoint reference.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.Simulation!-Union{Tuple{T}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}, Vector{<:PowerSimulationsDynamics.Perturbation}}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation!","text":"function Simulation!\n    ::SimulationModel\n    system::PowerSystems.System\n    simulation_folder::String\n    tspan::NTuple{2, Float64},\n    perturbations::Vector{<:Perturbation} = Vector{Perturbation}();\n    kwargs...,\nend\n\nBuilds the simulation object and conducts the indexing process. The original system is not modified and a copy its created and stored in the Simulation.\n\nArguments:\n\n::SimulationModel : Type of Simulation Model. ResidualModel or MassMatrixModel. See Models Section for more details\nsystem::PowerSystems.System : System data\nsimulation_folder::String : Folder directory\ntspan::NTuple{2, Float64} : Time span for simulation\nperturbations::Vector{<:Perturbation} : Vector of Perturbations for the Simulation. Default: No Perturbations\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\ninitial_conditions::Vector{Float64} : Allows the user to pass a vector with the initial condition values desired in the simulation. If initialize_simulation = true, these values are used as a first guess and overwritten.\nfrequency_reference : Default ReferenceBus. Determines which frequency model is used for the network. Currently there are two options available:\nConstantFrequency assumes that the network frequency is 1.0 per unit at all times.\nReferenceBus will use the frequency state of a Dynamic Generator (rotor speed) or Dynamic Inverter (virtual speed) connected to the Reference Bus (defined in the Power Flow data) as the network frequency. If multiple devices are connected to such bus, the device with larger base power will be used as a reference. If a Voltage Source is connected to the Reference Bus, then a ConstantFrequency model will be used.\nsystem_to_file::Bool : Default false. Serializes the initialized system\nconsole_level::Logging : Default Logging.Warn. Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\nfile_level::Logging : Default Logging.Info. Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\ndisable_timer_output::Bool : Default false. Allows the user to display timer information about the construction and initilization of the Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.execute!-Tuple{Simulation, Any}","page":"Public API Reference","title":"PowerSimulationsDynamics.execute!","text":"execute!(\n    sim::Simulation,\n    solver;\n    kwargs...\n)\n\nSolves the time-domain dynamic simulation model.\n\nArguments\n\nsim::Simulation : Initialized simulation object\nsolver : Solver used for numerical integration. Must be passed correctly depending on the Type of Simulation Model\nenable_progress_bar::Bool : Default: true. Enables progress bar for the integration routine.\nAdditional solver keyword arguments can be included. See Common Solver Options in the DifferentialEquations.jl documentation for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_activepower_branch_flow-Tuple{SimulationResults, String, Symbol}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_activepower_branch_flow","text":"get_activepower_branch_flow(\n        res::SimulationResults,\n        name::String,\n        location::Symbol,\n)\n\nFunction to obtain the active power flowing through the series element of a Branch. The user must specified is the power should be computed in the :from or to :bus, by specifying a symbol.\n\nIf :from is specified, the power is computed flowing outwards the :from bus. If :to is specified, the power is computed flowing into the :to bus.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\nlocation::Symbol : :from or :to to specify a bus\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_activepower_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_activepower_series","text":"get_activepower_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the active power output time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_field_current_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_field_current_series","text":"get_field_current_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the field current time series of a Dynamic Generator out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_field_voltage_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_field_voltage_series","text":"get_field_voltage_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the field voltage time series of a Dynamic Generator out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_frequency_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_frequency_series","text":"get_frequency_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the frequency time series of a Dynamic Injection out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_imaginary_current_branch_flow-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_imaginary_current_branch_flow","text":"get_imaginary_current_branch_flow(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the imaginary current flowing through the series element of a Branch\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_imaginary_current_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_imaginary_current_series","text":"get_imaginary_current_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the imaginary current time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_jacobian-Union{Tuple{T}, Tuple{Type{T}, System}, Tuple{Type{T}, System, Int64}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.get_jacobian","text":"function get_jacobian(\n::Type{T},\nsystem::PSY.System,\nsparse_retrieve_loop::Int = 3,\n) where {T <: SimulationModel}\n\nReturns the jacobian function of the system model resulting from the system data.\n\nArguments:\n\n::SimulationModel : Type of Simulation Model. ResidualModel or MassMatrixModel. See Models Section for more details\nsystem::PowerSystems.System : System data\nsparse_retrieve_loop::Int : Number of loops for sparsity detection. If 0, builds the Jacobian with a DenseMatrix\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_mechanical_torque_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_mechanical_torque_series","text":"get_mechanical_torque_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the mechanical torque time series of the mechanical torque out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_reactivepower_branch_flow-Tuple{SimulationResults, String, Symbol}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_reactivepower_branch_flow","text":"get_reactivepower_branch_flow(\n        res::SimulationResults,\n        name::String,\n        location::Symbol,\n)\n\nFunction to obtain the reactive power flowing through the series element of a Branch. The user must specified is the power should be computed in the :from or to :bus, by specifying a symbol.\n\nIf :from is specified, the power is computed flowing outwards the :from bus. If :to is specified, the power is computed flowing into the :to bus.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\nlocation::Symbol : :from or :to to specify a bus\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_reactivepower_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_reactivepower_series","text":"get_reactivepower_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the reactive power output time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_real_current_branch_flow-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_real_current_branch_flow","text":"get_real_current_branch_flow(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the real current flowing through the series element of a Branch\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_real_current_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_real_current_series","text":"get_real_current_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the real current time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_setpoints-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_setpoints","text":"get_setpoints(sim::Simulation)\n\nFunction that returns the reference setpoints for all the dynamic devices.\n\nArguments\n\nsim::Simulation : Simulation object that contains the initial condition and setpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_source_imaginary_current_series","page":"Public API Reference","title":"PowerSimulationsDynamics.get_source_imaginary_current_series","text":"Function to obtain output imaginary current for a source. It receives the simulation results, the Source name and an optional argument of the time step of the results.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#PowerSimulationsDynamics.get_source_real_current_series","page":"Public API Reference","title":"PowerSimulationsDynamics.get_source_real_current_series","text":"Function to obtain output real current for a source. It receives the simulation results, the Source name and an optional argument of the time step of the results.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#PowerSimulationsDynamics.get_state_series-Tuple{SimulationResults, Tuple{String, Symbol}}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_state_series","text":"get_state_series(\n    res::SimulationResults,\n    ref::Tuple{String, Symbol};\n    dt::Union{Nothing, Float64} = nothing\n)\nend\n\nFunction to obtain series of states out of DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nref:Tuple{String, Symbol} : Tuple used to identify the dynamic device, via its name, as a String, and the associated state as a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltage_angle_series-Tuple{SimulationResults, Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltage_angle_series","text":"get_voltage_angle_series(\n    res::SimulationResults,\n    bus_number::Int\n)\n\nFunction to obtain the voltage angle series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nbus_number::Int : Bus number identifier\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltage_magnitude_series-Tuple{SimulationResults, Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltage_magnitude_series","text":"get_voltage_magnitude_series(\n    res::SimulationResults,\n    bus_number::Int\n)\n\nFunction to obtain the voltage magnitude series out of the DAE Solution.\n\nArguments:\n\nres::SimulationResults : Simulation Results object that contains the solution\nbus_number::Int : Bus number identifier\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.read_initial_conditions-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.read_initial_conditions","text":"Returns a Dictionary with the resulting initial conditions of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.show_states_initial_value-Tuple{SimulationResults}","page":"Public API Reference","title":"PowerSimulationsDynamics.show_states_initial_value","text":"show_states_initial_value(res::SimulationResults)\n\nFunction to print initial states.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.show_states_initial_value-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.show_states_initial_value","text":"show_states_initial_value(sim::Simulation)\n\nFunction to print initial states.\n\nArguments\n\nsim::Simulation : Simulation object that contains the initial condition\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.summary_eigenvalues-Tuple{PowerSimulationsDynamics.SmallSignalOutput}","page":"Public API Reference","title":"PowerSimulationsDynamics.summary_eigenvalues","text":"summary_eigenvalues(\n        sm::SmallSignalOutput,\n)\n\nFunction to obtain a summary of the eigenvalues of the Jacobian at the operating point. It returns a DataFrame with the most associated state for each eigenvalue, its real and imaginary part, damping and frequency.\n\nArguments\n\nsm::SmallSignalOutput : Small Signal Output object that contains the eigenvalues and participation factors\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.summary_participation_factors-Tuple{PowerSimulationsDynamics.SmallSignalOutput}","page":"Public API Reference","title":"PowerSimulationsDynamics.summary_participation_factors","text":"summary_participation_factors(\n        sm::SmallSignalOutput,\n)\n\nFunction to obtain the participation factor of each state to each eigenvalue. It returns a DataFrame with the participation factors of each state to all eigenvalues.\n\nArguments\n\nsm::SmallSignalOutput : Small Signal Output object that contains the eigenvalues and participation factors\n\n\n\n\n\n","category":"method"},{"location":"component_models/network/#Network-model","page":"Network","title":"Network model","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in PowerSimulationsDynamics.jl. This is based on a standard current injection model as defined in Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"In simple terms, PowerSimulationsDynamics.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolv\n endalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"where boldsymboli = i_r + ji_i is the vector of the sum of complex current injections from devices , boldsymbolx is the vector of states and boldsymbolv = v_r + jv_i is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"component_models/network/#Static-Branches-(or-Algebraic-Branches)","page":"Network","title":"Static Branches (or Algebraic Branches)","text":"","category":"section"},{"location":"component_models/network/#Lines","page":"Network","title":"Lines","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"component_models/network/#Two-Windings-Transformers","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"component_models/network/#Dynamic-Branches","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdboldsymboli_elldt = (boldsymbolv_n - boldsymbolv_m) - (r+jl) boldsymboli_ell \n     fracc_nOmega_b fracdboldsymbolv_ndt =  boldsymboli_n^textcap - jc_nboldsymbolv_n   \n      fracc_mOmega_b fracdboldsymbolv_mdt = boldsymboli_m^textcap - jc_mboldsymbolv_m\nendalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"A detail discussion about the effects of different line models in the modeling of inverters is presented in Grid Forming Inverter Small Signal Stability: Examining Role of Line and Voltage Dynamics","category":"page"},{"location":"component_models/pss/#Power-System-Stabilizers-(PSS)","page":"PSS","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"PSS are used to add an additional signal v_s to the input signal of the AVR: v_textref = v_textref^textavr + v_s.","category":"page"},{"location":"component_models/pss/#Fixed-PSS-[PSSFixed]","page":"PSS","title":"Fixed PSS [PSSFixed]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"component_models/pss/#Simple-PSS-[PSSSimple]","page":"PSS","title":"Simple PSS [PSSSimple]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is  a proportional controller over the frequency and electrical power:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag1a\nendalign","category":"page"},{"location":"component_models/pss/#IEEE-Stabilizer-[IEEEST]","page":"PSS","title":"IEEE Stabilizer [IEEEST]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"The 7th-order PSS model is:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nA_4 dotx_1 = u - A_3 x_1 - x_2  tag2a \ndotx_2 = x_1 tag2b \nA_2dotx_3 = x_2 - A_1 x_3 - x_4 tag2c\ndotx_4 = x_3 tag2d\nT_2dotx_5 = left(1 - fracT_1T_2right) y_f - x_5 tag2e\nT_4dotx_6 = left(1 - fracT_3T_4right) y_LL1 - x_6 tag2f\nT_6dotx_7 =  -left(fracK_s T_5T_6 y_LL2 + x_7 right) tag2g\nendalign","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"with","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign*\ny_f = fracT_4T_2 x_2 + left(T_3 - T_1 fracT_4T_2right) x_3 + left(1 - fracT_4T_2right)x_4 \ny_LL1 = x_5 + fracT_1T_2 y_f \ny_LL2 = x_6 + fracT_3T_4 y_LL1 \ny_out = x_7 + fracK_s T_5T_6 y_LL2 \nV_s = textclamp(y_out textLs_textmin textLs_textmax)\nendalign*","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"on which u is the input signal to the PSS, that depends on the flag. Currently, rotor speed, electric torque, mechanical torque and voltage magnitude are supported inputs.","category":"page"},{"location":"component_models/pss/#STAB1-PSS-[STAB1]","page":"PSS","title":"STAB1 PSS [STAB1]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"The 3rd-order PSS model is:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nT dotx_1 = K omega - x_1 tag3a \nT_3dotx_2 = left(1 - fracT_1T_3right) x_1 - x_2 tag3b \nT_4dotx_3 = left(1 - fracT_2T_4right) y_LL - x_2 tag3c \nendalign","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"with","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign*\ny_LL = x_2 + fracT_1T_3 x_1 \ny_out = x_3 +  fracT_2T_4 y_LL \nV_s =  textclamp(y_out -H_lim H_lim)\nendalign*","category":"page"},{"location":"initialization/#Initialization-Routine","page":"Initialization","title":"Initialization Routine","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Dynamic Simulations require a reasonable initial condition for the system model. In most analysis, power systems models are initialized at a stable equilibrium, which implies that:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"beginalign\n0 = F(x u eta)\nendalign","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finding the solution of a large non-linear system is challenging and requires a reasonable initial guess. In classical power systems literature, the routine to find equilibrium points for the dynamic injection devices' components is well known and used in free and commercial software (see Power System Modelling and Scripting page 224). However, in the case of converter interface dynamic injection models, such routines are not documented.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initializing the system also requires finding valid set-points for the devices in the system. For instance, finding the reference voltage in an AVR to match the voltage magnitude resulting from the power flow solution. PowerSimulationsDynamics.jl prioritizes mathching the dynamic components control references to match the power flow results.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finally, the initialization must instantiate not only the values of the states but also the inner vars. PowerSimulationsDynamics.jl handles all this initializations by default.","category":"page"},{"location":"initialization/#Initialization-interface","page":"Initialization","title":"Initialization interface","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"By default PowerSimulationsDynamics.jl initializes the system following the steps described below. it is possible to provide an initial guess for the initial conditions to speed up the initialization process.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Simulation(\n        ResidualModel,\n        sys,\n        pwd(),\n        (0.0, 20.0);\n        initial_conditions = x0_init,\n    )","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"It is also possible to initialize the simulation using a flat start (V_mag = 1.0, V_angle = 0.0 and x0 = zeros) using initialize_simulation = false. However, for medium or large system this is unlikely to result in a valid initial condition for the simulation.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Simulation(\n        ResidualModel,\n        sys,\n        pwd(),\n        (0.0, 20.0);\n        initialize_simulation = false,\n    )","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"If you want to avoid PowerSimulationsDynamics.jl from finding an stable equilibrium automatically and provide the initial condition manually you can use the following flag combination.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Simulation(\n        ResidualModel,\n        sys,\n        pwd(),\n        (0.0, 20.0);\n        initialize_simulation = false,\n        initial_conditions = x0_init,\n    )","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"<span style=\"color:red\">WARNING!</span>: when the initialize_simulation is set to false, neither the device set points nor the inner vars are initialized. Use these keywords with care and make sure the values in the system components match the initial conditions provided.","category":"page"},{"location":"initialization/#System-wide-initialization-routine","page":"Initialization","title":"System-wide initialization routine","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The initialization routine starts from the solution of the power flow equations. For each dynamic injection device PowerSimulationsDynamics.jl finds the solution of the systems of non-linear equations for each dynamic component following the sequences described in the forthcoming sections.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Once each device is individually initialized, the system-wide initial guess is used to solve the system (1). In a first attempt at finding the solution, the tolerance is set to a stringent tolerance. If the non-linear solver is unable to get a solution, it might usually reflect small signal stability problems in the system. In a second attempt, the tolerances are relaxed. If the solver succeeds, the simulation continues, but the user is warned.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"<img src=\"../assets/sys_init.png\" width=\"65%\">","category":"page"},{"location":"initialization/#Initialization-of-the-Synchronous-Machines","page":"Initialization","title":"Initialization of the Synchronous Machines","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The initialization of Synchronous Machines is standard in power systems and follows the scheme shown in the figure. Other internal variables are calculated recursively from the power flow solution for the node on which the dynamic device isconnected. (Adapted from Power System Modelling and Scripting Figure 9.2)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"(Image: init_machine)","category":"page"},{"location":"initialization/#Initialization-of-the-Inverters","page":"Initialization","title":"Initialization of the Inverters","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initializing the inverters follows the sequence shown in the figure and has been developed to be compatible with the implementation of custom dynamic components. Given that the process is less studied and standard than the one of the synchronous machine, this page contains more detailed documentation of the process.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"(Image: init_machine)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The first component to be initialized is the filter. Given that the filter is an RLC circuit connected to the grid, its currents and voltages need to match the results of the power flow. The initialization of the filter provides the values for the P and Q used in the outer control and the V and I needed in the inner controls.\nBased on the bus voltage in the system's reference frame V_r and the bus angle theta the PLL's can be initialized to obtain the angle and frequency estimates needed by the outer control.\nThe Outer Control calculates the internal angle delta_olc required by the inner control to estimate the voltage and current phase difference.\nThe DC Source uses the power set-point consistent with the power outputs of the filter to initialize the V_dc set-points. This value is used in the inner control.\nThe inner control takes the phase angle delta_olc and the V_dc to estimate the modulation values of the PWM converter.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Note: The initialization of an inverter through the proposed meta-model is actively under development and subject to change. This page will maintain the latest version of the sequence.","category":"page"},{"location":"tutorials_page/#SIIP-Examples","page":"Tutorials","title":"SIIP-Examples","text":"","category":"section"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"All the tutorials for the SIIP project are part of a separate repository SIIP-Examples. You can access the latest PowerSimulationsDynamics.jl tutorial notebooks in this link","category":"page"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"Specific examples of common workflows and models:","category":"page"},{"location":"tutorials_page/","page":"Tutorials","title":"Tutorials","text":"Loading Dynamic Data\nSolving a One Machine against Infinite Bus model\nChanging line modeling assumptions\nUsing an Inverter in a Multi-Machine Model","category":"page"},{"location":"reference_frames/#Reference-Frames","page":"Reference Frames","title":"Reference Frames","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Each dynamic device is defined in its own dq synchronous reference frame (SRF). It is important to note that there are several conventions to do reference frame transformations.","category":"page"},{"location":"reference_frames/#Synchronous-Machines","page":"Reference Frames","title":"Synchronous Machines","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The grid is modeled in its own real-imaginary (RI) reference frame. With such, this follows the standard convention that for a voltage angle theta = 0, there is no imaginary part and hence v_h = v_r + j0. Traditionally, the reference frame dq with rotor angle delta for synchronous machines connected to a bus v_hangle theta = v_r + jv_i follows the following convention for transformation of per-unit RMS phasors:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-j(delta- pi2) tag1a \nv_d =  v_h sin(delta - theta) tag1b \nv_q = v_h cos(delta - theta) tag1c \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag1d\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Note that hence in a bus of 10angle 0, a rotor angle of delta = 0 implies that v_q = 10 and v_d = 00. This transformation is the one that can be found in most books of Power Systems, such as Kundur, Sauer Pai and in Milano too, and is the convention used in the software to model dynamic models of synchronous machines in their own reference frame.","category":"page"},{"location":"reference_frames/#Inverters","page":"Reference Frames","title":"Inverters","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The previously convention is not the standard one used for modeling inverters. Most of inverter and phase-lock loop (PLL) models follow the next convention:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-j delta tag2a  \nv_d =  v_h cos(delta - theta) tag2b \nv_q = -v_h sin(delta - theta) tag2c\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"That, contrary to the previous case, when delta = theta = 0 implies that v_d = 10 and v_q = 00. This yields the typical PLL conditions that steer v_q to 0 when delta locks in theta, or when both SRF lock between each other.","category":"page"},{"location":"reference_frames/#Transformation-used","page":"Reference Frames","title":"Transformation used","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Given the predominancy of both convention in current work, the software uses both conventions depending on the device modeled. For synchronous machines we used the standard convention (1a)-(1d), while for inverter models we use the predominant convention used nowadays in such models, i.e. (2a)-(2c).","category":"page"},{"location":"component_models/dc_source/#DC-Source","page":"DC Sources","title":"DC Source","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"component_models/dc_source/#Fixed-DC-Source-[FixedDCSource]","page":"DC Sources","title":"Fixed DC Source [FixedDCSource]","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"api/internal/#Internal","page":"Internal API Reference","title":"Internal","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/internal/#PowerSimulationsDynamics.BUILD_STATUS","page":"Internal API Reference","title":"PowerSimulationsDynamics.BUILD_STATUS","text":"Defines the status of the simulation object\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.BranchWrapper","page":"Internal API Reference","title":"PowerSimulationsDynamics.BranchWrapper","text":"Wraps DynamicBranch devices from PowerSystems to handle changes in controls and connection status, and allocate the required indexes of the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.DynamicWrapper","page":"Internal API Reference","title":"PowerSimulationsDynamics.DynamicWrapper","text":"Wraps DynamicInjection devices from PowerSystems to handle changes in controls and connection status, and allocate the required indexes of the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.SimulationInputs-Tuple{Type{MassMatrixModel}, System, Union{ConstantFrequency, ReferenceBus}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.SimulationInputs","text":"SimulationInputs build function for MassMatrixModels\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.SimulationInputs-Tuple{Type{ResidualModel}, System, Union{ConstantFrequency, ReferenceBus}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.SimulationInputs","text":"SimulationInputs build function for ResidualModels\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.generator_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.generator_inner_vars","text":"Generator Inner Vars:\n\nτe_var :: Electric torque\nτm_var :: Mechanical torque\nVf_var :: Field voltage\nV_pss_var :: Additional PSS voltage\nVR_gen_var :: Real part of the terminal voltage\nVI_gen_var :: Imaginary part of the terminal voltage\nψd_var :: Stator Flux (if defined) in the d-axis\nψq_var :: Stator Flux (if defined) in the q-axis\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.inverter_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.inverter_inner_vars","text":"Inverter Inner Vars:\n\nmd_var :: Modulation signal on the d-component\nmq_var :: Modulation signal on the q-component\nVdc_var :: DC voltage supplied by the DC source\nVr_filter_var :: Voltage seen in the capacitor of the filter in the R-component\nVi_filter_var :: Voltage seen in the capacitor of the filter in the I-component\nθ_freq_estimator_var :: Angle estimated by the frequency estimator.\nω_freq_estimator_var :: Frequency estimated by the frequency estimator.\nV_oc_var :: Control voltage reference in the d-axis supplied from the outer loop control to the inner loop (for Voltage Mode Control)\nId_oc_var :: Control current reference in the d-axis supplied from the outer loop control to the inner loop (for Current Mode Control)\nIq_oc_var :: Control current reference in the q-axis supplied from the outer loop control to the inner loop (for Current Mode Control)\nId_ic_var :: Control current reference in the d-axis supplied from the inner loop control to the converter (for Generic Models)\nIq_ic_var :: Control current reference in the q-axis supplied from the inner loop control to the converter (for Generic Models)\nIr_cnv_var :: Control current reference in the R-axis supplied from the converter to the filter (for Generic Models)\nIi_cnv_var :: Control current reference in the I-axis supplied from the converter to the filter (for Generic Models)\nω_oc_var :: Control frequency supplied from the outer loop control the inner loop\nθ_oc_var :: Variation of the angle (PLL or VSM) of the inverter\nVr_inv_var :: Real terminal voltage on the inverter\nVi_inv_var :: Imaginary terminal voltage on the inverter\nVr_cnv_var :: Voltage supplied from the converter in the R-component\nVi_cnv_var :: Voltage supplied from the converter in the I-component\nP_ES_var :: Power supplied from the Energy Source side\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Tuple{SalientPoleExponential, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator with machine type GENSAE.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Tuple{SalientPoleQuadratic, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator with machine type GENSAL.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Union{Tuple{M}, Tuple{M, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64}}} where M<:Machine","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator. It is dispatched via the machine type. By default, machine does not have support for field current\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Union{Tuple{M}, Tuple{M, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64}}} where M<:Union{RoundRotorExponential, RoundRotorQuadratic}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator with machine type GENROU/GENROE.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{AVRFixed, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr AVRFixed.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{SCRX, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr SCRX.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{Union{ESAC1A, EXAC1}, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr ESAC1A and EXAC1.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Union{Tuple{A}, Tuple{A, String, SimulationResults, Union{Nothing, Float64}}} where A<:AVR","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avrs that have  the field voltage as a state. By default it is assumed that the models have that state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{F}, Tuple{OuterControl{ActivePowerDroop, ReactivePowerDroop}, F, String, SimulationResults, G, Union{Nothing, Float64}}} where {F<:FrequencyEstimator, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a droop grid forming inverter out of the DAE Solution. It is dispatched via the OuterControl type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{F}, Tuple{OuterControl{ActiveVirtualOscillator, ReactiveVirtualOscillator}, F, String, SimulationResults, G, Union{Nothing, Float64}}} where {F<:FrequencyEstimator, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a VOC grid forming inverter out of the DAE Solution. It is dispatched via the OuterControl type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{F}, Tuple{OuterControl{VirtualInertia, ReactivePowerDroop}, F, String, SimulationResults, G, Union{Nothing, Float64}}} where {F<:FrequencyEstimator, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a virtual inertia grid forming inverter out of the DAE Solution. It is dispatched via the OuterControl type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{OuterControl{ActivePowerPI, ReactivePowerPI}, ReducedOrderPLL, String, SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a grid-following inverter with KauraPLL out of the DAE Solution. It is dispatched via the OuterControl and FrequencyEstimator type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{BaseMachine, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a Classic Machine model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{OneDOneQMachine, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a One-D-One-Q model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{SauerPaiMachine, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a SauerPaiMachine model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{AndersonFouadMachine, MarconatoMachine}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a Marconato or AndersonFouad model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{RoundRotorExponential, RoundRotorQuadratic}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a GENROU/GENROE model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{SalientPoleExponential, SalientPoleQuadratic}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a GENSAL/GENSAE model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{SimpleAFMachine, SimpleMarconatoMachine}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a SimpleMarconato or SimpleAndersonFouad model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._make_reduced_jacobian_index-Tuple{Any, Any}","page":"Internal API Reference","title":"PowerSimulationsDynamics._make_reduced_jacobian_index","text":"Finds the location of the differential states in the reduced Jacobian\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{GasTG, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with GasTG (GAST) Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{HydroTurbineGov, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with HydroTurbineGov (HYGOV) Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{SteamTurbineGov1, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with SteamTurbineGov1 (TGOV1) Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{TGFixed, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with TGFixed Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{TGTypeI, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with TGTypeI Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{TGTypeII, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with TGTypeII Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._output_current-Union{Tuple{G}, Tuple{C}, Tuple{LCLFilter, C, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, G, Union{Nothing, Float64}}} where {C<:Converter, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._output_current","text":"Function to obtain the output current time series of a LCL Filter model out of the DAE Solution. It is dispatched via the Filter type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._output_current-Union{Tuple{G}, Tuple{RLFilter, RenewableEnergyConverterTypeA, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics._output_current","text":"Function to obtain the output current time series of a REGCA converter model out of the DAE Solution. It is dispatched via the Converter type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._post_proc_state_series-Tuple{Any, Int64, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._post_proc_state_series","text":"Internal function to obtain as a Vector of Float64 of a specific state. It receives the solution and the global index for a state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_current","text":"Function to obtain the field current time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_current","text":"Function to obtain the field current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It must return nothing since field current does not exists in inverters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_voltage-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific voltage.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_voltage-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_voltage","text":"Function to obtain the field current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It must return nothing since field voltage does not exists in inverters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_frequency-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_frequency","text":"Function to obtain the output frequency time series of a DynamicGenerator\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_mechanical_torque-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific torque.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_mechanical_torque-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It must return nothing since mechanical torque is not used in inverters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, AggregateDistributedGenerationA, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a AggregateDistributedGenerationA (DERA) model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, PeriodicVariableSource, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a PeriodicVariableSource model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current. computeoutputcurrent(::SimulationResults, ::PeriodicVariableSource, ::Vector{Float64}, ::Vector{Float64}, ::Nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, PowerLoad, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a PowerLoad model. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, PowerSystems.ExponentialLoad, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a ExponentialLoad model. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, SimplifiedSingleCageInductionMachine, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a 3th Order Induction Machine model out of the DAE Solution.  It receives the simulation inputs, the dynamic device and bus voltage. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, SingleCageInductionMachine, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a 5th Order Induction Machine model out of the DAE Solution.  It receives the simulation inputs, the dynamic device and bus voltage. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{I}, Tuple{SimulationResults, I, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64}}} where I<:DynamicInjection","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Default function to compute output current.  Returns an error\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.configure_logging-Tuple{}","page":"Internal API Reference","title":"PowerSimulationsDynamics.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{ActiveConstantPowerLoad}, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of 12-state Active Constant Power Load in Julia. Based on the paper Malicious Control of an Active Load in an Islanded Mixed-Source Microgrid by C. Roberts, U. Markovic, D. Arnold and D. Callaway.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{SimplifiedSingleCageInductionMachine}, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of 3-state (SimplifiedSingleCageInductionMachine) induction motor in Julia. Based on the 3rd order model derived in Prabha Kundur's Book and the equations in \"Analysis of Electric Machinery and Drive Systems\" by Paul Krause, Oleg Wasynczuk and Scott Sudhoff.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{SingleCageInductionMachine}, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of 5-state (SingleCageInductionMachine) induction motor in Julia. Refer to \"Analysis of Electric Machinery and Drive Systems\" by Paul Krause, Oleg Wasynczuk and Scott Sudhoff for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{AndersonFouadMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{BaseMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 0-state synchronous (classic model) machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{MarconatoMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{OneDOneQMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SauerPaiMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (SauerPai) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleAFMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleMarconatoMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.low_pass_modified_mass_matrix-Union{Tuple{Z}, Tuple{W}, Tuple{V}, Tuple{Z, V, Float64, W, Float64}} where {V<:Union{Float64, ForwardDiff.Dual}, W<:Union{Float64, ForwardDiff.Dual}, Z<:Union{Float64, ForwardDiff.Dual}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.low_pass_modified_mass_matrix","text":"Low Pass Filter Modified      ┌─────────────┐      │      K      │ u -> │ ────────────│ -> y      │ K_den + sT  │      └─────────────┘\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mass_matrix_entries-Tuple{DynamicInjection}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mass_matrix_entries","text":"Default implementation of mass matrix entries. Keeps the default values in the identity matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{AndersonFouadMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (AndersonFouadMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{BaseMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 0-state synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{MarconatoMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (MarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{OneDOneQMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SauerPaiMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (SauerPaiMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleAFMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleAFMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleMarconatoMachine, S, A, TG, P}}}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleMarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_zip_load!-Union{Tuple{T}, Tuple{T, T, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.StaticLoadWrapper}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_zip_load!","text":"Model for ZIP Load model given by:\n\nPzip = Ppower + Pcurrent * (V / V0) + Pimpedance * (V / V0)^2 Qzip = Qpower + Qcurrent * (V / V0) + Qimpedance * (V / V0)^2\n\nwith V = sqrt(Vr^2 + Vi^2) and V0 the voltage magnitude from the power flow solution\n\nThe current taken for the load is computed as: Izip = (Pzip + j Qzip)^* / (Vr + j Vi)^* Izip = (Pzip - j Qzip) / (Vr - j Vi)\n\nFor constant impedance it is obtained: Izre = (1 / V0)^2 * (Vr * Pimpedance + Vi * Qimpedance) Izim = (1 / V0)^2 * (Vi * Pimpedance - Vr * Qimpedance)\n\nFor constant current it is obtained: Iire = (1 / V0) * ( (Vr * Pcurrent + Vi * Qcurrent) / V ) Iiim = (1 / V0) * ( (Vi * Pcurrent - Vr * Qcurrent) / V )\n\nFor constant power it is obtained: Ipre =  (Vr * Ppower + Vi * Qpower) / V^2 Ipim =  (Vi * Ppower - Vr * Qpower) / V^2\n\nModel for Exponential Load model given by:\n\nPexp = P0 * (V / V0)^α Qexp = Q0 * (V / V0)^β\n\nThe current taken for the load is computed as: Iexp = (Pexp + j Qexp)^* / (Vr + j Vi)^* Iexp = (Pexp - j Qexp) / (Vr - j Vi)\n\nIt results: Irexp = Vr * P0 * (V^(α - 2) / V0^α) + Vi * Q0 * (V^(β - 2)/ V0^β) Iiim  = Vi * P0 * (V^(α - 2) / V0^α) - Vr * Q0 * (V^(β - 2)/ V0^β)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_activepower_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_activepower_series","text":"Function to compute the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_branch_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_branch_series","text":"Function to compute the current flowing through an AC branch through their series element. The current is computed through the from bus into the to bus.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_field_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_field_current_series","text":"Function to compute the field current output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_field_voltage_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_field_voltage_series","text":"Function to compute the field voltage output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_frequency_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_frequency_series","text":"Function to compute the frequency of a Dynamic Injection component.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_imaginary_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_imaginary_current_series","text":"Function to compute the imaginary current output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_mechanical_torque_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_mechanical_torque_series","text":"Function to compute the mechanical torque output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_reactivepower_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_reactivepower_series","text":"Function to compute the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_real_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_real_current_series","text":"Function to compute the real current output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_source_voltage_current_series","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_source_voltage_current_series","text":"Function to obtain voltage and output currents for a source. It receives the simulation resutls and      an optional argument of the time step of the results.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_state_series-Tuple{SimulationResults, Tuple{String, Symbol}, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_state_series","text":"Function to obtain the state time series of a specific state. It receives the simulation, and a tuple containing the name of the Dynamic Device and the symbol of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_voltage_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_voltage_current_series","text":"Function to obtain voltage and output currents for a dynamic device. It receives the simulation, and the name of the Dynamic Device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_voltage_series-Tuple{Any, Int64, Int64, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_voltage_series","text":"Function to obtain voltage using the bus index (and not the bus number). It receives the solution, the bus index and the total number of buses.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorExponential, SalientPoleExponential}, Union{Float64, ForwardDiff.Dual}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for exponential saturation models for machines\n    Se(x) = B * x^A\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorQuadratic, SalientPoleQuadratic}, Union{Float64, ForwardDiff.Dual}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for quadratic saturation models for machines\n    Se(x) = B * (x - A)^2 / x\n\n\n\n\n\n","category":"method"},{"location":"component_models/converter/#Converter","page":"Converter","title":"Converter","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"component_models/converter/#Average-Model-[AverageConverter]","page":"Converter","title":"Average Model [AverageConverter]","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"The average model outputs the desired reference signal since:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag1a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag1b\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"component_models/converter/#Generic-Renewable-Converter-Type-A-[RenewableEnergyConverterTypeA]","page":"Converter","title":"Generic Renewable Converter Type A ```[RenewableEnergyConverterTypeA]","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This block represents the REGCA model. The equations (without the limiters) are:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\n    dotI_p = frac1T_g (I_textpcmd - I_p) tag2a \n    dotI_q = frac1T_g (I_textqcmd - I_q) tag2b \n    dotV_textmeas = frac1T_fltr (V_t - V_textmeas tag2c)\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"on which I_textpcmd and I_textqcmd are the current commands from the inner control and V_t is the bus voltage magnitude. The additional terms and output current are computed as:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\n    I_q^textcv = -I_q - I_textqextra tag2d \n    I_textqextra = max(K_hv (V_t - V_textolim)) tag2e \n    I_p^textcv = G_lv I_p tag2f \nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"on which G_lv is the gain used for Low Voltage Active Current Management and I_textqextra is the additional current for High Voltage Reactive Current Management.","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"It is important to note that both current commands coming from the inner control were obtained by dividing the active (or reactive) power by the magnitude voltage instead of using the correct phasor formula I = (SV)^*. For that purpose, a correction factor must be applied to obtain the correct output currents in the network reference frame:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign*\n    I_r + jI_i = (I_p + jI_q) cdot V_t cdot frac1V_r + jV_i \n    = (I_p + jI_q) cdot fracV_tV_t e^jtheta \n    = (I_p + jI_q) cdot e^-jtheta\nendalign*","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This correction factor looks like a reference transformation that must be used to properly inject current into the grid. With that the output current is computed as:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\n    I_r = I_p^textcv cos(theta) - I_q^textcv sin(theta) tag2g \n    I_i = I_p^textcv sin(theta) + I_q^textcv cos(theta) tag2h\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This current source is usually modeled as a Norton equivalent using a parallel impedance with values R_sorce and X_sorce provided in the .raw file. If an RL filter is used, a Voltage Source behind that RL filter (i.e. the converter output voltage) can be computed as:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign*\n    Z_f = r_f + jl_f \n    Z_sorce = R_sorce + jX_sorce \n    I_cv = I_r + jI_i \n    v_r^textcv + jv_i^textcv = fracI_cv + fracv^textgridZ_ffrac1Z_sorce + frac1Z_f tag2i\nendalign*","category":"page"},{"location":"#PowerSimulationsDynamics.jl","page":"Welcome Page","title":"PowerSimulationsDynamics.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerSystems","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The synchronous machine components supported here are based on commercial models and the academic components are derived from Power System Modelling and Scripting.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Inverter models support both commercial models, such as REPC, REEC and REGC type of models; and academic models obtained from grid-following and grid-forming literature such as in \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\"","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerSimulationsDynamics can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics#master","category":"page"},{"location":"#Structure","page":"Welcome Page","title":"Structure","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The following figure shows the interactions between PowerSimulationsDynamics.jl, PowerSystems.jl, ForwardDiff.jl, DiffEqBase.jl and the integrators. The architecture of PowerSimulationsDynamics.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated using automatic differentiation through ForwardDiff.jl, that is used for both numerical integration and small signal analysis. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular BDF and Rosenbrock methods since it has exceptional features applicable to large models — for instance, interfacing with distributed linear-solvers and GPU arrays.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"<img src=\"./assets/SoftwareLoop.jpg\" width=\"65%\"/>","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"⠀","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL)","category":"page"},{"location":"generic/#Industrial-(Generic)-Renewable-Models","page":"Industrial Renewable Models","title":"Industrial (Generic) Renewable Models","text":"","category":"section"},{"location":"generic/#Connection-with-the-Inverter-Metamodel","page":"Industrial Renewable Models","title":"Connection with the Inverter Metamodel","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Generic Renewable Models for PV solar or battery devices used in industrial tools, such as PSS/E or PowerWorld, does not necessary resemble the proposed structure of our proposed metamodel. ","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"In general terms, a generic renewable model (for PV plant or battery) is typically a Grid Following inverter that uses a Renewable Energy Plant Controller (REPC), a Renewable Energy Electrical Controller (REEC) and a Renewable Energy Generic Converter (REGC) model. The following figure is useful to understand the general structure of such models:","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/generic_vsc.png\" width=\"100%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"In comparison to the proposed inverter metamodel it is clear that the REPC resembles the Outer Control. However, the REEC has a purpose of both Outer Control and Inner Control and the REGC has a similar purpose of the Converter and Filter in the proposed structure. For such purpose, it was necessary to split the REEC and part of its model was included in both Outer Control and Inner Control.","category":"page"},{"location":"generic/#Example-of-implementation-of-generic-models","page":"Industrial Renewable Models","title":"Example of implementation of generic models","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The following includes examples of the implementation of the proposed model in the inverter metamodel.","category":"page"},{"location":"generic/#Active-Renewable-Outer-Control","page":"Industrial Renewable Models","title":"Active Renewable Outer Control","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The following example join the active power controllers from REPCA and REECB as ActiveRenewableControllerAB in PowerSimulationsDynamics.jl","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/active_ren.png\" width=\"90%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"⠀","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"An important thing to consider with the industrial models, is that the change of Flags can significantly vary the model and purpose of the controller.","category":"page"},{"location":"generic/#Reactive-Renewable-Outer-Control","page":"Industrial Renewable Models","title":"Reactive Renewable Outer Control","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Similar to the active controller, the following figure presents the reactive controller part from REPCA and REECB as ReactiveRenewableControllerAB in PowerSimulationsDynamics.jl","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/reactive_ren.png\" width=\"90%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"⠀","category":"page"},{"location":"generic/#Inner-Controller","page":"Industrial Renewable Models","title":"Inner Controller","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Finally, the remaining part from REECB was included RECurrentControllerB","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/inner_reecb.png\" width=\"90%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"⠀","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The REGCAmodel was directly included in a Converter Block, and the filter can be bypassed using an RLFilter block with rf = lf = 0.","category":"page"},{"location":"generic/#Current-availability-of-model-flags-in-PSID","page":"Industrial Renewable Models","title":"Current availability of model flags in PSID","text":"","category":"section"},{"location":"generic/#Active-Controller","page":"Industrial Renewable Models","title":"Active Controller","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"For the active controller, both Freq_Flag = 0 (ignoring frequency regulation) and Freq_Flag = 1 (considering frequency regulation) are available.","category":"page"},{"location":"generic/#Reactive-Controller","page":"Industrial Renewable Models","title":"Reactive Controller","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The following table describes the current available combination of flags in PSID:","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"REF_Flag PF_Flag V_Flag Q_Flag\n0 0 0 0\n0 0 1 0\n1 0 1 1\n1 0 0 0","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Any combination outside of these cases may not converge to a feasible operating point. Check the following CAISO report for the description and compliance of each flag combination.","category":"page"}]
}
