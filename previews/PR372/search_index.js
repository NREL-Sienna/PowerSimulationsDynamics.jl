var documenterSearchIndex = {"docs":
[{"location":"execute/#Executing-a-Simulation","page":"Simulation Execution","title":"Executing a Simulation","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"After constructing the System data from PowerSystems.jl with its dynamic components, a Simulation structure must be constructed. Check the API for Simulation and Simulation! for its construction and available arguments.","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Once a Simulation is constructed and properly initialized, the execute! command is used to run the Simulation. If no perturbation was included, then a steady state simulation will be run over the time span defined. See the API of execute! for more details.","category":"page"},{"location":"execute/#Solvers","page":"Simulation Execution","title":"Solvers","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Solvers must be chosen accordingly depending on the type of model used in the Simulation. For example, a Residual model can be executed using Sundials IDA solver:","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"using Sundials\nsim = Simulation(\n    ResidualModel,\n    sys,\n    pwd(),\n    (0.0, 20.0),\n    perturbation,\n)\nexecute!(sim, IDA())","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Results can be explored using:","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"results = read_results(sim)","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Similarly, a Mass Matrix model can be executed using Rodas4 solver.","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"using OrdinaryDiffEq\nsim2 = Simulation(\n    MassMatrixModel,\n    sys,\n    pwd(),\n    (0.0, 20.0),\n    perturbation,\n)\nexecute!(sim2, Rodas4())","category":"page"},{"location":"execute/#Exploring-the-Solution","page":"Simulation Execution","title":"Exploring the Solution","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Once a Simulation is executed and the results are stored via results = read_results(sim), the following functions can be used to explore the Simulation solution:","category":"page"},{"location":"execute/#Show-initial-conditions","page":"Simulation Execution","title":"Show initial conditions","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function show_states_initial_value(results) can be used to display the initial condition of the voltages and dynamic states of each dynamic component.","category":"page"},{"location":"execute/#Explore-bus-voltages","page":"Simulation Execution","title":"Explore bus voltages","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function get_voltage_magnitude_series(results, BusNumber) can be used to obtain the voltage magnitude time series of the specified bus. Similarly, get_voltage_angle_series(results, BusNumber) can be used to obtain the voltage angle time series of the specified bus.","category":"page"},{"location":"execute/#Explore-output-currents","page":"Simulation Execution","title":"Explore output currents","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The functions get_real_current_series(results, \"DeviceName\") and get_imaginary_current_series(results, \"DeviceName\") can be used to obtain the output current time series of the specified device.","category":"page"},{"location":"execute/#Explore-output-power","page":"Simulation Execution","title":"Explore output power","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The functions get_activepower_series(results, \"DeviceName\") and get_reactivepower_series(results, \"DeviceName\") can be used to obtain the output power time series of the specified device.","category":"page"},{"location":"execute/#Explore-dynamic-states","page":"Simulation Execution","title":"Explore dynamic states","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function get_state_series(results, (\"DeviceName\", :StateSymbol) can be used to obtain the specified state time series of the specified device.","category":"page"},{"location":"execute/#Explore-Reference-Setpoints","page":"Simulation Execution","title":"Explore Reference Setpoints","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"The function get_setpoints(sim) can be used to obtain the reference setpoints of each dynamic device. Note: If a setpoint was changed via a perturbation, this function will return the modified setpoint.","category":"page"},{"location":"execute/#Keyword-Arguments","page":"Simulation Execution","title":"Keyword Arguments","text":"","category":"section"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Any solver option available in DifferentialEquations.jl can be passed as keyword arguments in the execute! function. Please see the Common Solver Options in the DifferentialEquations.jl documentation for more details.","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"Most common solver options used are dtmax to control the maximum dt for adaptive timestepping. abstol and reltol are also commonly used to control the tolerance in the adaptive timestepping. saveat is also used to store the results at a specified time stamps. For example, the following code is valid to further specify your solver options:","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"execute!(sim, IDA(), dtmax = 0.01, abstol = 1e-9, reltol = 1e-6, saveat = 0.01)","category":"page"},{"location":"execute/","page":"Simulation Execution","title":"Simulation Execution","text":"In addition, the keyword argument enable_progress_bar = false can be used to disable the progress bar.","category":"page"},{"location":"component_models/inner_control/#Inner-Loop-Controls","page":"Inner Control","title":"Inner Loop Controls","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"This component defines voltage and current controllers to generate the reference signal for the converter. Although in many controls the current and voltage control are separate blocks we propose a more general control approach that considers them as a joint control logic.","category":"page"},{"location":"component_models/inner_control/#Integrated-Virtual-Impedance,-Voltage-and-Current-Controller-[VoltageModeControl]","page":"Inner Control","title":"Integrated Virtual Impedance, Voltage and Current Controller [VoltageModeControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives both the outer loop control frequency and reference voltage signal to generate the reference signal for the converters. The virtual impedance plays a similar role of the impedance of a synchronous generator. A PI voltage controller is used to generate the current signal that is used in the PI current controller to finally generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotxi_d = v_dtextvi^textref - v_d tag1a \n    dotxi_q = v_qtextvi^textref - v_q tag1b \n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag1c \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag1d \n    dotphi_d = omega_textad(v_d - phi_d) tag1e \n    dotphi_q = omega_textad(v_q - phi_q) tag1f\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_dtextvi^textref = v_textolc^textref - r_v i_d + omega_textolc l_v i_q tag1g \n    v_qtextvi^textref = - r_v i_q - omega_textolc l_v i_d tag1h \n    i_dtextcv^textref = k_pvleft(v_dtextvi^textref - v_dright) + k_iv xi_d - c_f omega_textolc v_q + k_textffii_d tag1i \n    i_qtextcv^textref = k_pvleft(v_qtextvi^textref - v_qright) + k_iv xi_q + c_f omega_textolc v_d + k_textffii_q tag1j \n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d - k_textad(v_d - phi_d) tag1k \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q - k_textad(v_q - phi_q) tag1l\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here the transformation to the dq reference frame is using the outer-loop reference angle as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\nv_d + jv_q = (v_r + jv_i)e^-jdeltatheta_olc \ni_d + ji_q = (i_r + ji_i)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"that again v_r + jv_i could be in the capacitor or the last branch of the filter (i.e. the point of common coupling). For LCL filters it is considered in the capacitor. In the case of the converter, the transformation is directly","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/#Current-Mode-Controller-[CurrentModeControl]","page":"Inner Control","title":"Current Mode Controller [CurrentModeControl]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The following model receives the current reference (in dq axis) from an outer loop controller that outputs current references such as the PI outer controller used for grid following inverters. A PI current controller is used to generate the voltage reference signal for the converters.","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\n    dotgamma_d = i_dtextcv^textref - i_dtextcv tag2a \n    dotgamma_q = i_qtextcv^textref - i_qtextcv tag2b \nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"with","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    v_d^textref-signal = k_pc left(i_dtextcv^textref - i_dtextcvright) + k_ic gamma_d - omega_textolc l_f i_qtextcv + k_textffvv_d tag2b \n    v_q^textref-signal = k_pc left(i_qtextcv^textref - i_qtextcvright) + k_ic gamma_q + omega_textolc l_f i_dtextcv + k_textffvv_q tag2c\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The transformation for the converter current is computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign*\ni_dtextcv + ji_qtextcv = (i_rtextcv + ji_itextcv)e^-jtheta_olc\nendalign*","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"In here theta_olc is the outer-loop angle. In the case of grid-following models, this angle is equal to the angle provided from the PLL.","category":"page"},{"location":"component_models/inner_control/#Generic-Renewable-Inner-Controller-Type-B-[RECurrentControlB]","page":"Inner Control","title":"Generic Renewable Inner Controller Type B [RECurrentControlB]","text":"","category":"section"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"This models the inner control part of the REECB model. The equations (without limiters) when Q_Flag = 1 are:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    T_rv dotV_texttflt = V_t - dotV_texttflt tag3a \n    dotxi_icv = V_textocqcmd tag3b\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"on which V_textocqcmd comes from the Outer Controller and the output current commands I_textpcmd and I_textqcmd are computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    I_textpcmd = I_textoc pcmd tag3c \n    I_textqcmd = I_icv + I_textqinj tag3d \n    I_icv = K_vp V_textocqcmd + K_vi xi_icv tag3e \n    I_textqinj = K_qv (V_textref0 - V_texttflt) tag3f\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"The equations when Q_Flag = 0 are:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    T_rv dotV_texttflt = V_t - dotV_texttflt tag3g \n    T_iq dotI_icv = I_textocqcmd - I_icv tag3h\nendalign","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"on which I_textocqcmd comes from the Outer Controller and the output current commands I_textpcmd and I_textqcmd are computed as:","category":"page"},{"location":"component_models/inner_control/","page":"Inner Control","title":"Inner Control","text":"beginalign\n    I_textpcmd = I_textoc pcmd tag3i \n    I_textqcmd = I_icv + I_textqinj tag3j \n    I_textqinj = K_qv (V_textref0 - V_texttflt) tag3k\nendalign","category":"page"},{"location":"quick_start_guide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"The data for these tutorials is provided in PowerSystemCaseBuilder. If you want to build your own case, take a look at the tutorial Creating and Handling Data for Dynamic Simulations","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For more details about loading data and adding more dynamic components check the Creating a System with Dynamic devices section of the documentation in PowerSystems.jl.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"For a detailed tutorial about this case visit One Machine against Infinite Bus (OMIB) Simulation","category":"page"},{"location":"quick_start_guide/#Loading-data","page":"Quick Start Guide","title":"Loading data","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Data can be loaded from a pss/e raw file and a pss/e dyr file.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerSystems\nusing PowerSimulationsDynamics\nusing PowerSystemCaseBuilder\nusing Sundials\nusing Plots\n\nomib_sys = build_system(PSIDSystems, \"OMIB System\")","category":"page"},{"location":"quick_start_guide/#Define-the-Simulation","page":"Quick Start Guide","title":"Define the Simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"time_span = (0.0, 30.0)\nperturbation_trip = BranchTrip(1.0, Line, \"BUS 1-BUS 2-i_1\")\nsim = Simulation!(ResidualModel, omib_sys, pwd(), time_span, perturbation_trip)","category":"page"},{"location":"quick_start_guide/#Explore-initial-conditions-for-the-simulation","page":"Quick Start Guide","title":"Explore initial conditions for the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"x0_init = read_initial_conditions(sim)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"show_states_initial_value(sim)","category":"page"},{"location":"quick_start_guide/#Obtain-small-signal-results-for-initial-conditions","page":"Quick Start Guide","title":"Obtain small signal results for initial conditions","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"Show eigenvalues for operating point","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    small_sig = small_signal_analysis(sim)\n    summary_eigenvalues(small_sig)","category":"page"},{"location":"quick_start_guide/#Execute-the-simulation","page":"Quick Start Guide","title":"Execute the simulation","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"    execute!(sim, IDA(), dtmax = 0.02, saveat = 0.02, enable_progress_bar = false)","category":"page"},{"location":"quick_start_guide/#Make-a-plot-of-the-results","page":"Quick Start Guide","title":"Make a plot of the results","text":"","category":"section"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"results = read_results(sim)\nangle = get_state_series(results, (\"generator-102-1\", :δ));\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"gen-102-1\")","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"If you miss PSS/e's plotting aesthetics and want something that resembles that, you can use UnicodePlots.","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using UnicodePlots\nunicodeplots()\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"gen-102-1\");","category":"page"},{"location":"quick_start_guide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"(Image: plot)","category":"page"},{"location":"component_models/filters/#Filters","page":"Filter","title":"Filters","text":"","category":"section"},{"location":"component_models/filters/#LCL-Filter-[LCLFilter]","page":"Filter","title":"LCL Filter [LCLFilter]","text":"","category":"section"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"A standard LCL filter is proposed to connect the output of the converter to the grid. In this case, v_r and v_i are voltages in the capacitor, while v_r^textgrid and v_i^textgrid represent the voltage at the bus. The L filter after the capacitor can also include a step-up transformer to increase the voltage, that is model as an extra impedance.","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign\n    doti_rtextcv = fracOmega_bl_fleft( v_r^textcv - v_r  - r_f i_rtextcv + omega_textgrid l_f i_itextcv right) tag1a \n    doti_itextcv = fracOmega_bl_fleft( v_i^textcv - v_i  - r_f i_itextcv - omega_textgrid l_f i_rtextcv right) tag1b \n    dotv_r =  fracOmega_bc_fleft( i_r^textcv - i_r + omega_textgrid c_f v_i right) tag1c \n    dotv_i =  fracOmega_bc_fleft( i_i^textcv - i_i - omega_textgrid c_f v_r right) tag1d \n    doti_r = fracOmega_bl_gleft( v_r - v_r^textgrid - r_g i_r + omega_textgrid l_g i_i right) tag1e \n    doti_i = fracOmega_bl_gleft( v_i - v_i^textgrid - r_g i_i - omega_textgrid l_g i_r right) tag1f\nendalign","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"on which","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign*\nv_r^textcv + jv_i^textcv = (v_d^textcv + jv_q^textcv)e^jdeltatheta_olc\nendalign*","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"that comes from the converter model.","category":"page"},{"location":"component_models/filters/#RL-Filter-[RLFilter]","page":"Filter","title":"RL Filter [RLFilter]","text":"","category":"section"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"The algebraic RL filter is used to connect the output of the converter through a RL series filter using algebraic phasor equations. The equations for the output current are:","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"beginalign\n    i_r + ji_i = frac(v_r^textcv + j v_i^textcv) - (v_r^textgrid + jv_i^textgrid)r_f + jl_f tag2a\nendalign","category":"page"},{"location":"component_models/filters/","page":"Filter","title":"Filter","text":"on which v_r^textcv + jv_i^textcv comes from the converter model.","category":"page"},{"location":"tutorials/tutorial_activeload/#Tutorial-Active-Constant-Power-Load-model","page":"Active Load Model","title":"Tutorial Active Constant Power Load model","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"Originally Contributed by: Rodrigo Henriquez-Auba","category":"page"},{"location":"tutorials/tutorial_activeload/#Introduction","page":"Active Load Model","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"This tutorial will introduce you to the functionality of PowerSimulationsDynamics and PowerSystems to explore active load components and a small-signal analysis.","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"This tutorial presents a simulation of a two-bus system with a GFM inverter at bus 1, and a load on bus 2. We will change the model from a constant power load model, to a constant impedance model and then to a 12-state active constant power load model.","category":"page"},{"location":"tutorials/tutorial_activeload/#Dependencies","page":"Active Load Model","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"using PowerSimulationsDynamics;\nPSID = PowerSimulationsDynamics\nusing PowerSystemCaseBuilder\nusing PowerSystems\nconst PSY = PowerSystems;","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"PowerSystems (abbreviated with PSY) is used to properly define the data structure and establish an equilibrium point initial condition with a power flow routine using PowerFlows.","category":"page"},{"location":"tutorials/tutorial_activeload/#Load-the-system","page":"Active Load Model","title":"Load the system","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"We load the system using PowerSystemCaseBuilder.jl. This system has an inverter located at bus 1.","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sys = build_system(PSIDSystems, \"2 Bus Load Tutorial Droop\")","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"first(get_components(DynamicInverter, sys))","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"The load is an exponential load modeled as a constant power load since the coefficients are set to zero.","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"first(get_components(PSY.ExponentialLoad, sys))","category":"page"},{"location":"tutorials/tutorial_activeload/#Run-a-small-signal-analysis","page":"Active Load Model","title":"Run a small-signal analysis","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"We set up the Simulation. Since the droop model does not have a frequency state, we use a constant frequency reference frame for the network.","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sim = Simulation(ResidualModel,\n                sys,\n                mktempdir(),\n                (0.0, 1.0),\n                frequency_reference = ConstantFrequency())","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"The following provides a summary of eigenvalues for this droop system with a constant power load:","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sm = small_signal_analysis(sim);\ndf = summary_eigenvalues(sm);\nshow(df, allrows = true, allcols = true)","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"In this inverter model, the filter is modeled using differential equations, and as described in the literature, interfacing a RL filter against an algebraic constant power load usually results in unstable behavior as observed with the positive real part eigenvalue.","category":"page"},{"location":"tutorials/tutorial_activeload/#Change-to-a-constant-impedance-load-model","page":"Active Load Model","title":"Change to a constant impedance load model","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"Since the load is an exponential load model we can change the exponent coefficients to 2.0 to behave as a constant impedance model:","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"# Update load coefficients to 2.0\nload = first(get_components(PSY.ExponentialLoad, sys));\nPSY.set_active_power_coefficient!(load, 2.0);\nPSY.set_reactive_power_coefficient!(load, 2.0);","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"We then re-run the small-signal analysis:","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sim = Simulation(ResidualModel,\n                sys,\n                mktempdir(),\n                (0.0, 1.0),\n                frequency_reference = ConstantFrequency())","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sm = small_signal_analysis(sim);\ndf = summary_eigenvalues(sm);\nshow(df, allrows = true, allcols = true)","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"Observe that now the system is small-signal stable (since there is only one device the angle of the inverter is used as a reference, and hence is zero).","category":"page"},{"location":"tutorials/tutorial_activeload/#Adding-a-dynamic-active-load-model","page":"Active Load Model","title":"Adding a dynamic active load model","text":"","category":"section"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"To consider a dynamic model in the load it is only required to attach a dynamic component to the static load model. When a dynamic load model is attached, the active and reactive power of the static model are used to define reference parameters to ensure that the dynamic load model matches the static load output power.","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"Note that when a dynamic model is attached to a static model, the static model does not participate in the dynamic system equations, i.e. the only model interfacing to the network equations is the dynamic model and not the static model (the exponential load).","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"We define a function to create a active load model with the specific parameters:","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"# Parameters taken from active load model from N. Bottrell Masters\n# Thesis \"Small-Signal Analysis of Active Loads and Large-signal Analysis\n# of Faults in Inverter Interfaced Microgrid Applications\", 2014.\n\n# The parameters are then per-unitized to be scalable to represent an aggregation\n# of multiple active loads\n\n# Base AC Voltage: Vb = 380 V\n# Base Power (AC and DC): Pb = 10000 VA\n# Base AC Current: Ib = 10000 / 380 = 26.32 A\n# Base AC Impedance: Zb = 380 / 26.32 =  14.44 Ω\n# Base AC Inductance: Lb = Zb / Ωb = 14.44 / 377 = 0.3831 H\n# Base AC Capacitance: Cb = 1 / (Zb * Ωb) = 0.000183697 F\n# Base DC Voltage: Vb_dc = (√8/√3) Vb = 620.54 V\n# Base DC Current: Ib_dc = Pb / V_dc = 10000/620.54 = 16.12 A\n# Base DC Impedance: Zb_dc = Vb_dc / Ib_dc = 38.50 Ω\n# Base DC Capacitance: Cb_dc = 1 / (Zb_dc * Ωb) = 6.8886315e-5 F\n\nΩb = 2*pi*60;\nVb = 380;\nPb = 10000;\nIb = Pb / Vb;\nZb = Vb / Ib;\nLb = Zb / Ωb;\nCb = 1 / (Zb * Ωb);\nVb_dc = sqrt(8)/sqrt(3) * Vb;\nIb_dc = Pb / Vb_dc;\nZb_dc = Vb_dc / Ib_dc;\nCb_dc = 1/(Zb_dc * Ωb);\n\nfunction active_cpl(load)\n    return PSY.ActiveConstantPowerLoad(\n        name = get_name(load),\n        r_load = 70.0 / Zb_dc,\n        c_dc = 2040e-6 / Cb_dc,\n        rf = 0.1 / Zb,\n        lf = 2.3e-3 / Lb,\n        cf = 8.8e-6 / Cb,\n        rg = 0.03 / Zb,\n        lg = 0.93e-3 / Lb,\n        kp_pll = 0.4,\n        ki_pll = 4.69,\n        kpv = 0.5 * (Vb_dc / Ib_dc),\n        kiv = 150.0 * (Vb_dc / Ib_dc),\n        kpc = 15.0 * (Ib / Vb),\n        kic = 30000.0 * (Ib / Vb),\n        base_power = 100.0,\n    )\nend","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"We then attach the model to the system:","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"load = first(get_components(PSY.ExponentialLoad, sys));\ndyn_load = active_cpl(load)\nadd_component!(sys, dyn_load, load)","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"Finally, we set up the simulation:","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sim = Simulation(ResidualModel,\n                sys,\n                mktempdir(),\n                (0.0, 1.0),\n                frequency_reference = ConstantFrequency())","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"sm = small_signal_analysis(sim);\ndf = summary_eigenvalues(sm);\nshow(df, allrows = true, allcols = true)","category":"page"},{"location":"tutorials/tutorial_activeload/","page":"Active Load Model","title":"Active Load Model","text":"Observe the new states of the active load model and that the system is small-signal stable.","category":"page"},{"location":"component_models/turbine_gov/#Prime-Movers-and-Turbine-Governors-(TG)","page":"Turbine and Governor","title":"Prime Movers and Turbine Governors (TG)","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This section describes how mechanical power is modified to provide primary frequency control with synchronous generators. It is assumed that tau_textref = P_textref since they are decided at nominal frequency omega = 1.","category":"page"},{"location":"component_models/turbine_gov/#Fixed-TG-[TGFixed]","page":"Turbine and Governor","title":"Fixed TG [TGFixed]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This a simple model that set the mechanical torque to be equal to a proportion of the desired reference tau_m = eta P_textref. To set the mechanical torque to be equal to the desired power, the value of eta is set to 1.","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-I-[TGTypeI]","page":"Turbine and Governor","title":"TG Type I [TGTypeI]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is described by a droop controller and a low-pass filter to model the governor and two lead-lag blocks to model the servo and reheat of the turbine governor.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_s(p_textin - x_g1) tag1a \ndotx_g2 = frac1T_c left left(1- fract_3T_cright)x_g1 - x_g2 right tag1b \ndotx_g3 = frac1T_5 leftleft(1 - fracT_4T_5right)left(x_g2 + fracT_3T_cx_g1right) - x_g3  right tag1c \ntau_m = x_g3 + fracT_4T_5left(x_g2 + fracT_3T_cx_g1right) tag1d\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign*\np_textin = P_textref + frac1R(omega_s - 10)\nendalign*","category":"page"},{"location":"component_models/turbine_gov/#TG-Type-II-[TGTypeII]","page":"Turbine and Governor","title":"TG Type II [TGTypeII]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor is a simplified model of the Type I.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g = frac1T_2leftfrac1Rleft(1 - fracT_1T_2right) (omega_s - omega) - x_gright tag2a \ntau_m = P_textref + frac1RfracT_1T_2(omega_s - omega) tag2b\nendalign","category":"page"},{"location":"component_models/turbine_gov/#TGOV1-[SteamTurbineGov1]","page":"Turbine and Governor","title":"TGOV1 [SteamTurbineGov1]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This represents a classical Steam-Turbine Governor, known as TGOV1.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_1 (textref_in - x_g1) tag3a \ndotx_g2 = frac1T_3 left(x_g1^textsat left(1 - fracT_2T_3right) - x_g2right) tag3b\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ntextref_in = frac1R (P_ref - (omega - 10)) tag3c \nx_g1^textsat = left beginarraycl\n                        x_g1  text if  V_min le x_g1 le V_max\n                        V_max  text if  x_g1  V_max \n                        V_min  text if  x_g1  V_min\n                    endarray right tag3d \ntau_m = x_g2 + fracT_2T_3 x_g1 - D_T(omega - 10) tag3e\nendalign","category":"page"},{"location":"component_models/turbine_gov/#GAST-[GasTG]","page":"Turbine and Governor","title":"GAST [GasTG]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This turbine governor represents the Gas Turbine representation, known as GAST.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\ndotx_g1 = frac1T_1 (x_in - x_g1) tag4a \ndotx_g2 = frac1T_2 left(x_g1^textsat - x_g2right) tag4b \ndotx_g3 = frac1T_3 (x_g2 - x_g3) tag4c\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nx_in = minleftP_ref - frac1R(omega - 10) A_T + K_T (A_T - x_g3) right tag4d \nx_g1^textsat = left beginarraycl\n                        x_g1  text if  V_min le x_g1 le V_max\n                        V_max  text if  x_g1  V_max \n                        V_min  text if  x_g1  V_min\n                    endarray right tag4e \ntau_m = x_g2  - D_T(omega - 10) tag4f\nendalign","category":"page"},{"location":"component_models/turbine_gov/#HYGOV-[HydroTurbineGov]","page":"Turbine and Governor","title":"HYGOV [HydroTurbineGov]","text":"","category":"section"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"This represents a classical hydro governor, known as HYGOV.","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nT_fdotx_g1 = P_in - x_g1 tag5a \ndotx_g2 = x_g1 tag5b\nT_g dotx_g3 = c - x_g3 tag5c\ndotx_g4 = frac1 - hT_w tag5d\nendalign","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"with","category":"page"},{"location":"component_models/turbine_gov/","page":"Turbine and Governor","title":"Turbine and Governor","text":"beginalign\nP_in = P_ref - Delta omega - R x_g2 tag5e \nc = fracx_g1r + fracx_g2rT_r tag5f \nh = left(fracx_g4x_g3right)^2 tag5g\ntau_m = hcdot A_t(x_g4 - q_NL) - D_turb Deltaomega cdot x_g3 tag5h\nendalign","category":"page"},{"location":"small/#Small-Signal-Analysis","page":"Small Signal","title":"Small Signal Analysis","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Here we discuss the method used to do a small signal analysis on the DAE system defined in PowerSimulationsDynamics.jl. The package defines algebraic variables for both real and imaginary voltages on all buses (except if they have a dynamic line connected, on which the voltage of those buses are treated as differential variables). In addition, each dynamic device can add differential variables (or states) that are concatenated to construct the system of differential algebraic equations.","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Note: The validation of small signal results is still work in progress due to the differences in the way that different software packages perform the calculations.","category":"page"},{"location":"small/#Automatic-Differentiation","page":"Small Signal","title":"Automatic Differentiation","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"Once an equilibrium point is found, the complete jacobian of the non-linear system can be obtained using automatic differentiation in Julia. In particular, the package ForwardDiff.jl is used to obtain the jacobian of the non-linear algebraic system of equations. PowerSimulationsDynamics.jl handles the resulting jacobian and reports the reduced jacobian and the corresponding eigenvalues and eigenvectors.","category":"page"},{"location":"small/#Jacobian-Reduction","page":"Small Signal","title":"Jacobian Reduction","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"We define y as the vector of algebraic variables, x as the vector of differential variables (states) and p the parameters of the system, we can define g(yxp) as the vector of algebraic equations and f(yxp) as the vector of differential equations. With that, the non-linear differential algebraic system of equations can be written as:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  dotx\n  endarrayright = leftbeginarrayc\n  g(yxp) \n   f(yxp) endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analysis, we are interested in the stability around an equilbrium point y_eqx_eq that satisfies dotx = 0 or equivalently f(y_eqx_eqp) = 0, while obviously satisfying g(y_eq x_eq p) = 0. To do that we use a first order approximation:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nleftbeginarrayc\n 0 \n  Deltadotx\n  endarrayright = underbraceleftbeginarray\n  g(y_eqx_eqp) \n   f(y_eqx_eqp) endarrayright_ = 0\n + Jy_eq x_eq p leftbeginarrayc\n Delta y \n  Delta x\n  endarrayright\n  endalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"The first to note is that the jacobian matrix can be splitted in 4 blocks depending on the specific variables we are taking the partial derivatives:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJy_eq x_eq p =\nleftbeginarraycc\n g_y  g_x \n f_y  f_x \n  endarrayright\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"For small signal analyses, we are interested in the stability of the differential states, while still considering that those need to evolve in the manifold defined by the linearized algebraic equations. Assuming that g_y is not singular (see chapter 7 of Federico Milano's book: Power System Modelling and Scripting or the following paper) we can eliminate the algebraic variables to obtain the reduced jacobian:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nJ_textred = f_x - f_y g_y^-1 g_x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"that defines our reduced system for the differential variables","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\nDelta dotx = J_textred Delta x\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"on which we can compute its eigenvalues to analyze local stability.","category":"page"},{"location":"small/#Accessing-the-Jacobian-function","page":"Small Signal","title":"Accessing the Jacobian function","text":"","category":"section"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"You can retrieve the Jacobian function for a simulation using the get_jacobian function as follows:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian = function get_jacobian(ResidualModel, system)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"optionally you can pass the number of iterations to check for sparsity as follows:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian = function get_jacobian(ResidualModel, system, 0)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"if you specify 0, the jacobian function will use a full matrix.","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"The return of get_jacobian is known as a functor in Julia and can be used to make evaluations. Currently, any function can be evaluated with the following inputs:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(x)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version of the function is type unstable should only be used for non-critial ops. It works to get the eigenvalues given an operating point x","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(JM, x)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version evaluates in place the value of the jacobian for an operating point x and writes to the matrix JM","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(JM, x, p, t)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version complied with the requirements to be used in DiffEq for ODE solvers. p and t aren't used they just mean to match the interfaces. See DiffEqDocs","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"jacobian(JM, dx, x, p, gamma, t)","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"This version complied with the requirements to be used in DiffEq for DAE solvers. p and t aren't used they just mean to match the interfaces. It assumes that the jacobian has the form:","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"beginalign\n  JM = gamma * I + J(x)\nendalign","category":"page"},{"location":"small/","page":"Small Signal","title":"Small Signal","text":"See DiffEqDocs for additional details.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Here we discuss the models used to describe load modeling in PowerSimulationsDynamics.jl.  In a similar fashion of other devices, loads will withdraw power (i.e. current) from the current-injection balances at the nodal level. Based on the specified parameters and model chosen, the equations for computing such withdrawal will change.","category":"page"},{"location":"component_models/loads/#Static-Loads-(or-Algebraic-Loads)","page":"Load Models","title":"Static Loads (or Algebraic Loads)","text":"","category":"section"},{"location":"component_models/loads/#ZIP-Exponential-Load-Model","page":"Load Models","title":"ZIP + Exponential Load Model","text":"","category":"section"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"PowerSimulationsDynamics.jl uses all the static ZIP and exponential loads at each bus to obtain a single structure that creates an aggregate ZIP load model and a collection of all exponential loads.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The ZIP load model given by:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nP_textzip = P_textpower + P_textcurrent cdot fracVV_0 + P_textimpedance cdot left(fracVV_0right)^2 tag1a\nQ_textzip = Q_textpower + Q_textcurrent  cdot fracVV_0 + Q_textimpedance cdot left(fracVV_0right)^2tag1b\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"with V = sqrtV_r^2 + V_i^2 and V_0 the voltage magnitude from the power flow solution.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The current taken for the load is computed as:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textzip = frac(P_textzip + j Q_textzip)^*(V_r + j V_i)^*tag1c \nI_textzip = fracP_textzip - j Q_textzipV_r - j V_itag1d\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"For constant impedance load, the current obtained is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textre^z = frac1V_0^2 cdot (V_r cdot P_textimpedance + V_i cdot Q_textimpedance)tag1e \nI_textim^z = frac1V_0^2 cdot (V_i cdot P_textimpedance - V_r cdot Q_textimpedance)tag1f\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"For constant current load, the current obtained is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textre^i  = frac1V_0 cdot fracV_r * P_textcurrent + V_i * Q_textcurrentV tag1g\nI_textim^i  = frac1V_0 cdot fracV_i * P_textcurrent - V_r * Q_textcurrentV tag1h\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"For constant power load, the current obtained is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textre^p  =  fracV_r cdot P_textpower + V_i cdot Q_textpowerV^2 tag1i \nI_textim^p =  fracV_i cdot P_textpower - V_r cdot Q_textpowerV^2 tag1j\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Then the total current withdrawed from the ZIP load model is simply","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textzip^textre  =  I_textre^z + I_textre^i + I_textre^p tag1k \nI_textzip^textim  =  I_textim^z + I_textim^i + I_textim^p tag1l\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"On the case of Exponential Loads, the model is given by:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nP_textexp = P_0 cdot left(fracVV_0right)^alpha tag1m\nQ_textexp = Q_0 cdot left(fracVV_0right)^beta tag1n\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The current taken for the load is computed as:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textexp = frac(P_textexp + j Q_textexp)^*(V_r + j V_i)^* tag1o \nI_textexp = fracP_textexp - j Q_textexpV_r - j V_i tag1p\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"that results:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\nI_textexp^textre  = V_r cdot P_0 cdot fracV^alpha - 2V_0^alpha + V_i cdot Q_0 cdot fracV^beta - 2V_0^beta tag1q\nI_textexp^textim  = V_i cdot P_0 cdot fracV^alpha - 2V_0^alpha - V_r cdot Q_0 cdot fracV^beta - 2V_0^beta tag1r\nendalign","category":"page"},{"location":"component_models/loads/#Dynamic-loads","page":"Load Models","title":"Dynamic loads","text":"","category":"section"},{"location":"component_models/loads/#th-order-Single-Cage-Induction-Machine-[SingleCageInductionMachine]","page":"Load Models","title":"5th-order Single Cage Induction Machine [SingleCageInductionMachine]","text":"","category":"section"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The following model is used to model a 5th-order induction machine with a quadratic relationship speed-torque. Refer to \"Analysis of Electric Machinery and Drive Systems\" by Paul Krause, Oleg Wasynczuk and Scott Sudhoff for the equations derivation","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\ndotpsi_qs = Omega_b (v_qs - omega_textsys psi_ds - R_s i_qs) tag2a\ndotpsi_ds = Omega_b (v_ds + omega_textsys psi_qs - R_s i_ds) tag2b \ndotpsi_qr = Omega_b left(v_qr - (omega_textsys - omega_r) psi_dr + fracR_rX_lr (psi_mq - psi_qr)right) tag2c\ndotpsi_dr = Omega_b left(v_dr + (omega_textsys - omega_r) psi_qr + fracR_rX_lr (psi_md - psi_dr)right) tag2d\ndotomega_r = frac12H (tau_e - tau_m0(A omega_r^2 + B omega_r + C)) tag2e\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"where:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nX_ad = X_aq = left(frac1X_m + frac1X_ls + frac1X_lrright)^-1 \nv_qs = V_i^textbus \nv_ds = V_r^textbus \nv_qr = v_dr = 0 \npsi_mq = X_aq left(fracpsi_qsX_ls+ fracpsi_qrX_lrright) \npsi_md = X_ad left(fracpsi_dsX_ls+ fracpsi_drX_lrright) \ni_qs = frac1X_ls (psi_qs - psi_mq) \ni_ds = frac1X_ls (psi_ds - psi_md) \ntau_e = psi_ds i_qs - psi_qs i_ds \nendalign*","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Finally, the withdrawed current from the bus is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nI_r = left(fracS_textmotorS_textbaseright) (i_ds - v_qs B_sh) \nI_i = left(fracS_textmotorS_textbaseright) (i_qs + v_ds B_sh) \nendalign*","category":"page"},{"location":"component_models/loads/#rd-order-Single-Cage-Induction-Machine-[SimplifiedSingleCageInductionMachine]","page":"Load Models","title":"3rd-order Single Cage Induction Machine [SimplifiedSingleCageInductionMachine]","text":"","category":"section"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"The following models approximates the stator fluxes dynamics of the 5th-order model by using algebraic equations.","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign\ndotpsi_qr = Omega_b left(v_qr - (omega_textsys - omega_r) psi_dr - R_r i_qr right) tag3a \ndotpsi_dr = Omega_b left(v_dr + (omega_textsys - omega_r) psi_qr - R_r i_drright) tag3b \ndotomega_r = frac12H (tau_e - tau_m0(A omega_r^2 + B omega_r + C)) tag3c\nendalign","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"where","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nv_qs = V_i^textbus \nv_ds = V_r^textbus \nv_qr = v_dr = 0 \ni_qs = frac1R_s^2 + omega_textsys^2 X_p^2 left( (R_s v_qs - omega_textsys X_p v_ds) - left(R_s omega_textsys fracX_mX_rr psi_dr + omega_textsys^2 X_p fracX_mX_rr psi_qr right) right) \ni_ds = frac1R_s^2 + omega_textsys^2 X_p^2 left( (R_s v_ds + omega_textsys X_p v_qs) - left(-R_s omega_textsys fracX_mX_rr psi_qr + omega_textsys^2 X_p fracX_mX_rr psi_dr right) right) \ni_qr = frac1X_rr (psi_qr - X_m i_qs) \ni_dr = frac1X_rr (psi_dr - X_m i_ds) \ntau_e = psi_qr i_dr - psi_dr i_qr \nendalign*","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"Finally, the withdrawed current from the bus is:","category":"page"},{"location":"component_models/loads/","page":"Load Models","title":"Load Models","text":"beginalign*\nI_r = left(fracS_textmotorS_textbaseright) (i_ds - v_qs B_sh) \nI_i = left(fracS_textmotorS_textbaseright) (i_qs + v_ds B_sh) \nendalign*","category":"page"},{"location":"tutorials/tutorial_240bus/#[PSSE-240-Bus-Case-system-with-Renewables](https://www.nrel.gov/grid/test-case-repository.html)","page":"240 WECC solver comparison","title":"PSSE 240 Bus Case system with Renewables","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"Originally Contributed by: José Daniel Lara","category":"page"},{"location":"tutorials/tutorial_240bus/#Introduction","page":"240 WECC solver comparison","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"This tutorial will introduce the industry models of Renewable Energy the comparisons between DiffEq Integration techniques for comparison. We show the uses of Sundials and OrdinaryDiffEq to obtain the transient response of a system to a perturbation.","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"using PowerSimulationsDynamics\nusing PowerSystemCaseBuilder\nusing PowerSystems\nconst PSY = PowerSystems\nusing Sundials\nusing Plots\nusing OrdinaryDiffEq","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_240bus/#Load-the-system-and-transform-load-data","page":"240 WECC solver comparison","title":"Load the system and transform load data","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"To load the system we use PowerSystemCaseBuilder.jl:","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"# We remove the checks in this example to avoid large prints\nsys = build_system(PSIDSystems, \"WECC 240 Bus\"; runchecks = false)\n\n# Transform the system's load\nfor l in get_components(PSY.StandardLoad, sys)\n    transform_load_to_constant_impedance(l)\nend","category":"page"},{"location":"tutorials/tutorial_240bus/#Build-the-simulation-and-initialize-the-problem","page":"240 WECC solver comparison","title":"Build the simulation and initialize the problem","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"The next step is to create the simulation structure. This will create the indexing of our system that will be used to formulate the differential-algebraic system of equations. To do so, it is required to specify the perturbation that will occur in the system. In this case, we will use a ResidualModel formulation, for more details about the formulation checkout the Models Section in PowerSimulationsDynamics.jl documentation.","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"using Logging\nsim_ida = Simulation(\n    ResidualModel,\n    sys, #system\n    pwd(),\n    (0.0, 20.0), #time span\n    BranchTrip(1.0, Line, \"CORONADO    -1101-PALOVRDE    -1401-i_10\");\n    console_level = Logging.Info,\n)","category":"page"},{"location":"tutorials/tutorial_240bus/#Run-the-simulation-using-Sundials","page":"240 WECC solver comparison","title":"Run the simulation using Sundials","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"We will now run the simulation using Sundials.jl solver IDA() by specifying the maximum dt we want for the simulation. In our experience with this solver, solution times are faster when supplying information about the maximum time step than the tolerances as we can see in the example","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"execute!(sim_ida, IDA(), dtmax = 0.01)","category":"page"},{"location":"tutorials/tutorial_240bus/#Read-the-results-and-plot-a-system-variable","page":"240 WECC solver comparison","title":"Read the results and plot a system variable","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"After the simulation is completed, we can extract the results and make plots as desired. In this case, we will plot the voltage magnitude at the bus at which the line was connected.","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"res_ida = read_results(sim_ida)\nv1101_ida = get_voltage_magnitude_series(res_ida, 1101);\nplot(v1101_ida);","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_240bus/#Run-the-simulation-using-Rodas4()","page":"240 WECC solver comparison","title":"Run the simulation using Rodas4()","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"In this case, we will use a MassMatrixModel formulation, for more details about the formulation checkout the Models Section in PowerSimulationsDynamics.jl documentation","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"sim_rodas = Simulation(\n    MassMatrixModel,\n    sys, #system\n    pwd(),\n    (0.0, 20.0), #time span\n    BranchTrip(1.0, Line, \"CORONADO    -1101-PALOVRDE    -1401-i_10\");\n    console_level = Logging.Info,\n)","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"We will now run the simulation using OrdinaryDiffEq.jl solver Rodas4() by specifying the tolerance we want for the simulation. In our experience with this solver, solution times are faster when supplying information about the atol and rtol values as we can see in the example. The solver will also work with a specified dtmax but take a significantly longer time to solve. When using OrdinaryDiffEq.jl solvers always pass the option initializealg = NoInit() to avoid unnecessary re-initialization of the algebraic equations.","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"execute!(\n    sim_rodas,\n    Rodas4(),\n    saveat = 0.01,\n    atol = 1e-10,\n    rtol = 1e-10,\n    initializealg = NoInit(),\n)","category":"page"},{"location":"tutorials/tutorial_240bus/#Read-the-results","page":"240 WECC solver comparison","title":"Read the results","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"After the simulation is completed, we can extract the results and make plots as desired. In this case, we will plot the voltage magnitude at the bus at which the line was connected.","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"res_rodas = read_results(sim_rodas)","category":"page"},{"location":"tutorials/tutorial_240bus/#Compare-the-results","page":"240 WECC solver comparison","title":"Compare the results","text":"","category":"section"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"After the simulation is completed, we can extract the results and make plots as desired. In this case, we will plot the voltage magnitude at the bus at which the line was connected. For both of the solution techniques.","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"v1101 = get_voltage_magnitude_series(res_rodas, 1101);\nplot(v1101, label = \"RODAS4\");\nplot!(v1101_ida, label = \"IDA\");","category":"page"},{"location":"tutorials/tutorial_240bus/","page":"240 WECC solver comparison","title":"240 WECC solver comparison","text":"(Image: plot)","category":"page"},{"location":"component_models/freq_esti/#Frequency-Estimators","page":"Frequency Estimators","title":"Frequency Estimators","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This component is used to estimate the frequency of the grid based on the voltage at the bus.","category":"page"},{"location":"component_models/freq_esti/#Fixed-Frequency-[FixedFrequency]","page":"Frequency Estimators","title":"Fixed Frequency [FixedFrequency]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"This is a simple model that set the measured frequency to a desired constant value (i.e. does not measure the frequency) omega_pll = omega_textfix (usually omega_textfix = 10 p.u.). Used by default when grid-forming  inverters do not use frequency estimators. ","category":"page"},{"location":"component_models/freq_esti/#Phase-Locked-Loop-(PLL)-for-VSM-[KauraPLL]","page":"Frequency Estimators","title":"Phase-Locked Loop (PLL) for VSM [KauraPLL]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"The following equations present a PLL used to estimate the frequency and PLL angle of the grid. There are two reference frames considered in this inverter. Those are the VSM of the outer-loop control theta_textolc and the PLL one theta_textpll. The notation used a deltatheta refers as the variation of the respective angle theta^textgrid with respect to the grid SRF (instead of the fixed alpha component of the alphabeta transformation):","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\n\ndotv_dtextpll = omega_textlp left v_dtextout - v_dtextpll right tag1a \ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag1b \ndotvarepsilon_textpll = tan^-1left(fracv_qtextpllv_dtextpll right) tag1c \ndottheta_textpll = Omega_b delta omega_textpll tag1d\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"with","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndeltaomega_textpll = 10 - omega_textsys + k_ptextpll tan^-1 left(fracv_qtextpllv_dtextpll right) + k_itextpll varepsilon_textpll tag1e \nomega_textpll = deltaomega_textpll + omega_textsys tag1f \nv_dtextout + jv_qtextout = (v_r + jv_i)e^-deltatheta_textpll  tag1g\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring (i.e. point of common coupling), that could be in the capacitor of an LCL filter or the last branch of such filter.","category":"page"},{"location":"component_models/freq_esti/#Reduced-Order-Phase-Locked-Loop-(PLL)-[ReducedOrderPLL]","page":"Frequency Estimators","title":"Reduced Order Phase-Locked Loop (PLL) [ReducedOrderPLL]","text":"","category":"section"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"The following equations presents a simplified PLL used to estimate the frequency and PLL angle of the grid. The model attempts to steer the voltage in the q-axis to zero (i.e. lock the q-axis to zero) using a PI controller. With that the equations are given by:","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndotv_qtextpll = omega_textlp left v_qtextout - v_qtextpll right tag2a \ndotvarepsilon_textpll = v_qtextpll tag2b \ndottheta_textpll = Omega_b delta omega_textpll tag2c\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"with","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"beginalign\ndeltaomega_textpll = 10 - omega_textsys + k_ptextpll v_qtextpll + k_itextpll varepsilon_textpll tag2d \nomega_textpll = deltaomega_textpll + omega_textsys tag2e \nv_dtextout + jv_qtextout = (v_r + jv_i)e^-deltatheta_textpll  tag2f\nendalign","category":"page"},{"location":"component_models/freq_esti/","page":"Frequency Estimators","title":"Frequency Estimators","text":"on which v_r + jv_i is the voltage in the grid reference frame on which the PLL is measuring (i.e. point of common coupling), that could be in the capacitor of an LCL filter or the last branch of such filter.","category":"page"},{"location":"code_base_developer_guide/developer/#Guidelines-for-Developers","page":"Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"In order to contribute to PowerSimulationsDynamics.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"code_base_developer_guide/developer/","page":"Developer Guide","title":"Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Creating-and-Handling-Data-for-Dynamic-Simulations","page":"Create Dynamic Data","title":"Creating and Handling Data for Dynamic Simulations","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Originally Contributed by: Rodrigo Henriquez and José Daniel Lara","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Introduction","page":"Create Dynamic Data","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"This tutorial briefly introduces how to create a system using PowerSystems.jl data structures. For more details visit PowerSystems.jl Documentation","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Start by calling PowerSystems.jl and PowerSystemCaseBuilder.jl:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"using PowerSystems\nusing PowerSystemCaseBuilder\nconst PSY = PowerSystems;","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#System-description","page":"Create Dynamic Data","title":"System description","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Next we need to define the different elements required to run a simulation. To run a simulation in PowerSimulationsDynamics, it is required to define a System that contains the following components:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Static-Components","page":"Create Dynamic Data","title":"Static Components","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We called static components to those that are used to run a Power Flow problem.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Vector of Bus elements, that define all the buses in the network.\nVector of Branch elements, that define all the branches elements (that connect two buses) in the network.\nVector of StaticInjection elements, that define all the devices connected to buses that can inject (or withdraw) power. These static devices, typically generators, in PowerSimulationsDynamics are used to solve the Power Flow problem that determines the active and reactive power provided for each device.\nVector of PowerLoad elements, that define all the loads connected to buses that can withdraw current. These are also used to solve the Power Flow.\nVector of Source elements, that define source components behind a reactance that can inject or withdraw current.\nThe base of power used to define per unit values, in MVA as a Float64 value.\nThe base frequency used in the system, in Hz as a Float64 value.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Dynamic-Components","page":"Create Dynamic Data","title":"Dynamic Components","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Dynamic components are those that define differential equations to run a transient simulation.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Vector of DynamicInjection elements. These components must be attached to a StaticInjection that connects the power flow solution to the dynamic formulation of such device. DynamicInjection can be DynamicGenerator or DynamicInverter, and its specific formulation (i.e. differential equations) will depend on the specific components that define such device.\n(Optional) Selecting which of the Lines (of the Branch vector) elements must be modeled of DynamicLines elements, that can be used to model lines with differential equations.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"To start we will define the data structures for the network.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Three-Bus-case-manual-data-creation","page":"Create Dynamic Data","title":"Three Bus case manual data creation","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"The following describes the system creation for this dynamic simulation case.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Static-System-creation","page":"Create Dynamic Data","title":"Static System creation","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"To create the system you need to load data using PowerSystemCaseBuilder.jl. This system was originally created from following raw file.  ","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"sys = build_system(PSIDSystems, \"3 Bus Inverter Base\"; force_build=true)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"This system does not have an injection device in bus 1 (the reference bus). We can add a source with small impedance directly as follows:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"slack_bus = [b for b in get_components(ACBus, sys) if get_bustype(b) == ACBusTypes.REF][1]\ninf_source = Source(\n    name = \"InfBus\", #name\n    available = true, #availability\n    active_power = 0.0,\n    reactive_power = 0.0,\n    bus = slack_bus, #bus\n    R_th = 0.0, #Rth\n    X_th = 5e-6, #Xth\n)\nadd_component!(sys, inf_source)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We just added a infinite source with X_th = 5cdot 10^-6 pu. The system can be explored directly using functions like:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"show_components(sys, Source)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"show_components(sys, ThermalStandard)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"By exploring those it can be seen that the generators are named as: generator-bus_number-id. Then, the generator attached at bus 2 is named generator-102-1.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Dynamic-Injections","page":"Create Dynamic Data","title":"Dynamic Injections","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We are now interested in attaching to the system the dynamic component that will be modeling our dynamic generator.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Dynamic generator devices are composed by 5 components, namely, machine, shaft, avr, tg and pss. So we will be adding functions to create all of its components and the generator itself:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"# *Machine*\nmachine_classic() = BaseMachine(\n    0.0, #R\n    0.2995, #Xd_p\n    0.7087, #eq_p\n)\n\n# *Shaft*\nshaft_damping() = SingleMass(\n    3.148, #H\n    2.0, #D\n)\n\n# *AVR: No AVR*\navr_none() = AVRFixed(0.0)\n\n# *TG: No TG*\ntg_none() = TGFixed(1.0) #efficiency\n\n# *PSS: No PSS*\npss_none() = PSSFixed(0.0)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"The next lines receives a static generator name, and creates a DynamicGenerator based on that specific static generator, with the specific components defined previously. This is a classic machine model without AVR, Turbine Governor and PSS.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"static_gen = get_component(Generator, sys, \"generator-102-1\")\n\ndyn_gen = DynamicGenerator(\n    name = get_name(static_gen),\n    ω_ref = 1.0,\n    machine = machine_classic(),\n    shaft = shaft_damping(),\n    avr = avr_none(),\n    prime_mover = tg_none(),\n    pss = pss_none(),\n)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"The dynamic generator is added to the system by specifying the dynamic and static generator","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"add_component!(sys, dyn_gen, static_gen)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Then we can serialize our system data to a json file that can be later read as:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"file_dir = @__DIR__ #hide\nto_json(sys, joinpath(file_dir, \"modified_sys.json\"), force = true)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Dynamic-Lines-case:-Data-creation","page":"Create Dynamic Data","title":"Dynamic Lines case: Data creation","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We will now create a three bus system with one inverter and one generator. In order to do so, we will parse the following ThreebusInverter.raw network:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"threebus_sys = build_system(PSIDSystems, \"3 Bus Inverter Base\")\nslack_bus = first(get_components(x -> get_bustype(x) == BusTypes.REF, Bus, threebus_sys))\ninf_source = Source(\n    name = \"InfBus\", #name\n    available = true, #availability\n    active_power = 0.0,\n    reactive_power = 0.0,\n    bus = slack_bus, #bus\n    R_th = 0.0, #Rth\n    X_th = 5e-6, #Xth\n)\nadd_component!(threebus_sys, inf_source)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We will connect a One-d-one-q machine at bus 102, and a Virtual Synchronous Generator Inverter at bus 103. An inverter is composed by a converter, outer control, inner control, dc source, frequency estimator and a filter.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Dynamic-Inverter-definition","page":"Create Dynamic Data","title":"Dynamic Inverter definition","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We will create specific functions to create the components of the inverter as follows:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"#Define converter as an AverageConverter\nconverter_high_power() = AverageConverter(\n    rated_voltage = 138.0,\n    rated_current = 100.0\n    )\n\n#Define Outer Control as a composition of Virtual Inertia + Reactive Power Droop\nouter_control() = OuterControl(\n    VirtualInertia(Ta = 2.0, kd = 400.0, kω = 20.0),\n    ReactivePowerDroop(kq = 0.2, ωf = 1000.0),\n)\n\n#Define an Inner Control as a Voltage+Current Controler with Virtual Impedance:\ninner_control() = VoltageModeControl(\n    kpv = 0.59,     #Voltage controller proportional gain\n    kiv = 736.0,    #Voltage controller integral gain\n    kffv = 0.0,     #Binary variable enabling voltage feed-forward in current controllers\n    rv = 0.0,       #Virtual resistance in pu\n    lv = 0.2,       #Virtual inductance in pu\n    kpc = 1.27,     #Current controller proportional gain\n    kic = 14.3,     #Current controller integral gain\n    kffi = 0.0,     #Binary variable enabling the current feed-forward in output of current controllers\n    ωad = 50.0,     #Active damping low pass filter cut-off frequency\n    kad = 0.2,      #Active damping gain\n)\n\n#Define DC Source as a FixedSource:\ndc_source_lv() = FixedDCSource(voltage = 600.0)\n\n#Define a Frequency Estimator as a PLL\n#based on Vikram Kaura and Vladimir Blaskoc 1997 paper:\npll() = KauraPLL(\n    ω_lp = 500.0, #Cut-off frequency for LowPass filter of PLL filter.\n    kp_pll = 0.084,  #PLL proportional gain\n    ki_pll = 4.69,   #PLL integral gain\n)\n\n#Define an LCL filter:\nfilt() = LCLFilter(lf = 0.08, rf = 0.003, cf = 0.074, lg = 0.2, rg = 0.01)","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"We will construct the inverter later by specifying to which static device is assigned.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Dynamic-Generator-definition","page":"Create Dynamic Data","title":"Dynamic Generator definition","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Similarly we will construct a dynamic generator as follows:","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"# Create the machine\nmachine_oneDoneQ() = OneDOneQMachine(\n    0.0, #R\n    1.3125, #Xd\n    1.2578, #Xq\n    0.1813, #Xd_p\n    0.25, #Xq_p\n    5.89, #Td0_p\n    0.6, #Tq0_p\n)\n\n# Shaft\nshaft_no_damping() = SingleMass(\n    3.01, #H (M = 6.02 -> H = M/2)\n    0.0, #D\n)\n\n# AVR: Type I: Resembles a DC1 AVR\navr_type1() = AVRTypeI(\n    20.0, #Ka - Gain\n    0.01, #Ke\n    0.063, #Kf\n    0.2, #Ta\n    0.314, #Te\n    0.35, #Tf\n    0.001, #Tr\n    (min = -5.0, max = 5.0),\n    0.0039, #Ae - 1st ceiling coefficient\n    1.555, #Be - 2nd ceiling coefficient\n)\n\n#No TG\ntg_none() = TGFixed(1.0) #efficiency\n\n#No PSS\npss_none() = PSSFixed(0.0) #Vs","category":"page"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"Now we will construct the dynamic generator and inverter.","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Add-the-components-to-the-system","page":"Create Dynamic Data","title":"Add the components to the system","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"for g in get_components(Generator, threebus_sys)\n    #Find the generator at bus 102\n    if get_number(get_bus(g)) == 102\n        #Create the dynamic generator\n        case_gen = DynamicGenerator(\n            get_name(g),\n            1.0, # ω_ref,\n            machine_oneDoneQ(), #machine\n            shaft_no_damping(), #shaft\n            avr_type1(), #avr\n            tg_none(), #tg\n            pss_none(), #pss\n        )\n        #Attach the dynamic generator to the system by\n        # specifying the dynamic and static components\n        add_component!(threebus_sys, case_gen, g)\n        #Find the generator at bus 103\n    elseif get_number(get_bus(g)) == 103\n        #Create the dynamic inverter\n        case_inv = DynamicInverter(\n            get_name(g),\n            1.0, # ω_ref,\n            converter_high_power(), #converter\n            outer_control(), #outer control\n            inner_control(), #inner control voltage source\n            dc_source_lv(), #dc source\n            pll(), #pll\n            filt(), #filter\n        )\n        #Attach the dynamic inverter to the system\n        add_component!(threebus_sys, case_inv, g)\n    end\nend","category":"page"},{"location":"tutorials/tutorial_dynamic_data/#Save-the-system-in-a-JSON-file","page":"Create Dynamic Data","title":"Save the system in a JSON file","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_data/","page":"Create Dynamic Data","title":"Create Dynamic Data","text":"file_dir = @__DIR__ #hide\nto_json(threebus_sys, joinpath(file_dir, \"threebus_sys.json\"), force = true)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Line-Modeling-Simulations","page":"Dynamic Lines Simulation","title":"Line Modeling Simulations","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"Originally Contributed by: Rodrigo Henriquez-Auba and José Daniel Lara","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Introduction","page":"Dynamic Lines Simulation","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"This tutorial will introduce an example of considering dynamic lines in PowerSimulationsDynamics.","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"This tutorial presents a simulation of a three-bus system, with an infinite bus (represented as a voltage source behind an impedance) at bus 1, a one d- one q- machine on bus 2 and an inverter of 19 states, as a virtual synchronous machine at bus 3. The perturbation will be the trip of two of the three circuits (triplicating its resistance and impedance) of the line that connects bus 1 and bus 3. This case also consider a dynamic line model for connection between buses 2 and 3. We will compare it against a system without dynamic lines.","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"It is recommended to check the OMIB tutorial first, since that includes more details and explanations on all definitions and functions.","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-1:-Package-Initialization","page":"Dynamic Lines Simulation","title":"Step 1: Package Initialization","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"using PowerSimulationsDynamics\nusing PowerSystems\nusing PowerNetworkMatrices\nusing PowerSystemCaseBuilder\nusing Sundials\nusing Plots","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-2:-Data-creation","page":"Dynamic Lines Simulation","title":"Step 2: Data creation","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"Load the system using PowerSystemCaseBuilder.jl:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"threebus_sys = build_system(PSIDSystems, \"Three Bus Dynamic data Example System\")","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"In addition, we will create a new copy of the system on which we will simulate the same case, but will consider dynamic lines:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"threebus_sys_dyn = deepcopy(threebus_sys);","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-3:-Create-the-fault-and-simulation-on-the-Static-Lines-system","page":"Dynamic Lines Simulation","title":"Step 3: Create the fault and simulation on the Static Lines system","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"First, we construct the perturbation, by properly computing the new Ybus on the system:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"#Make a copy of the original system\nsys2 = deepcopy(threebus_sys)\n#Triplicates the impedance of the line named \"BUS 1-BUS 3-i_1\"\nfault_branches = get_components(ACBranch, sys2)\nfor br in fault_branches\n    if get_name(br) == \"BUS 1-BUS 3-i_1\"\n        br.r = 3 * br.r\n        br.x = 3 * br.x\n        b_new = (from = br.b.from / 3, to = br.b.to / 3)\n        br.b = b_new\n    end\nend\n#Obtain the new Ybus\nYbus_fault = Ybus(sys2).data\n#Define Fault: Change of YBus\nYbus_change = NetworkSwitch(\n    1.0, #change at t = 1.0\n    Ybus_fault, #New YBus\n);","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"Now, we construct the simulation:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"#Time span of our simulation\ntspan = (0.0, 30.0)\n\n#Define Simulation\nsim = Simulation(\n    ResidualModel, #Type of model used\n    threebus_sys, #system\n    pwd(), #folder to output results\n    tspan, #time span\n    Ybus_change, #Type of perturbation\n)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"We can obtain the initial conditions as:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"#Print the initial states. It also give the symbols used to describe those states.\nshow_states_initial_value(sim)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-4:-Run-the-simulation-of-the-Static-Lines-System","page":"Dynamic Lines Simulation","title":"Step 4: Run the simulation of the Static Lines System","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"#Run the simulation\nexecute!(\n    sim, #simulation structure\n    IDA(), #Sundials DAE Solver\n    dtmax = 0.02, #Maximum step size\n)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-5:-Store-the-solution","page":"Dynamic Lines Simulation","title":"Step 5: Store the solution","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"results = read_results(sim)\nseries2 = get_voltage_magnitude_series(results, 102)\nzoom = [\n    (series2[1][ix], series2[2][ix]) for\n    (ix, s) in enumerate(series2[1]) if (s > 0.90 && s < 1.6)\n];","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-3.1:-Create-the-fault-and-simulation-on-the-Dynamic-Lines-system","page":"Dynamic Lines Simulation","title":"Step 3.1: Create the fault and simulation on the Dynamic Lines system","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"An important aspect to consider is that DynamicLines must not be considered in the computation of the Ybus. First we construct the Dynamic Line, by finding the Line named \"BUS 2-BUS 3-i_1\", and then adding it to the system.","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"# get component return the Branch on threebus_sys_dyn named \"BUS 2-BUS 3-i_1\"\ndyn_branch = DynamicBranch(get_component(Line, threebus_sys_dyn,\"BUS 2-BUS 3-i_1\"))\n# Adding a dynamic line will immediately remove the static line from the system.\nadd_component!(threebus_sys_dyn, dyn_branch)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"Similarly, we construct the Ybus fault by creating a copy of the original system, but removing the Line \"BUS 2-BUS 3-i_1\" to avoid considering it in the Ybus:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"#Make a copy of the original system\nsys3 = deepcopy(threebus_sys);\n#Remove Line \"BUS 2-BUS 3-i_1\"\nremove_component!(Line, sys3, \"BUS 2-BUS 3-i_1\")\n#Triplicates the impedance of the line named \"BUS 1-BUS 2-i_1\"\nfault_branches2 = get_components(Line, sys3)\nfor br in fault_branches2\n    if get_name(br) == \"BUS 1-BUS 3-i_1\"\n        br.r = 3 * br.r\n        br.x = 3 * br.x\n        b_new = (from = br.b.from / 3, to = br.b.to / 3)\n        br.b = b_new\n    end\nend\n#Obtain the new Ybus\nYbus_fault_dyn = Ybus(sys3).data\n#Define Fault: Change of YBus\nYbus_change_dyn = NetworkSwitch(\n    1.0, #change at t = 1.0\n    Ybus_fault_dyn, #New YBus\n)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-4.1:-Run-the-simulation-of-the-Dynamic-Lines-System","page":"Dynamic Lines Simulation","title":"Step 4.1: Run the simulation of the Dynamic Lines System","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"Now, we construct the simulation:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"# Define Simulation\nsim_dyn = Simulation(\n    ResidualModel, #Type of model used\n    threebus_sys_dyn, #system\n    pwd(), #folder to output results\n    (0.0, 30.0), #time span\n    Ybus_change_dyn, #Type of perturbation\n)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"# Run the simulation\nexecute!(\n    sim_dyn, #simulation structure\n    IDA(), #Sundials DAE Solver\n    dtmax = 0.02, #Maximum step size\n)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"We can obtain the initial conditions as:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"#Print the initial states. It also give the symbols used to describe those states.\nshow_states_initial_value(sim_dyn)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-5.1:-Store-the-solution","page":"Dynamic Lines Simulation","title":"Step 5.1: Store the solution","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"results_dyn = read_results(sim_dyn)\nseries2_dyn = get_voltage_magnitude_series(results_dyn, 102);\nzoom_dyn = [\n    (series2_dyn[1][ix], series2_dyn[2][ix]) for\n    (ix, s) in enumerate(series2_dyn[1]) if (s > 0.90 && s < 1.6)\n];","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/#Step-6.1:-Compare-the-solutions:","page":"Dynamic Lines Simulation","title":"Step 6.1: Compare the solutions:","text":"","category":"section"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"We can observe the effect of Dynamic Lines","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"plot(series2_dyn, label = \"V_gen_dyn\");\nplot!(series2, label = \"V_gen_st\", xlabel = \"Time [s]\", ylabel = \"Voltage [pu]\");","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"that looks quite similar. The differences can be observed in the zoom plot:","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"plot(zoom_dyn, label = \"V_gen_dyn\");\nplot!(zoom, label = \"V_gen_st\", xlabel = \"Time [s]\", ylabel = \"Voltage [pu]\");","category":"page"},{"location":"tutorials/tutorial_dynamic_lines/","page":"Dynamic Lines Simulation","title":"Dynamic Lines Simulation","text":"(Image: plot)","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Simulation-Models","page":"Models","title":"Simulation Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PowerSimulations dynamics supports two formulations for the simulation model and define different methods for each simulation model. You can pass ResidualModel or MassMatrixModel to a call to Simulation to define the preferred formulation.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"In this way, we provide a common set of development requirements for contributors of new models that maintains the same flexibility in choosing the solving algorithm.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"MassMatrixModel: Defines models that can be solved using Mass-Matrix Solvers. The model is formulated as follows:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nMfracdx(t)dt = f(x(t))\nendalign","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At this stage we have not conducted extensive tests with all the solvers in DifferentialEquations most of our tests use Rodas5().","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"ResidualModel: Define models that can be solved using Implicit ODE solvers and also the solver IDA from Sundials. The model is formulated to solved the following problem:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nr(t) = fracdx(t)dt - f(x(t))\nendalign","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"At this stage we have not conducted extensive tests with all the solvers in DifferentialEquations if you are solving a larger system use IDA().","category":"page"},{"location":"models/#The-dynamic-system-model-in-PowerSimulationsDynamics","page":"Models","title":"The dynamic system model in PowerSimulationsDynamics","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"In order to support both formulations, the default implementation of the ResidualModel solves the following problem:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"beginalign\nr(t) = Mfracdx(t)dt - f(x(t))\nendalign","category":"page"},{"location":"models/#Solution-approaches","page":"Models","title":"Solution approaches","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"PowerSimulationsDynamics.jl construct the entire function that is passed to DifferentialEquations to solve it using different solvers. This is called the Simultaneous-solution approach to numerically integrate over time. It gives the user the flexibility to model devices with a combination of differential and algebraic states. In addition, it gives the flexibility to model the network using an algebraic or differential model.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"On the other hand, industrial tools such as PSS/E uses a Partitioned-solution approach, on which the network must be modeled using an algebraic approach, and the differential equations and algebraic equations are solved sequentially. This method is usually faster if the heuristics for convergence when solving sequentially are properly tuned. However, boundary techniques must be considered when the connection with the devices and network is not converging when applying the partitioned-solution approach.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The difference in solution methods can complicate the validation and comparison between software tools. In addition it can affect the computational properties due to reliance of heuristics. These solution aspects are important to consider when using different tools for simulating power systems dynamics.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"For more details, check Brian Stott paper \"Power system dynamic response calculations\".","category":"page"},{"location":"models/#Generator-Models","page":"Models","title":"Generator Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model generators in PowerSimulationsDynamics.jl. See PowerSystems.jl dynamic devices for details.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Each generator is a data structure composed of the following components defined in PowerSystems.jl:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Machine: That defines the stator electro-magnetic dynamics.\nShaft: That describes the rotor electro-mechanical dynamics.\nAutomatic Voltage Regulator: Electromotive dynamics to model an AVR controller.\nPower System Stabilizer: Control dynamics to define an stabilization signal for the AVR.\nPrime Mover and Turbine Governor: Thermo-mechanical dynamics and associated controllers.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The implementation of Synchronous generators as components uses the following structure to share values across components.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://github.com/nrel-sienna/PowerSystems.jl/blob/master/docs/src/assets/gen_metamodel.png?raw=true\" width=\"75%\">","category":"page"},{"location":"models/#Inverter-Models","page":"Models","title":"Inverter Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we discuss the structure and models used to model inverters in PowerSimulationsDynamics.jl. See PowerSystems.jl dynamic devices for details. One of the key contributions in this software package is a separation of the components in a way that resembles current practices for synchronoues machine modeling.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"DC Source: Defines the dynamics of the DC side of the converter.\nFrequency Estimator: That describes how the frequency of the grid can be estimated using the grid voltages. Typically a phase-locked loop (PLL).\nOuter Loop Control: That describes the active and reactive power control dynamics.\nInner Loop Control: That can describe virtual impedance, voltage control and current control dynamics.\nConverter: That describes the dynamics of the pulse width modulation (PWM) or space vector modulation (SVM).\nFilter: Used to connect the converter output to the grid.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The following figure summarizes the components of a inverter and which variables they share:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://github.com/nrel-sienna/PowerSystems.jl/blob/master/docs/src/assets/inv_metamodel.png?raw=true\" width=\"75%\">","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Contrary to the generator, there are many control structures that can be used to model inverter controllers (e.g. grid-following, grid feeding or virtual synchronous machine). For this purpose, more variables are shared among the components in order to cover all these posibilities.","category":"page"},{"location":"models/#Reference","page":"Models","title":"Reference","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"For models, check the library in PowerSystems.jl","category":"page"},{"location":"component_models/avr/#Automatic-Voltage-Regulators-(AVR)","page":"AVR","title":"Automatic Voltage Regulators (AVR)","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"AVR are used to determine the voltage in the field winding v_f (or V_f) in the model.","category":"page"},{"location":"component_models/avr/#Fixed-AVR-[AVRFixed]","page":"AVR","title":"Fixed AVR [AVRFixed]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This is a simple model that set the field voltage to be equal to a desired constant value v_f = v_textfix.","category":"page"},{"location":"component_models/avr/#Simple-AVR-[AVRSimple]","page":"AVR","title":"Simple AVR [AVRSimple]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This depicts the most basic AVR, on which the field voltage is an integrator over the difference of the measured voltage and a reference:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = K_v(v_textref - v_h) tag1a\nendalign","category":"page"},{"location":"component_models/avr/#AVR-Type-I-[AVRTypeI]","page":"AVR","title":"AVR Type I [AVRTypeI]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This AVR is a simplified version of the IEEE DC1 AVR model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(K_e + S_e(v_f))-v_r1 right tag2a \ndotv_r1 = frac1T_a left K_aleft(v_textref - v_m - v_r2 - fracK_fT_fv_fright) - v_r1 right   tag2b \ndotv_r2 =  -frac1T_f left fracK_fT_fv_f + v_r2 right  tag2c \ndotv_m = frac1T_r (v_h - v_m) tag2d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with the ceiling function:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#AVR-Type-II-[AVRTypeII]","page":"AVR","title":"AVR Type II [AVRTypeII]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"This model represents a static exciter with higher gains and faster response than the Type I:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotv_f = -frac1T_e left V_f(1 + S_e(v_f))-v_r right tag3a \ndotv_r1 = frac1T_1 left K_0left(1 - fracT_2T_1 right)(v_textref - v_m) - v_r1  right tag3b \ndotv_r2 =  frac1K_0 T_3 left left( 1 - fracT_4T_3 right) left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) - K_0 v_r2 right  tag3c \ndotv_m = frac1T_r (v_h - v_m) tag3d\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nv_r = K_0v_r2 + fracT_4T_3 left( v_r1 + K_0fracT_2T_1(v_textref - v_m)right) \nS_e(v_f) = A_e exp(B_ev_f)\nendalign*","category":"page"},{"location":"component_models/avr/#Excitation-System-AC1A-[ESAC1A]","page":"AVR","title":"Excitation System AC1A [ESAC1A]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 5-states IEEE Type AC1A Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag4a \ndotV_r1 = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_r1right) tag4b \ndotV_r2 = frac1T_a (K_a V_out - V_r2) tag4c \ndotV_e = frac1T_e (V_r - V_FE) tag4d \ndotV_r3 = frac1T_f left( - fracK_fT_fV_FE - V_r3 right) tag4e \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nI_N = fracK_cV_e X_adI_fd \nV_FE = K_d X_adI_fd + K_e V_e + S_e V_e \nS_e = Bfrac(V_e-A)^2V_e \nV_F1 = V_r3 + fracK_fT_f V_FE \nV_in = V_ref - V_m - V_F1 \nV_out = V_r1 + fracT_cT_b V_in \nV_f = V_e f(I_N) \nf(I_N) = leftbeginarraycl\n    1  text if I_N le 0 \n    1 - 0577 I_N  text if  0  I_N le 0433 \n    sqrt075 - I_N^2  text if  0433  I_N le 075 \n    1732(1-I_N)  text if  075   I_N le 1 \n    0  text if  I_N  1 endarray right\nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which X_adI_fd is the field current coming from the generator and V_h is the terminal voltage, and AB are the saturation coefficients computed using the E_1 E_2 S_e(E_1) S_e(E_2) data.","category":"page"},{"location":"component_models/avr/#Simplified-Excitation-System-[SEXS]","page":"AVR","title":"Simplified Excitation System [SEXS]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model for the 2 states excitation system SEXS:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_f = frac1T_e (V_LL - V_f) tag5a \ndotV_r = frac1T_b leftleft(1 - fracT_aT_bright) V_in - V_r right tag5b\nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nV_in = V_ref + V_s - V_h \nV_LL = V_r + fracT_aT_bV_in \nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which V_h is the terminal voltage and V_s is the PSS output signal.","category":"page"},{"location":"component_models/avr/#Excitation-System-ST1-[EXST1]","page":"AVR","title":"Excitation System ST1 [EXST1]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 4-states IEEE Type ST1 Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag6a \ndotV_rll = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_rllright) tag6b \ndotV_r = frac1T_a (V_LL - V_r) tag6c \ndotV_fb = frac1T_f left( - fracK_fT_fV_r - V_fb right) tag6d \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with ","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nV_in = V_ref - V_m - y_hp \nV_LL = V_r + fracT_cT_b V_in \ny_hp = V_fb + fracK_fT_f V_r \nV_f = V_r \nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which V_h is the terminal voltage.","category":"page"},{"location":"component_models/avr/#Excitation-System-EXAC1-[EXAC1]","page":"AVR","title":"Excitation System EXAC1 [EXAC1]","text":"","category":"section"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"The model represents the 5-states IEEE Type EXAC1 Excitation System Model:","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign\ndotV_m = frac1T_r (V_h - V_m) tag7a \ndotV_r1 = frac1T_b left(V_in left(1 - fracT_cT_bright) - V_r1right) tag7b \ndotV_r2 = frac1T_a (K_a V_out - V_r2) tag7c \ndotV_e = frac1T_e (V_r - V_FE) tag7d \ndotV_r3 = frac1T_f left( - fracK_fT_fV_FE - V_r3 right) tag7e \nendalign","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"with","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"beginalign*\nI_N = fracK_cV_e X_adI_fd \nV_FE = K_d X_adI_fd + K_e V_e + S_e V_e \nS_e = Bfrac(V_e-A)^2V_e \nV_F1 = V_r3 + fracK_fT_f V_FE \nV_in = V_ref - V_m - V_F1 \nV_out = V_r1 + fracT_cT_b V_in \nV_f = V_e f(I_N) \nf(I_N) = leftbeginarraycl\n    1  text if I_N le 0 \n    1 - 0577 I_N  text if  0  I_N le 0433 \n    sqrt075 - I_N^2  text if  0433  I_N le 075 \n    1732(1-I_N)  text if  075   I_N le 1 \n    0  text if  I_N  1 endarray right\nendalign*","category":"page"},{"location":"component_models/avr/","page":"AVR","title":"AVR","text":"on which X_adI_fd is the field current coming from the generator and V_h is the terminal voltage, and AB are the saturation coefficients computed using the E_1 E_2 S_e(E_1) S_e(E_2) data.","category":"page"},{"location":"component_models/outer_control/#Outer-Loop-Controls","page":"Outer Control","title":"Outer Loop Controls","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This component defines controllers for both active and reactive power. The joint design is based on the fact that many novel control techniques can be based on joint control of active and reactive power.","category":"page"},{"location":"component_models/outer_control/#Virtual-Inertia-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Virtual Inertia and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a virtual synchronous machine model to represent how active power is going to be deployed. The constructor is OuterControl{VirtualInertia, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotomega_textolc = fracp_textrefT_a - fracp_eT_a - frack_d(omega_textolc - omega_textpll)T_a - frack_omega(omega_textolc - omega_textref)T_a tag1a \n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag1b \n    dotq_m = omega_f (q_e - q_m) tag1c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag1d \n    q_e = v_ii_r - v_ri_i tag1e \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag1f\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/outer_control/#Active-Power-Droop-(P-droop)-and-Q-droop-[OuterControl]","page":"Outer Control","title":"Active Power Droop (P-droop) and Q-droop [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represent a Ptext-f droop model to represent how active power is going to be deployed. The constructor is OuterControl{ActivePowerControl, ReactivePowerDroop}. It defines a new SRF denoted as theta_textolc for the active power controller and uses a simple voltage droop for dispatching reactive power. Both active and reactive power are measured via a low-pass filter:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag2a \n    dotp_m = omega_z (p_e - p_m) tag2b \n    dotq_m = omega_f (q_e - q_m) tag2c\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag2d \n    q_e = v_ii_r - v_ri_i tag2e \n    omega_textolc = omega_textref + R_p (p_textref - p_m) tag2f \n    v_textolc^textref = v_textref + k_q(q_textref - q_m) tag2g\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In this case, the measurement of power are being done in the capacitor of the LCL filter. However, depending on the model, this measurements could be different depending on where is the point of common coupling.","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Virtual-Oscillator-Controllers-[OuterControl]","page":"Outer Control","title":"Active and Reactive Virtual Oscillator Controllers [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents a Virtual Oscillator Controller for both active and reactive power to generate the voltage references that will be used in the Voltage Controller. The contructor is OuterControl{ActiveVirtualOscillator, ReactiveVirtualOscillator} It defines a new SRF denoted as theta_textolc and a voltage reference E_textolc. The equations are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dottheta_textolc = Omega_b (omega_textolc - omega_textsys) tag3a \n    dotE_olc = Omega_b left(frack_1E_oc (-sin(gamma) (p_textref - p_e) + cos(gamma)(q_textref - q_e)) + k_2 (V_textref - E_oc^2)E_oc right) tag3b \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    gamma = psi - fracpi2 tag3c \n    omega_textolc =  omega_textsys + frack_1E_oc^2 left(cos(gamma) (p_textref - p_e) + sin(gamma)(q_textref - q_e) right) tag3d \n    p_e = v_ri_r + v_ii_i tag3e \n    q_e = v_ii_r - v_ri_i tag3f \nendalign","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Power-PI-Controllers-(Grid-Following)-[OuterControl]","page":"Outer Control","title":"Active and Reactive Power PI Controllers (Grid Following) [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents a PI controller for both active and reactive power to generate the current references that will be used in the Current Controller of the inner control CurrentModeControl. The constructor is OuterControl{ActivePowerPI, ReactivePowerPI}. The equations are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotsigma_p = p_textref - p_m tag4a \n    dotp_m = omega_z (p_e - p_m) tag4b \n    dotsigma_q = q_textref - q_m tag4c \n    dotq_m = omega_f (q_e - p_m) tag4d \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag4e \n    q_e = v_ii_r - v_ri_i tag4f \n    omega_textolc = omega_textpll tag4g \n    theta_textolc = theta_textpll tag4h \n    i_textdcv^textref = k_p^q (q_textref - q_m) + k_i^q sigma_q tag4i \n    i_textqcv^textref = k_p^p (p_textref - p_m) + k_i^p sigma_p tag4j \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"This models requires a PLL to have a SRF for an internal dq reference frame. Contrary to the Grid-Forming model, it cannot work without a PLL. Since this Outer Control outputs a current reference, it can only be used with a current mode inner control (i.e. that receives  a current reference instead of a voltage reference).","category":"page"},{"location":"component_models/outer_control/#Active-and-Reactive-Generic-Renewable-Controller-Type-AB-[OuterControl]","page":"Outer Control","title":"Active and Reactive Generic Renewable Controller Type AB [OuterControl]","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The following model represents an outer controller for both active and reactive power from generic industrial models REPCA and REECB to generate the current references that will be used in the Current Controller of the inner control RECurrentControlB. The constructor is OuterControl{ActiveRenewableControllerAB, ReactiveRenewableControllerAB}. The equations will depend on the flags used.","category":"page"},{"location":"component_models/outer_control/#Active-part","page":"Outer Control","title":"Active part","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of F_Flag = 1 the equations (without limits and freezing) are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotp_textflt = frac1T_p (p_e - p_textflt) tag5a \n    dotxi_P = p_texterr tag5b \n    dotp_textext = frac1T_g (K_pg p_texterr + K_ig xi_P) tag5c \n    dotp_textord = frac1T_textpord (p_textext - p_textord) tag5d\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    p_e = v_ri_r + v_ii_i tag5e \n    p_texterr = p_textref + p_textdroop - p_textflt tag5f \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of F_Flag = 0 the equations (without limits) are simply","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotp_textord = frac1T_textpord (p_textref - p_textord) tag5g\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The current command going to the Inner Loop is computed as:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    I_textocpcmd = fracp_textordV_texttflt tag5h\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"on which V_texttflt is the filtered terminal bus voltage coming from the inner controller.","category":"page"},{"location":"component_models/outer_control/#Reactive-part","page":"Outer Control","title":"Reactive part","text":"","category":"section"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of VC_Flag = 0, Ref_Flag = 0, PF_Flag = 0, V_Flag = 1 the equations (without limits and freezing) are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotq_textflt = frac1T_textfltr (q_e - q_textflt) tag5i \n    dotxi_textqoc = q_texterr tag5j \n    dotq_LL = frac1T_fv(Q_textpi ( 1 - T_ftT_fv) - q_LL) tag5k \n    dotxi_Q = V_textpiin tag5l \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"with","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    q_e = v_ii_r - v_ri_i tag5m \n    q_texterr = q_textref - q_flt tag5n \n    Q_textpi = K_p q_texterr + K_i xi_textqoc tag5o \n    Q_textext = q_LL + fracT_ftT_fv Q_textpi tag5p \n    V_textpiin = Q_textext - q_e tag5q \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The output to the inner controller are V_textocqcmd if the Q_Flag = 1 on the Inner Controller, or I_textocqcmd if Q_Flag = 0:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    V_textocqcmd = (K_qp V_textpiin + K_qi xi_Q) - V_texttflt tag5r \n    I_textocqmcd = fracQ_textextmax(V_texttflt 001) tag5s\nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"In the case of VC_Flag = 0, Ref_Flag = 0, PF_Flag = 0, V_Flag = 1 the equations (without limits and freezing) are:","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"beginalign\n    dotq_textflt = frac1T_textfltr (q_e - q_textflt) tag5t \n    dotxi_textqoc = q_texterr tag5u \n    dotq_LL = frac1T_fv(Q_textpi ( 1 - T_ftT_fv) - q_LL) tag5v \nendalign","category":"page"},{"location":"component_models/outer_control/","page":"Outer Control","title":"Outer Control","text":"The remaining models for other flags will be included when implemented in PowerSimulationsDynamics.jl.","category":"page"},{"location":"perturbations/#Perturbations","page":"Perturbations","title":"Perturbations","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Perturbations are used to alter the system from its steady state operation. If a Simulation is properly initialized, all states will remain fixed in their initial condition if no perturbation is applied to the system.","category":"page"},{"location":"perturbations/#List-of-perturbations","page":"Perturbations","title":"List of perturbations","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"NetworkSwitch: allows to modify directly the admittance matrix, Ybus, used in the Simulation.\nBranchTrip: completely disconnects a branch from the system.\nBranchImpedanceChange: change the impedance of a branch by a user defined multiplier. \nGeneratorTrip: allows to disconnect a Dynamic Generation unit from the system.\nControlReferenceChange: allows to change the reference setpoint provided by a generator/inverter.\nLoadChange: allows to change the active or reactive power setpoint from a load.\nLoadTrip: allows the user to disconnect a load from the system.\nSourceBusVoltageChange: allows to change the reference setpoint provided by a voltage source.","category":"page"},{"location":"perturbations/#Examples","page":"Perturbations","title":"Examples","text":"","category":"section"},{"location":"perturbations/#Example-1:-Circuit-Disconnection-using-NetworkSwitch","page":"Perturbations","title":"Example 1: Circuit Disconnection using NetworkSwitch","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider a two bus system connected via a double circuit line, on which each circuit has parameters, r = 0.0, x = 0.1, b = 0.0 per unit, then the admittance matrix of the original system is given by:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"yb = [0.0 - 20.0im 0.0 + 20.0im\n      0.0 + 20.0im 0.0 - 20.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Triping one circuit can be modeled by doubling the impedance, i.e., dividing by 2 the admittance:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb = [0.0 - 10.0im 0.0 + 10.0im\n          0.0 + 10.0im 0.0 - 10.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"To apply a Network Switch, we require to use a sparse matrix, so we can do this by simply:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"using SparseArrays\nnew_yb = sparse(new_yb)","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Then, this perturbation ocurring at t = 10 seconds can be included as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"ns1 = NetworkSwitch(1.0, new_yb)","category":"page"},{"location":"perturbations/#Example-2:-Three-Phase-Fault-using-NetworkSwitch","page":"Perturbations","title":"Example 2: Three Phase Fault using NetworkSwitch","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Another perturbation that can be modeled is a three phase fault at Bus 1 with impedance r_f = 0.0001, x_f = 0.0 per unit, then the admittance of this new system is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb2 = [10000.0 - 20.0im  0.0 + 20.0im\n           0.0 + 20.0im  0.0 - 20.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Then, this perturbation ocurring at t = 10 seconds can be included as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb2 = sparse(new_yb2)\nns2 = NetworkSwitch(1.0, new_yb2)","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Now, consider that the fault is cleared at t = 105 seconds by disconnecting the Circuit 2 of the line. This can be modeled with the single circuit admittance matrix:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb3 = [0.0 - 10.0im 0.0 + 10.0im\n           0.0 + 10.0im 0.0 - 10.0im]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"and the perturbation as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"new_yb3 = sparse(new_yb3)\nns3 = NetworkSwitch(1.05, new_yb3)","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Then, the entire perturbation for the Simulation can be included in a vector of perturbations as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"three_fault = [ns2, ns3]","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"that can be passed as a perturbation argument in the Simulation construction.","category":"page"},{"location":"perturbations/#Example-3:-BranchTrip","page":"Perturbations","title":"Example 3: BranchTrip","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider the following 2 bus system defined by:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"buses = [\n    Bus(1, \"nodeA\", \"REF\", 0, 1.0, (min = 0.9, max = 1.05), 230, nothing, nothing),\n    Bus(2, \"nodeB\", \"PV\", 0, 1.0, (min = 0.9, max = 1.05), 230, nothing, nothing),\n]\n\nline1 = Line(\n        \"Circuit1\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = buses[1], to = buses[2]),\n        0.00,\n        0.1,\n        (from = 0.0, to = 0.0),\n        2.0,\n        (min = -0.7, max = 0.7),\n    )\nline2 = Line(\n        \"Circuit2\",\n        true,\n        0.0,\n        0.0,\n        Arc(from = buses[1], to = buses[2]),\n        0.0,\n        0.1,\n        (from = 0.0, to = 0.0),\n        2.0,\n        (min = -0.7, max = 0.7),\n    )\n\nsys = System(100.0, buses, [], [], [line1, line2])","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"A Branch Trip of Circuit 2 at time t = 10 seconds, can be implemented as:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"b_trip = BranchTrip(1.0, Line, \"Circuit2\")","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Note: Islanding is currently not supported in PowerSimulationsDynamics.jl. If a BranchTrip isolates a generation unit, the system may diverge due to the isolated generator.","category":"page"},{"location":"perturbations/#Example-4:-BranchImpedanceChange","page":"Perturbations","title":"Example 4: BranchImpedanceChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Following the same example as before, it is possible to amplify the impedance of a single circuit by 2.0 (that would represent that this Circuit is actually composed by 2 circuits) using the following perturbation:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"b_change = BranchImpedanceChange(1.0, Line, \"Circuit2\", 2.0)","category":"page"},{"location":"perturbations/#Example-5:-GeneratorTrip","page":"Perturbations","title":"Example 5: GeneratorTrip","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a generator at bus 102, named \"generator-102-1\" in your system called sys. The constructor to trip it from the system is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"g = get_component(DynamicGenerator, sys, \"generator-102-1\")\ng_trip = GeneratorTrip(1.0, g)","category":"page"},{"location":"perturbations/#Example-6:-ControlReferenceChange","page":"Perturbations","title":"Example 6: ControlReferenceChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a generator at bus 102, named \"generator-102-1\" in your system called sys. The constructor to change is active power reference to 0.5 is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"g = get_component(DynamicGenerator, sys, \"generator-102-1\")\ncrc = ControlReferenceChange(1.0, g, :P_ref, 0.5)","category":"page"},{"location":"perturbations/#Example-7:-LoadChange","page":"Perturbations","title":"Example 7: LoadChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a load at bus 103, named \"load-103-1\" in your system called sys. The constructor to change is active power reference to 0.8 per unit at t = 10 seconds is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"l_device = get_component(ElectricLoad, sys, \"load-103-1\")\nl_change = LoadChange(1.0, l_device, :P_ref, 0.8)","category":"page"},{"location":"perturbations/#Example-8:-LoadTrip","page":"Perturbations","title":"Example 8: LoadTrip","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a load at bus 103, named \"load-103-1\" in your system called sys. The constructor to disconnect such load at t = 10 seconds is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"l_device = get_component(ElectricLoad, sys, \"load-103-1\")\nl_trip = LoadTrip(1.0, l_device)","category":"page"},{"location":"perturbations/#Example-9:-SourceBusVoltageChange","page":"Perturbations","title":"Example 9: SourceBusVoltageChange","text":"","category":"section"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"Consider that you have a voltage source at bus 101, named \"source-101-1\" in your system called sys. The constructor to change is voltage magnitude reference to 1.02 per unit at t = 10 seconds is:","category":"page"},{"location":"perturbations/","page":"Perturbations","title":"Perturbations","text":"s_device = get_component(Source, sys, \"source-101-1\")\ns_change = SourceBusVoltageChange(1.0, s_device, 1, 1.02)","category":"page"},{"location":"component_models/machines/#Machines","page":"Machine","title":"Machines","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The machine component describes the stator-rotor electromagnetic dynamics.","category":"page"},{"location":"component_models/machines/#Classical-Model-(Zero-Order)-[BaseMachine]","page":"Machine","title":"Classical Model (Zero Order) [BaseMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This is the classical order model that does not have differential equations in its machine model (delta and omega are defined in the shaft):","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_d  x_d  r_a endarray right^-1  left beginarrayc -v_d  e_q - v_q endarray right tag1a\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag1b\nendalign","category":"page"},{"location":"component_models/machines/#One-d-One-q-Model-(2nd-Order)-[OneDOneQMachine]","page":"Machine","title":"One d- One q- Model (2nd Order) [OneDOneQMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model includes two transient emf with their respective differential equations:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q + (x_d-x_d)i_d + v_fright tag2a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag2b\n  left beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag2c\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag2d\nendalign","category":"page"},{"location":"component_models/machines/#Marconato-Machine-(6th-Order)-[MarconatoMachine]","page":"Machine","title":"Marconato Machine (6th Order) [MarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Marconato model defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag3a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag3b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag3c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag3d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag3e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag3f \ni_d = frac1x_d (e_q - psi_d) tag3g \ni_q = frac1x_q (-e_d - psi_q) tag3h \ntau_e = psi_d i_q - psi_q i_d tag3i\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Simplified-Marconato-Machine-(4th-Order)-[SimpleMarconatoMachine]","page":"Machine","title":"Simplified Marconato Machine (4th Order) [SimpleMarconatoMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omegapsi_d=psi_d and omegapsi_q=psi_q) that allows to remove the stator fluxes variables from the Marconato model.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d-gamma_d)i_d + left(1- fracT_AAT_d0 right) v_fright tag4a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q-gamma_q)i_q right tag4b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d+gamma_d)i_d + fracT_AAT_d0v_f right tag4c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q+gamma_q)i_q right tag4d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag4e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag4f\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d = fracT_d0 x_dT_d0 x_d (x_d - x_d) \n  gamma_q = fracT_q0 x_qT_q0 x_q (x_q - x_q)\nendalign*","category":"page"},{"location":"component_models/machines/#Anderson-Fouad-Machine-(6th-Order)-[AndersonFouadMachine]","page":"Machine","title":"Anderson-Fouad Machine (6th Order) [AndersonFouadMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Anderson-Fouad model also defines 6 differential equations, two for stator fluxes and 4 for transient and subtransient emfs and is derived from the Marconato model by defining gamma_d approx gamma_q approx T_AA approx 0:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag5a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag5b \ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag5c\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag5d\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag5e \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag5f \ni_d = frac1x_d (e_q - psi_d) tag5g \ni_q = frac1x_q (-e_d - psi_q) tag5h \ntau_e = psi_d i_q - psi_q i_d tag5i\nendalign","category":"page"},{"location":"component_models/machines/#Simplified-Anderson-Fouad-Machine-(4th-Order)-[SimpleAFMachine]","page":"Machine","title":"Simplified Anderson-Fouad Machine (4th Order) [SimpleAFMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q) and assume that the rotor speed stays close to 1 pu (omega psi_d = psi_d and omega psi_q = psi_q) that allows to remove the stator fluxes variables from the model:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 left-e_q - (x_d-x_d)i_d + v_fright tag6a\ndote_d = frac1T_q0 left-e_d + (x_q-x_q)i_q right tag6b\ndote_q = frac1T_d0 left-e_q + e_q - (x_d-x_d)i_d right tag6c \ndote_d = frac1T_q0 left-e_d + e_d + (x_q-x_q)i_q right tag6d \nleft beginarrayc i_d  i_q endarray right = left beginarraycc r_a  -x_q  x_d  r_a endarray right^-1  left beginarrayc e_d-v_d  e_q - v_q endarray right tag6e\np_e approx tau_e = (v_q + r_a i_q)i_q + (v_d + r_ai_d)i_d tag6f\nendalign","category":"page"},{"location":"component_models/machines/#Round-Rotor-Machine-(4th-Order)-[RoundRotorQuadratic,-RoundRotorExponential]","page":"Machine","title":"Round Rotor Machine (4th Order) [RoundRotorQuadratic, RoundRotorExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENROU/GENROE models implemented in PSLF/PSSE/PowerWorld. Similar to the Simplified Marconato Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q). Round rotor machines must satisfy x_d = x_q.","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag7a\ndote_d = frac1T_q0 left-X_aqI_1q right tag7b\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag7c \ndotpsi_kq = frac1T_q0 left-psi_kq + e_d + (x_q-x_l)i_q right tag7d \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag7e\ngamma_q1 = fracx_q - x_lx_q - x_l tag7f\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag7g\ngamma_q2 = fracx_q - x_q(x_q - x_l)^2 tag7h\ngamma_qd = fracx_q - x_lx_d - x_l tag7i\npsi_q = gamma_q1 e_d + psi_kq (1 - gamma_q1) tag7j\npsi_d = gamma_d1 e_q + gamma_d2 (x_d - x_l) psi_kd tag7k\npsi = sqrt(psi_d)^2 + (psi_q)^2 tag7l\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag7m\nX_adI_fd = e_q + (x_d - x_d) (gamma_d1 i_d - gamma_d2 psi_kd + gamma_d2 + e_q) + textSe(psi) psi_d tag7n\nX_aqI_1q = e_d + (x_q - x_q) (gamma_q2 e_d - gamma_q2psi_kq - gamma_q1 i_q) + textSe(psi) psi_q gamma_qd tag7o \ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag7p\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENROU and GENROE occurs in which additive saturation function textSe(psi) is used. Input data is provided by the saturation values at psi = 10 and psi = 12 p.u. For the GENROU model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = fracB(psi - A)^2 psi tag7q\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENROE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(psi) = B(psi)^A tag7r\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/machines/#Salient-Pole-Machine-(3rd-Order)-[SalientPoleQuadratic,-SalientPoleExponential]","page":"Machine","title":"Salient Pole Machine (3rd Order) [SalientPoleQuadratic, SalientPoleExponential]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"This model represents the traditional round rotor models GENSAL/GENSAE models implemented in PSLF/PSSE/PowerWorld. Similar to the GENROU Model, this model neglects the derivative of stator fluxes (dotpsi_d and  dotpsi_q).","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndote_q = frac1T_d0 leftv_f - X_adI_fdright tag8a\ndotpsi_kd = frac1T_d0 left-psi_kd + e_q - (x_d-x_l)i_d right tag8b \ndotpsi_q = frac1T_q0 left-psi_q - (x_q-x_q)i_q right tag8c \nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ngamma_d1 = fracx_d - x_lx_d - x_l tag8d\ngamma_q1 = fracx_q - x_lx_q - x_l tag8e\ngamma_d2 = fracx_d - x_d(x_d-x_l)^2 tag8f\npsi_d = gamma_d1 e_q + gamma_q1 psi_kd tag8g\nleft beginarrayc i_d  i_q endarray right = left beginarraycc -r_a  x_q  -x_d  r_a endarray right^-1  left beginarrayc v_d - psi_q  -v_q + psi_d endarray right tag8h\nX_adI_fd = e_q + textSe(e_q) e_q + (x_d - x_d) (i_d + gamma_d2 (e_q - psi_kd - (x_d - x_l)i_d) tag8i\ntau_e = i_d (r_a i_d + v_d) + i_q(r_a i_q + v_q) tag8j\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The difference between GENSAL and GENSAE occurs in which additive saturation function textSe(e_q) is used. Input data is provided by the saturation values at e_q = 10 and e_q = 12 p.u. For the GENSAL model, the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(e_q) = fracB(e_q - A)^2 e_q tag8k\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"and for the GENSAE model the function used is:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ntextSe(e_q) = B(e_q)^A tag8l\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The parameters A and B for each function are computed using the two points given (10 textSe(10)) and (12 textSe(12)).","category":"page"},{"location":"component_models/machines/#SauerPai-Machine-(6th-Order)-[SauerPaiMachine]","page":"Machine","title":"SauerPai Machine (6th Order) [SauerPaiMachine]","text":"","category":"section"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"The Sauer Pai model defines 6 differential equations as follows:","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign\ndotpsi_d = Omega_b(r_ai_d + omega psi_q + v_d) tag9a \ndotpsi_q = Omega_b(r_ai_q - omega psi_d + v_q) tag9b \ndote_q = frac1T_d0 left(-e_q - (x_d - x_d)(i_d + gamma_d2 * dotpsi_d) + v_f) tag9c\ndote_q = frac1T_q0 left(-e_d + (x_q - x_q)(i_q + gamma_q2 * dotpsi_q)) tag9d\ndotpsi_d = frac1T_d0 left(-psi_d + e_q - (x_d - x_l)*i_d) tag9e \ndotpsi_q = frac1T_q0 left(-psi_q - e_d - (x_q - x_l)*i_q)  tag9f \ni_d = frac1x_d (gamma_d1 * e_q - psi_d + (1 - gamma_d1) * psi_d) tag9g \ni_q = frac1x_q ((-gamma_q1 * e_d - psi_q + (1 - gamma_q1) * psi_q) tag9h \ntau_e = psi_d i_q - psi_q i_d tag9i\nendalign","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"with","category":"page"},{"location":"component_models/machines/","page":"Machine","title":"Machine","text":"beginalign*\n  gamma_d1 = fracx_d - x_lx_d - x_l \n  gamma_q1 = fracx_q - x_lx_q - x_l \n  gamma_d2 = frac1 - gamma_d1x_d - x_l \n  gamma_q2 = frac1 - gamma_q1x_q - x_l\nendalign*","category":"page"},{"location":"component_models/shafts/#Shafts","page":"Shaft","title":"Shafts","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"The shaft component defines the rotating mass of the synchronous generator.","category":"page"},{"location":"component_models/shafts/#Rotor-Mass-Shaft-[SingleMass]","page":"Shaft","title":"Rotor Mass Shaft [SingleMass]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This is the standard model, on which one single mass (typically the rotor) is used to model the entire inertia of the synchronous generator. Each generator's rotating frame use a reference frequency omega_s, that typically is the synchronous one (i.e. omega_s = 10). The model defines two differential equations for the rotor angle delta and the rotor speed omega:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag1a \ndotomega = frac12H(tau_m - tau_e - D(omega-omega_s)) tag1b\nendalign","category":"page"},{"location":"component_models/shafts/#Five-Mass-Shaft-[FiveMassShaft]","page":"Shaft","title":"Five-Mass Shaft [FiveMassShaft]","text":"","category":"section"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"This model describes model connecting a high-pressure (hp) steam turbine, intermediate-pressure (ip) steam turbine, low-pressure (lp) steam pressure, rotor and exciter (ex) connected in series (in that order) in the same shaft using a spring-mass model:","category":"page"},{"location":"component_models/shafts/","page":"Shaft","title":"Shaft","text":"beginalign\ndotdelta = Omega_b(omega - omega_s) tag2a \ndotomega = frac12H left- tau_e - D(omega-omega_s)) - D_34 (omega-omega_lp) - D_45(omega-omega_ex) + K_lp(delta_lp-delta) +K_ex(delta_ex-delta) right tag2b \ndotdelta_hp = Omega_b(omega_hp - omega_s) tag2c \ndotomega_hp = frac12H_hp left tau_m - D_hp(omega_hp-omega_s) - D_12(omega_hp - omega_ip) + K_hp(delta_ip - delta_hp) right tag2d \ndotdelta_ip = Omega_b(omega_ip - omega_s) tag2e \ndotomega_ip = frac12H_ip left- D_ip(omega_ip-omega_s) - D_12(omega_ip - omega_hp) -D_23(omega_ip - omega_lp ) + K_hp(delta_hp - delta_ip) + K_ip(delta_lp-delta_ip) right tag2f \ndotdelta_lp = Omega_b(omega_lp-omega_s) tag2g \ndotomega_lp = frac12H_lp left - D_lp(omega_lp-omega_s) - D_23(omega_lp - omega_ip) -D_34(omega_lp - omega ) + K_ip(delta_ip - delta_lp) + K_lp(delta-delta_lp) right tag2h \ndotdelta_ex = Omega_b(omega_ex-omega_s) tag2i \ndotomega_ex = frac12H_ex left - D_ex(omega_ex-omega_s) - D_45(omega_ex - omega) + K_ex(delta - delta_ex) right tag2j\nendalign","category":"page"},{"location":"api/public/#PowerSimulationsDynamics","page":"Public API Reference","title":"PowerSimulationsDynamics","text":"","category":"section"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/public/#PowerSimulationsDynamics.BranchImpedanceChange","page":"Public API Reference","title":"PowerSimulationsDynamics.BranchImpedanceChange","text":"mutable struct BranchImpedanceChange <: Perturbation\n    time::Float64\n    branch_type::Type{<:PSY.ACBranch}\n    branch_name::String\n    multiplier::Float64\nend\n\nA BranchImpedanceChange change the impedance of a branch by a user defined multiplier. Currently there is only support for static branches disconnection, PowerSystems.Line and PowerSystems.Transformer2W. Future releases will provide support for a Dynamic Line disconnection.\n\nArguments:\n\ntime::Float64 : Defines when the Branch Impedance Change will happen. This time should be inside the time span considered in the Simulation\nbranch_tipe::Type{<:PowerSystems.ACBranch} : Type of branch modified\nbranch_name::String : User defined name for identifying the branch\nmultiplier::Float64 : User defined value for impedance multiplier.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.BranchTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.BranchTrip","text":"mutable struct BranchTrip <: Perturbation\n    time::Float64\n    branch_type::Type{<:PowerSystems.ACBranch}\n    branch_name::String\nend\n\nA BranchTrip completely disconnects a branch from the system. Currently there is only support for static branches disconnection, PowerSystems.Line and PowerSystems.Transformer2W. Future releases will provide support for a Dynamic Line disconnection. Note: Islanding is currently not supported in PowerSimulationsDynamics.jl. If a BranchTrip isolates a generation unit, the system may diverge due to the isolated generator.\n\nArguments:\n\ntime::Float64 : Defines when the Branch Trip will happen. This time should be inside the time span considered in the Simulation\nbranch_tipe::Type{<:PowerSystems.ACBranch} : Type of branch disconnected\nbranch_name::String : User defined name for identifying the branch\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.ControlReferenceChange","page":"Public API Reference","title":"PowerSimulationsDynamics.ControlReferenceChange","text":"mutable struct ControlReferenceChange <: Perturbation\n    time::Float64\n    device::PowerSystems.DynamicInjection\n    signal::Symbol\n    ref_value::Float64\nend\n\nA ControlReferenceChange allows to change the reference setpoint provided by a generator/inverter.\n\nArguments:\n\ntime::Float64 : Defines when the Control Reference Change will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.DynamicInjection} : Dynamic device modified\nsignal::Symbol : determines which reference setpoint will be modified. The accepted signals are:\n:P_ref: Modifies the active power reference setpoint.\n:V_ref: Modifies the voltage magnitude reference setpoint (if used).\n:Q_ref: Modifies the reactive power reference setpoint (if used).\n:ω_ref: Modifies the frequency setpoint.\nref_value::Float64 : User defined value for setpoint reference.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.GeneratorTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.GeneratorTrip","text":"mutable struct GeneratorTrip <: Perturbation\n    time::Float64\n    device::PowerSystems.DynamicInjection\nend\n\nA GeneratorTrip allows to disconnect a Dynamic Generation unit from the system at a specified time.\n\nArguments:\n\ntime::Float64 : Defines when the Generator Trip will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.DynamicInjection} : Device to be disconnected\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.LoadChange","page":"Public API Reference","title":"PowerSimulationsDynamics.LoadChange","text":"mutable struct LoadChange <: Perturbation\n    time::Float64\n    device::PowerSystems.ElectricLoad\n    signal::Symbol\n    ref_value::Float64\nend\n\nA LoadChange allows to change the active or reactive power setpoint from a load.\n\nArguments:\n\ntime::Float64 : Defines when the Load Change will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.ElectricLoad} : Dynamic device modified\nsignal::Symbol : determines which reference setpoint will be modified. The accepted signals are:\n:P_ref: Modifies the active power reference setpoint.\n:Q_ref: Modifies the reactive power reference setpoint.\nref_value::Float64 : User defined value for setpoint reference.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.LoadTrip","page":"Public API Reference","title":"PowerSimulationsDynamics.LoadTrip","text":"mutable struct LoadTrip <: Perturbation\n    time::Float64\n    device::PowerSystems.ElectricLoad\nend\n\nA LoadTrip allows the user to disconnect a load from the system.\n\nArguments:\n\ntime::Float64 : Defines when the Generator Trip will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.ElectricLoad} : Device to be disconnected\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.MassMatrixModel-Union{Tuple{Ctype}, Tuple{Any, Vector{Float64}, Type{Ctype}}} where Ctype<:PowerSimulationsDynamics.SimCache","page":"Public API Reference","title":"PowerSimulationsDynamics.MassMatrixModel","text":"Instantiate a MassMatrixModel for ODE inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.MassMatrixModel-Union{Tuple{Ctype}, Tuple{T}, Tuple{PowerSimulationsDynamics.SimulationInputs, Vector{T}, Type{Ctype}}} where {T<:Float64, Ctype<:PowerSimulationsDynamics.JacobianCache}","page":"Public API Reference","title":"PowerSimulationsDynamics.MassMatrixModel","text":"Instantiate a MassMatrixModel for ForwardDiff calculations\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.NetworkSwitch","page":"Public API Reference","title":"PowerSimulationsDynamics.NetworkSwitch","text":"function NetworkSwitch(\n    time::Float64,\n    ybus::SparseArrays.SparseMatrixCSC{Complex{Float64}, Int},\n)\n\nAllows to modify directly the admittance matrix, Ybus, used in the Simulation. This allows the user to perform branch modifications, three phase faults (with impedance larger than zero) or branch trips, as long as the new Ybus provided captures that perturbation.\n\nArguments:\n\ntime::Float64 : Defines when the Network Switch will happen. This time should be inside the time span considered in the Simulation\nybus::SparseArrays.SparseMatrixCSC{Complex{Float64}, Int} : Complex admittance matrix\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.PerturbState","page":"Public API Reference","title":"PowerSimulationsDynamics.PerturbState","text":"function PerturbState(\n    time::Float64,\n    index::Int,\n    value::Float64,\n)\n\nAllows the user to modify the state index by adding value. The user should modify dynamic states only, since algebraic state may require to do a reinitialization.\n\nArguments:\n\ntime::Float64 : Defines when the modification of the state will happen. This time should be inside the time span considered in the Simulation.\nindex::Int : Defines which state index you want to modify\nvalue::Float64 : Defines how much the state will increase in value\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.ResidualModel-Union{Tuple{Ctype}, Tuple{Any, Vector{Float64}, Type{Ctype}}} where Ctype<:PowerSimulationsDynamics.SimCache","page":"Public API Reference","title":"PowerSimulationsDynamics.ResidualModel","text":"Instantiate an ResidualModel for ODE inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.ResidualModel-Union{Tuple{Ctype}, Tuple{T}, Tuple{PowerSimulationsDynamics.SimulationInputs, Vector{T}, Type{Ctype}}} where {T<:Float64, Ctype<:PowerSimulationsDynamics.JacobianCache}","page":"Public API Reference","title":"PowerSimulationsDynamics.ResidualModel","text":"Instantiate an ResidualModel for ForwardDiff calculations\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.Simulation-Union{Tuple{T}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}, Vector{<:PowerSimulationsDynamics.Perturbation}}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation","text":"function Simulation\n    ::SimulationModel\n    system::PowerSystems.System\n    simulation_folder::String\n    tspan::NTuple{2, Float64},\n    perturbations::Vector{<:Perturbation} = Vector{Perturbation}();\n    kwargs...,\nend\n\nBuilds the simulation object and conducts the indexing process. The original system is not modified and a copy its created and stored in the Simulation.\n\nArguments:\n\n::SimulationModel : Type of Simulation Model. ResidualModel or MassMatrixModel. See Models Section for more details\nsystem::PowerSystems.System : System data\nsimulation_folder::String : Folder directory\ntspan::NTuple{2, Float64} : Time span for simulation\nperturbations::Vector{<:Perturbation} : Vector of Perturbations for the Simulation. Default: No Perturbations\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\ninitial_conditions::Vector{Float64} : Allows the user to pass a vector with the initial condition values desired in the simulation. If initialize_simulation = true, these values are used as a first guess and overwritten.\nfrequency_reference : Default ReferenceBus. Determines which frequency model is used for the network. Currently there are two options available:\nConstantFrequency assumes that the network frequency is 1.0 per unit at all times.\nReferenceBus will use the frequency state of a Dynamic Generator (rotor speed) or Dynamic Inverter (virtual speed) connected to the Reference Bus (defined in the Power Flow data) as the network frequency. If multiple devices are connected to such bus, the device with larger base power will be used as a reference. If a Voltage Source is connected to the Reference Bus, then a ConstantFrequency model will be used.\nsystem_to_file::Bool : Default false. Serializes the initialized system\nconsole_level::Logging : Default Logging.Warn. Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\nfile_level::Logging : Default Logging.Info. Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\ndisable_timer_outputs::Bool : Default false. Allows the user to display timer information about the construction and initilization of the Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.SourceBusVoltageChange","page":"Public API Reference","title":"PowerSimulationsDynamics.SourceBusVoltageChange","text":"mutable struct SourceBusVoltageChange <: Perturbation\n    time::Float64\n    device::PSY.Source\n    signal::Symbol\n    ref_value::Float64\nend\n\nA SourceBusVoltageChange allows to change the reference setpoint provided by a voltage source.\n\nArguments:\n\ntime::Float64 : Defines when the Control Reference Change will happen. This time should be inside the time span considered in the Simulation\ndevice::Type{<:PowerSystems.Source} : Device modified\nsignal::Symbol : determines which reference setpoint will be modified. The accepted signals are:\n:V_ref Modifies the internal voltage magnitude reference setpoint.\n:θ_ref  Modifies the internal voltage angle reference setpoint.\nref_value::Float64 : User defined value for setpoint reference.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#PowerSimulationsDynamics.Simulation!-Union{Tuple{T}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}}, Tuple{Type{T}, System, String, Tuple{Float64, Float64}, Vector{<:PowerSimulationsDynamics.Perturbation}}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.Simulation!","text":"function Simulation!\n    ::SimulationModel\n    system::PowerSystems.System\n    simulation_folder::String\n    tspan::NTuple{2, Float64},\n    perturbations::Vector{<:Perturbation} = Vector{Perturbation}();\n    kwargs...,\nend\n\nBuilds the simulation object and conducts the indexing process. The initial conditions are stored in the system.\n\nArguments:\n\n::SimulationModel : Type of Simulation Model. ResidualModel or MassMatrixModel. See Models Section for more details\nsystem::PowerSystems.System : System data\nsimulation_folder::String : Folder directory\ntspan::NTuple{2, Float64} : Time span for simulation\nperturbations::Vector{<:Perturbation} : Vector of Perturbations for the Simulation. Default: No Perturbations\ninitialize_simulation::Bool : Runs the initialization routine. If false, simulation runs based on the operation point stored in System\ninitial_conditions::Vector{Float64} : Allows the user to pass a vector with the initial condition values desired in the simulation. If initialize_simulation = true, these values are used as a first guess and overwritten.\nfrequency_reference : Default ReferenceBus. Determines which frequency model is used for the network. Currently there are two options available:\nConstantFrequency assumes that the network frequency is 1.0 per unit at all times.\nReferenceBus will use the frequency state of a Dynamic Generator (rotor speed) or Dynamic Inverter (virtual speed) connected to the Reference Bus (defined in the Power Flow data) as the network frequency. If multiple devices are connected to such bus, the device with larger base power will be used as a reference. If a Voltage Source is connected to the Reference Bus, then a ConstantFrequency model will be used.\nsystem_to_file::Bool : Default false. Serializes the initialized system\nconsole_level::Logging : Default Logging.Warn. Sets the level of logging output to the console. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\nfile_level::Logging : Default Logging.Info. Sets the level of logging output to file. Can be set to Logging.Error, Logging.Warn, Logging.Info or Logging.Debug\ndisable_timer_outputs::Bool : Default false. Allows the user to display timer information about the construction and initilization of the Simulation.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.execute!-Tuple{Simulation, Any}","page":"Public API Reference","title":"PowerSimulationsDynamics.execute!","text":"execute!(\n    sim::Simulation,\n    solver;\n    kwargs...\n)\n\nSolves the time-domain dynamic simulation model.\n\nArguments\n\nsim::Simulation : Initialized simulation object\nsolver : Solver used for numerical integration. Must be passed correctly depending on the Type of Simulation Model\nenable_progress_bar::Bool : Default: true. Enables progress bar for the integration routine.\nAdditional solver keyword arguments can be included. See Common Solver Options in the DifferentialEquations.jl documentation for more details.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_activepower_branch_flow-Tuple{SimulationResults, String, Symbol}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_activepower_branch_flow","text":"get_activepower_branch_flow(\n        res::SimulationResults,\n        name::String,\n        location::Symbol,\n)\n\nFunction to obtain the active power flowing through the series element of a Branch. The user must specified is the power should be computed in the :from or to :bus, by specifying a symbol.\n\nIf :from is specified, the power is computed flowing outwards the :from bus. If :to is specified, the power is computed flowing into the :to bus.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\nlocation::Symbol : :from or :to to specify a bus\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_activepower_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_activepower_series","text":"get_activepower_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the active power output time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_field_current_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_field_current_series","text":"get_field_current_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the field current time series of a Dynamic Generator out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_field_voltage_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_field_voltage_series","text":"get_field_voltage_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the field voltage time series of a Dynamic Generator out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_frequency_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_frequency_series","text":"get_frequency_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the frequency time series of a Dynamic Injection out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_imaginary_current_branch_flow-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_imaginary_current_branch_flow","text":"get_imaginary_current_branch_flow(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the imaginary current flowing through the series element of a Branch\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_imaginary_current_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_imaginary_current_series","text":"get_imaginary_current_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the imaginary current time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_jacobian-Union{Tuple{T}, Tuple{Type{T}, System}, Tuple{Type{T}, System, Int64}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.get_jacobian","text":"function get_jacobian(\n::Type{T},\nsystem::PSY.System,\nsparse_retrieve_loop::Int = 3,\n) where {T <: SimulationModel}\n\nReturns the jacobian function of the system model resulting from the system data.\n\nArguments:\n\n::SimulationModel : Type of Simulation Model. ResidualModel or MassMatrixModel. See Models Section for more details\nsystem::PowerSystems.System : System data\nsparse_retrieve_loop::Int : Number of loops for sparsity detection. If 0, builds the Jacobian with a DenseMatrix\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_mechanical_torque_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_mechanical_torque_series","text":"get_mechanical_torque_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the mechanical torque time series of the mechanical torque out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_pss_output_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_pss_output_series","text":"get_pss_output_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the pss output time series of a Dynamic Generator out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_reactivepower_branch_flow-Tuple{SimulationResults, String, Symbol}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_reactivepower_branch_flow","text":"get_reactivepower_branch_flow(\n        res::SimulationResults,\n        name::String,\n        location::Symbol,\n)\n\nFunction to obtain the reactive power flowing through the series element of a Branch. The user must specified is the power should be computed in the :from or to :bus, by specifying a symbol.\n\nIf :from is specified, the power is computed flowing outwards the :from bus. If :to is specified, the power is computed flowing into the :to bus.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\nlocation::Symbol : :from or :to to specify a bus\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_reactivepower_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_reactivepower_series","text":"get_reactivepower_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the reactive power output time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_real_current_branch_flow-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_real_current_branch_flow","text":"get_real_current_branch_flow(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the real current flowing through the series element of a Branch\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified line\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_real_current_series-Tuple{SimulationResults, String}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_real_current_series","text":"get_real_current_series(\n        res::SimulationResults,\n        name::String,\n)\n\nFunction to obtain the real current time series of a Dynamic Injection series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nname::String : Name to identify the specified device\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_setpoints-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_setpoints","text":"get_setpoints(sim::Simulation)\n\nFunction that returns the reference setpoints for all the dynamic devices.\n\nArguments\n\nsim::Simulation : Simulation object that contains the initial condition and setpoints.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_source_imaginary_current_series","page":"Public API Reference","title":"PowerSimulationsDynamics.get_source_imaginary_current_series","text":"Function to obtain output imaginary current for a source. It receives the simulation results, the Source name and an optional argument of the time step of the results.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#PowerSimulationsDynamics.get_source_real_current_series","page":"Public API Reference","title":"PowerSimulationsDynamics.get_source_real_current_series","text":"Function to obtain output real current for a source. It receives the simulation results, the Source name and an optional argument of the time step of the results.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#PowerSimulationsDynamics.get_state_series-Tuple{SimulationResults, Tuple{String, Symbol}}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_state_series","text":"get_state_series(\n    res::SimulationResults,\n    ref::Tuple{String, Symbol};\n    dt::Union{Nothing, Float64, Vector{Float64}} = nothing\n)\nend\n\nFunction to obtain series of states out of DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nref:Tuple{String, Symbol} : Tuple used to identify the dynamic device, via its name, as a String, and the associated state as a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltage_angle_series-Tuple{SimulationResults, Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltage_angle_series","text":"get_voltage_angle_series(\n    res::SimulationResults,\n    bus_number::Int\n)\n\nFunction to obtain the voltage angle series out of the DAE Solution.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\nbus_number::Int : Bus number identifier\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.get_voltage_magnitude_series-Tuple{SimulationResults, Int64}","page":"Public API Reference","title":"PowerSimulationsDynamics.get_voltage_magnitude_series","text":"get_voltage_magnitude_series(\n    res::SimulationResults,\n    bus_number::Int\n)\n\nFunction to obtain the voltage magnitude series out of the DAE Solution.\n\nArguments:\n\nres::SimulationResults : Simulation Results object that contains the solution\nbus_number::Int : Bus number identifier\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.read_initial_conditions-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.read_initial_conditions","text":"Returns a Dictionary with the resulting initial conditions of the simulation\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.show_states_initial_value-Tuple{SimulationResults}","page":"Public API Reference","title":"PowerSimulationsDynamics.show_states_initial_value","text":"show_states_initial_value(res::SimulationResults)\n\nFunction to print initial states.\n\nArguments\n\nres::SimulationResults : Simulation Results object that contains the solution\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.show_states_initial_value-Tuple{Simulation}","page":"Public API Reference","title":"PowerSimulationsDynamics.show_states_initial_value","text":"show_states_initial_value(sim::Simulation)\n\nFunction to print initial states.\n\nArguments\n\nsim::Simulation : Simulation object that contains the initial condition\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.small_signal_analysis-Union{Tuple{Simulation{T}}, Tuple{T}} where T<:PowerSimulationsDynamics.SimulationModel","page":"Public API Reference","title":"PowerSimulationsDynamics.small_signal_analysis","text":"small_signal_analysis(\n        sim::Simulation,\n)\n\nReturns the Small Signal Output object that contains the eigenvalues and participation factors.\n\nArguments\n\nsim::Simulation : Small Signal Output object that contains the eigenvalues and participation factors\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.summary_eigenvalues-Tuple{PowerSimulationsDynamics.SmallSignalOutput}","page":"Public API Reference","title":"PowerSimulationsDynamics.summary_eigenvalues","text":"summary_eigenvalues(\n        sm::SmallSignalOutput,\n)\n\nFunction to obtain a summary of the eigenvalues of the Jacobian at the operating point. It returns a DataFrame with the most associated state for each eigenvalue, its real and imaginary part, damping and frequency.\n\nArguments\n\nsm::SmallSignalOutput : Small Signal Output object that contains the eigenvalues and participation factors\n\n\n\n\n\n","category":"method"},{"location":"api/public/#PowerSimulationsDynamics.summary_participation_factors-Tuple{PowerSimulationsDynamics.SmallSignalOutput}","page":"Public API Reference","title":"PowerSimulationsDynamics.summary_participation_factors","text":"summary_participation_factors(\n        sm::SmallSignalOutput,\n)\n\nFunction to obtain the participation factor of each state to each eigenvalue. It returns a DataFrame with the participation factors of each state to all eigenvalues.\n\nArguments\n\nsm::SmallSignalOutput : Small Signal Output object that contains the eigenvalues and participation factors\n\n\n\n\n\n","category":"method"},{"location":"component_models/network/#Network-model","page":"Network","title":"Network model","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Here we discuss the models used to describe the network in PowerSimulationsDynamics.jl. This is based on a standard current injection model as defined in Power System Modelling and Scripting. The numerical advantages of current injection models outweigh the complexities of implementing constant power loads for longer-term transient stability analysis. The network is defined in a synchronous reference frame (SRF), named the RI (real-imaginary) reference frame, rotating at the constant base frequency Omega_b.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"In simple terms, PowerSimulationsDynamics.jl internally tracks the current-injection balances at the nodal level from all the devices on the system. Based on the buses and branches information, the system constructor computes the admittance matrix boldsymbolY assuming nominal frequency and this is used for static branch modeling. The algebraic equations for the static portions of the network are as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":" beginalign\n 0 = boldsymboli(boldsymbolx boldsymbolv) - boldsymbolYboldsymbolv\n endalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"where boldsymboli = i_r + ji_i is the vector of the sum of complex current injections from devices , boldsymbolx is the vector of states and boldsymbolv = v_r + jv_i is the vector of complex bus voltages. Equations (1) connect all the port variables, i.e., currents, defined for each injection device. Components that contribute to (1) by modifying the current boldsymboli are (i) static injection devices, (ii) dynamic injection devices, and (iii) dynamic network branches. Components that contribute to modify the admittance matrix boldsymbolY are static branches.","category":"page"},{"location":"component_models/network/#Static-Branches-(or-Algebraic-Branches)","page":"Network","title":"Static Branches (or Algebraic Branches)","text":"","category":"section"},{"location":"component_models/network/#Lines","page":"Network","title":"Lines","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Each line is defined using a pi model connecting two buses (nm), with a series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m). The values are already in system per unit. Then each branch contributes to the admittance matrix as follows:","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\nY_nn += frac1r+jx + jc_n \nY_nm += frac-1r+jx \nY_mm += frac1r+jx + jc_m \nY_mn += frac-1r+jx \nendalign","category":"page"},{"location":"component_models/network/#Two-Windings-Transformers","page":"Network","title":"Two-Windings Transformers","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Similarly to lines these are defined by a series reactance and impedance. The equations are equivalently of the lines without the shunt capacitance.","category":"page"},{"location":"component_models/network/#Dynamic-Branches","page":"Network","title":"Dynamic Branches","text":"","category":"section"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Dynamic network branches contribute directly to (1) by modifying the vector of complex currents. Their parameters are also the series resistance r and reactance x, and a shunt capacitance at both ends (c_n c_m) for a line ell. In addition, they define 3 new additional differential equations per line (6 in total for real and imaginary part):","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"beginalign\n    fraclOmega_b fracdboldsymboli_elldt = (boldsymbolv_n - boldsymbolv_m) - (r+jl) boldsymboli_ell \n     fracc_nOmega_b fracdboldsymbolv_ndt =  boldsymboli_n^textcap - jc_nboldsymbolv_n   \n      fracc_mOmega_b fracdboldsymbolv_mdt = boldsymboli_m^textcap - jc_mboldsymbolv_m\nendalign","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"Since all the values are in per unit, the reactance is equal to the inductance.","category":"page"},{"location":"component_models/network/","page":"Network","title":"Network","text":"A detail discussion about the effects of different line models in the modeling of inverters is presented in Grid Forming Inverter Small Signal Stability: Examining Role of Line and Voltage Dynamics","category":"page"},{"location":"component_models/pss/#Power-System-Stabilizers-(PSS)","page":"PSS","title":"Power System Stabilizers (PSS)","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"PSS are used to add an additional signal v_s to the input signal of the AVR: v_textref = v_textref^textavr + v_s.","category":"page"},{"location":"component_models/pss/#Fixed-PSS-[PSSFixed]","page":"PSS","title":"Fixed PSS [PSSFixed]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is a simple model that set the stabilization signal to be equal to a desired constant value v_s = v_s^textfix. The absence of PSS can be modelled using this component with v_s^textfix = 0.","category":"page"},{"location":"component_models/pss/#Simple-PSS-[PSSSimple]","page":"PSS","title":"Simple PSS [PSSSimple]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"This is the most basic PSS that can be implemented, on which the stabilization signal is  a proportional controller over the frequency and electrical power:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nv_s = K_omega(omega - omega_s) + K_p(omega tau_e - P_textref) tag1a\nendalign","category":"page"},{"location":"component_models/pss/#IEEE-Stabilizer-[IEEEST]","page":"PSS","title":"IEEE Stabilizer [IEEEST]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"The 7th-order PSS model is:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nA_4 dotx_1 = u - A_3 x_1 - x_2  tag2a \ndotx_2 = x_1 tag2b \nA_2dotx_3 = x_2 - A_1 x_3 - x_4 tag2c\ndotx_4 = x_3 tag2d\nT_2dotx_5 = left(1 - fracT_1T_2right) y_f - x_5 tag2e\nT_4dotx_6 = left(1 - fracT_3T_4right) y_LL1 - x_6 tag2f\nT_6dotx_7 =  -left(fracK_s T_5T_6 y_LL2 + x_7 right) tag2g\nendalign","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"with","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign*\ny_f = fracT_4T_2 x_2 + left(T_3 - T_1 fracT_4T_2right) x_3 + left(1 - fracT_4T_2right)x_4 \ny_LL1 = x_5 + fracT_1T_2 y_f \ny_LL2 = x_6 + fracT_3T_4 y_LL1 \ny_out = x_7 + fracK_s T_5T_6 y_LL2 \nV_s = textclamp(y_out textLs_textmin textLs_textmax)\nendalign*","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"on which u is the input signal to the PSS, that depends on the flag. Currently, rotor speed, electric torque, mechanical torque and voltage magnitude are supported inputs.","category":"page"},{"location":"component_models/pss/#STAB1-PSS-[STAB1]","page":"PSS","title":"STAB1 PSS [STAB1]","text":"","category":"section"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"The 3rd-order PSS model is:","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign\nT dotx_1 = K omega - x_1 tag3a \nT_3dotx_2 = left(1 - fracT_1T_3right) x_1 - x_2 tag3b \nT_4dotx_3 = left(1 - fracT_2T_4right) y_LL - x_2 tag3c \nendalign","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"with","category":"page"},{"location":"component_models/pss/","page":"PSS","title":"PSS","text":"beginalign*\ny_LL = x_2 + fracT_1T_3 x_1 \ny_out = x_3 +  fracT_2T_4 y_LL \nV_s =  textclamp(y_out -H_lim H_lim)\nendalign*","category":"page"},{"location":"initialization/#Initialization-Routine","page":"Initialization","title":"Initialization Routine","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Dynamic Simulations require a reasonable initial condition for the system model. In most analysis, power systems models are initialized at a stable equilibrium, which implies that:","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"beginalign\n0 = F(x u eta)\nendalign","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finding the solution of a large non-linear system is challenging and requires a reasonable initial guess. In classical power systems literature, the routine to find equilibrium points for the dynamic injection devices' components is well known and used in free and commercial software (see Power System Modelling and Scripting page 224). However, in the case of converter interface dynamic injection models, such routines are not documented.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initializing the system also requires finding valid set-points for the devices in the system. For instance, finding the reference voltage in an AVR to match the voltage magnitude resulting from the power flow solution. PowerSimulationsDynamics.jl prioritizes mathching the dynamic components control references to match the power flow results.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Finally, the initialization must instantiate not only the values of the states but also the inner vars. PowerSimulationsDynamics.jl handles all this initializations by default.","category":"page"},{"location":"initialization/#Initialization-interface","page":"Initialization","title":"Initialization interface","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"By default PowerSimulationsDynamics.jl initializes the system following the steps described below. it is possible to provide an initial guess for the initial conditions to speed up the initialization process.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Simulation(\n        ResidualModel,\n        sys,\n        pwd(),\n        (0.0, 20.0);\n        initial_conditions = x0_init,\n    )","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"It is also possible to initialize the simulation using a flat start (V_mag = 1.0, V_angle = 0.0 and x0 = zeros) using initialize_simulation = false. However, for medium or large system this is unlikely to result in a valid initial condition for the simulation.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Simulation(\n        ResidualModel,\n        sys,\n        pwd(),\n        (0.0, 20.0);\n        initialize_simulation = false,\n    )","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"If you want to avoid PowerSimulationsDynamics.jl from finding an stable equilibrium automatically and provide the initial condition manually you can use the following flag combination.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Simulation(\n        ResidualModel,\n        sys,\n        pwd(),\n        (0.0, 20.0);\n        initialize_simulation = false,\n        initial_conditions = x0_init,\n    )","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"<span style=\"color:red\">WARNING!</span>: when the initialize_simulation is set to false, neither the device set points nor the inner vars are initialized. Use these keywords with care and make sure the values in the system components match the initial conditions provided.","category":"page"},{"location":"initialization/#System-wide-initialization-routine","page":"Initialization","title":"System-wide initialization routine","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The initialization routine starts from the solution of the power flow equations. For each dynamic injection device PowerSimulationsDynamics.jl finds the solution of the systems of non-linear equations for each dynamic component following the sequences described in the forthcoming sections.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Once each device is individually initialized, the system-wide initial guess is used to solve the system (1). In a first attempt at finding the solution, the tolerance is set to a stringent tolerance. If the non-linear solver is unable to get a solution, it might usually reflect small signal stability problems in the system. In a second attempt, the tolerances are relaxed. If the solver succeeds, the simulation continues, but the user is warned.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"<img src=\"../assets/sys_init.png\" width=\"65%\">","category":"page"},{"location":"initialization/#Initialization-of-the-Synchronous-Machines","page":"Initialization","title":"Initialization of the Synchronous Machines","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The initialization of Synchronous Machines is standard in power systems and follows the scheme shown in the figure. Other internal variables are calculated recursively from the power flow solution for the node on which the dynamic device isconnected. (Adapted from Power System Modelling and Scripting Figure 9.2)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"(Image: init_machine)","category":"page"},{"location":"initialization/#Initialization-of-the-Inverters","page":"Initialization","title":"Initialization of the Inverters","text":"","category":"section"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Initializing the inverters follows the sequence shown in the figure and has been developed to be compatible with the implementation of custom dynamic components. Given that the process is less studied and standard than the one of the synchronous machine, this page contains more detailed documentation of the process.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"(Image: init_machine)","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"The first component to be initialized is the filter. Given that the filter is an RLC circuit connected to the grid, its currents and voltages need to match the results of the power flow. The initialization of the filter provides the values for the P and Q used in the outer control and the V and I needed in the inner controls.\nBased on the bus voltage in the system's reference frame V_r and the bus angle theta the PLL's can be initialized to obtain the angle and frequency estimates needed by the outer control.\nThe Outer Control calculates the internal angle delta_olc required by the inner control to estimate the voltage and current phase difference.\nThe DC Source uses the power set-point consistent with the power outputs of the filter to initialize the V_dc set-points. This value is used in the inner control.\nThe inner control takes the phase angle delta_olc and the V_dc to estimate the modulation values of the PWM converter.","category":"page"},{"location":"initialization/","page":"Initialization","title":"Initialization","text":"Note: The initialization of an inverter through the proposed meta-model is actively under development and subject to change. This page will maintain the latest version of the sequence.","category":"page"},{"location":"tutorials_page/#SIIP-Examples","page":"SIIP-Examples","title":"SIIP-Examples","text":"","category":"section"},{"location":"tutorials_page/","page":"SIIP-Examples","title":"SIIP-Examples","text":"All the tutorials for the SIIP project are part of a separate repository SIIP-Examples. You can access the latest PowerSimulationsDynamics.jl tutorial notebooks in this link","category":"page"},{"location":"tutorials_page/","page":"SIIP-Examples","title":"SIIP-Examples","text":"Specific examples of common workflows and models:","category":"page"},{"location":"tutorials_page/","page":"SIIP-Examples","title":"SIIP-Examples","text":"Loading Dynamic Data\nSolving a One Machine against Infinite Bus model\nChanging line modeling assumptions\nUsing an Inverter in a Multi-Machine Model","category":"page"},{"location":"tutorials/tutorial_continuation_pf/#Tutorial-Small-Signal-Analysis-with-Continuation-Power-Flow","page":"Small-Signal Analysis","title":"Tutorial Small Signal Analysis with Continuation Power Flow","text":"","category":"section"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"Originally Contributed by: Rodrigo Henriquez-Auba","category":"page"},{"location":"tutorials/tutorial_continuation_pf/#Introduction","page":"Small-Signal Analysis","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"This tutorial will introduce you to the functionality of PowerSimulationsDynamics and PowerFlows for running small signal analysis in a continuation power flow.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"This tutorial presents a simulation of a two-bus system with a generator (represented with a GENROU + SEXS + TGOV1 model) at bus 1, and a load on bus 2. We will increase the load demand to observe the P-V curve and run a small-signal analysis to check if the system satisfies small-signal stability at different operating points.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/#Dependencies","page":"Small-Signal Analysis","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"using PowerSimulationsDynamics\nPSID = PowerSimulationsDynamics\nusing PowerSystemCaseBuilder\nusing PowerSystems\nusing PowerFlows\nconst PSY = PowerSystems\nusing Plots\ngr()\n\n# Disable Logging to avoid excessive information\nusing Logging\nLogging.disable_logging(Logging.Info); \nLogging.disable_logging(Logging.Warn); ","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"PowerSystems (abbreviated with PSY) is used to properly define the data structure and establish an equilibrium point initial condition with a power flow routine using PowerFlows.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/#Load-the-system","page":"Small-Signal Analysis","title":"Load the system","text":"","category":"section"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"We load the system using PowerSystemCaseBuilder.jl. This system only have a generator without dynamic data on which we can use PowerFlows to generate a P-V (or nose) curve.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"sys_static = build_system(PSIDSystems, \"2 Bus Load Tutorial\")","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"Note that this system contains an Exponential Load, but the parameters are set up to zero, so it behaves a Constant Power Load:","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"first(get_components(PSY.ExponentialLoad, sys_static))","category":"page"},{"location":"tutorials/tutorial_continuation_pf/#Create-a-P-V-curve","page":"Small-Signal Analysis","title":"Create a P-V curve","text":"","category":"section"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"The next step is to run multiple power flows and store the voltage at the load and the active power. For this example we will set up the power factor to be unitary (i.e. no reactive power at the load). ","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"# Create a Power Range to change the power load active power\nP_range = 0.01:0.01:4.6;\n# Choose the power factor\nload_pf = 1.0;","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"Then create vectors to store the results","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"# PV Curve Results\nP_load_p = Vector{Float64}();\nV_load_p = Vector{Float64}();","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"Then, we run multiple power flows in a for loop by changing the active power of the load:","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"for p in P_range\n    # Change the active power and reactive power of the load\n    power = p * 1.0\n    load = get_component(PSY.ExponentialLoad, sys_static, \"load1021\")\n    set_active_power!(load, power)\n    q_power = power * tan(acos(load_pf))\n    set_reactive_power!(load, q_power)\n    # Run Power Flow\n    status = solve_ac_powerflow!(sys_static)\n    if !status\n        # Finish the loop if the power flow fails\n        print(\"Power Flow failed at p = $(power)\")\n        break\n    end\n    # Obtain the bus voltage information\n    bus = get_component(Bus, sys_static, \"BUS 2\")\n    Vm = get_magnitude(bus)\n    # Store values in the vectors\n    push!(V_load_p, Vm)\n    push!(P_load_p, power)\nend","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"The plot can be visualized with:","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"plot(P_load_p,\n     V_load_p,\n     label = \"PV Curve\",\n     xlabel = \"Load Power [pu]\",\n     ylabel = \"Load Bus Voltage [pu]\",\n     color = :black\n)","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_continuation_pf/#Run-Small-Signal-Analysis-besides-the-Continuation-Power-Flow","page":"Small-Signal Analysis","title":"Run Small-Signal Analysis besides the Continuation Power Flow","text":"","category":"section"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"To run a small-signal analysis we require a dynamic model of the machine. We can use PowerSystemCaseBuilder to the load the same system, but with a dynamic model for the generator, including a GENROU + SEXS exciter + TGOV1 governor.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"sys = build_system(PSIDSystems, \"2 Bus Load Tutorial GENROU\")","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"Here are the components of the generator:","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"first(get_components(DynamicGenerator, sys))","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"Besides the results of the P-V curve, we need to store if the system is small-signal stable or not by looking if there is a positive real part eigenvalue.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"# Vectors to store stability using a boolean (true for stable).\nstable_vec = Vector{Bool}();\nstatus_vec = Vector{Bool}();\n\n# PV Curve Results\nP_load_p = Vector{Float64}();\nV_load_p = Vector{Float64}();","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"We then run the main for loop by updating the load active power, but in addition we create a PowerSimulationsDynamics simulation on which we can run a small-signal analysis to check stability.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"for p in P_range\n    # Change the active power and reactive power of the load\n    power = p * 1.0\n    load = get_component(PSY.ExponentialLoad, sys_static, \"load1021\")\n    set_active_power!(load, power)\n    q_power = power * tan(acos(load_pf))\n    set_reactive_power!(load, q_power)\n    # Run Power Flow\n    status = solve_ac_powerflow!(sys_static)\n    if !status\n        # Finish the loop if the power flow fails\n        print(\"Power Flow failed at p = $(power)\")\n        break\n    end\n    # Obtain the bus voltage information\n    bus = get_component(Bus, sys_static, \"BUS 2\")\n    Vm = get_magnitude(bus)\n    # Store values in the vectors\n    push!(V_load_p, Vm)\n    push!(P_load_p, power)\n\n    # Update Load Power in the GENROU system\n    load = get_component(PSY.ExponentialLoad, sys, \"load1021\")\n    set_active_power!(load, power)\n    q_power = power * tan(acos(load_pf))\n    set_reactive_power!(load, q_power)\n    # Construct Simulation\n    sim = Simulation(ResidualModel, sys, mktempdir(), (0.0, 1.0))\n    if sim.status == PSID.BUILT\n        # Check small-signal stability\n        sm = small_signal_analysis(sim).stable\n        # Push results of small-signal stability\n        push!(stable_vec, sm)\n        # Push results if the simulation was able to be constructed\n        push!(status_vec, true)\n    else\n        # Push results if the simulation was not able to be constructed\n        push!(status_vec, false)\n    end\nend","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"The following plot showcases the P-V curve, while also showcasing (in red) the regions on which the system is small-signal stable.","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"\n# Find where is stable and unstable\ndict_true_ixs_p = Vector();\ndict_false_ixs_p = Vector();\ndict_true_ixs_p = findall(x->x, stable_vec);\ndict_false_ixs_p = findall(x->!x, stable_vec);\n\n# Create plot\ntrue_ixs = dict_true_ixs_p;\nplot(P_load_p, V_load_p, color = :blue, label = \"PV Curve\", xlabel = \"Load Power [pu]\", ylabel = \"Load Bus Voltage [pu]\")\nplot!(Plots.scatter!(P_load_p[true_ixs] , V_load_p[true_ixs], markerstrokewidth= 0, label = \"GENROU SSA\"))","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_continuation_pf/","page":"Small-Signal Analysis","title":"Small-Signal Analysis","text":"This results is consistent with most of the literature for dynamic generator models supplying constant power loads, on which by increasing the active power of the load, produce critical eigenvalues which cross the jomega axis at some point. This is called a Hopf Bifurcation, in this case a subcritical one since the limit cycles are unstable.","category":"page"},{"location":"reference_frames/#Reference-Frames","page":"Reference Frames","title":"Reference Frames","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Each dynamic device is defined in its own dq synchronous reference frame (SRF). It is important to note that there are several conventions to do reference frame transformations.","category":"page"},{"location":"reference_frames/#Synchronous-Machines","page":"Reference Frames","title":"Synchronous Machines","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The grid is modeled in its own real-imaginary (RI) reference frame. With such, this follows the standard convention that for a voltage angle theta = 0, there is no imaginary part and hence v_h = v_r + j0. Traditionally, the reference frame dq with rotor angle delta for synchronous machines connected to a bus v_hangle theta = v_r + jv_i follows the following convention for transformation of per-unit RMS phasors:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-j(delta- pi2) tag1a \nv_d =  v_h sin(delta - theta) tag1b \nv_q = v_h cos(delta - theta) tag1c \nleft beginarrayc v_d  v_q endarray right = left beginarraycc sin(delta)  -cos(delta)  cos(delta)  sin(delta) endarray right left beginarrayc v_r  v_i endarray right tag1d\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Note that hence in a bus of 10angle 0, a rotor angle of delta = 0 implies that v_q = 10 and v_d = 00. This transformation is the one that can be found in most books of Power Systems, such as Kundur, Sauer Pai and in Milano too, and is the convention used in the software to model dynamic models of synchronous machines in their own reference frame.","category":"page"},{"location":"reference_frames/#Inverters","page":"Reference Frames","title":"Inverters","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"The previously convention is not the standard one used for modeling inverters. Most of inverter and phase-lock loop (PLL) models follow the next convention:","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"beginalign\nv_d + jv_q = (v_r + jv_i) e^-j delta tag2a  \nv_d =  v_h cos(delta - theta) tag2b \nv_q = -v_h sin(delta - theta) tag2c\nendalign","category":"page"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"That, contrary to the previous case, when delta = theta = 0 implies that v_d = 10 and v_q = 00. This yields the typical PLL conditions that steer v_q to 0 when delta locks in theta, or when both SRF lock between each other.","category":"page"},{"location":"reference_frames/#Transformation-used","page":"Reference Frames","title":"Transformation used","text":"","category":"section"},{"location":"reference_frames/","page":"Reference Frames","title":"Reference Frames","text":"Given the predominancy of both convention in current work, the software uses both conventions depending on the device modeled. For synchronous machines we used the standard convention (1a)-(1d), while for inverter models we use the predominant convention used nowadays in such models, i.e. (2a)-(2c).","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/#Inverter-Modeling-simulation","page":"Inverter Modeling","title":"Inverter Modeling simulation","text":"","category":"section"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Originally Contributed by: José Daniel Lara","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/#Introduction","page":"Inverter Modeling","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"This tutorial will introduce the modeling of an inverter with Virtual Inertia in a multi-machine model of the system. We will load the data directly from PSS/e dynamic files.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"The tutorial uses a modified 14-bus system on which all the synchronous machines have been substituted by generators with ESAC1A AVR's and no Turbine Governors.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"In the first portion of the tutorial we will simulate the system with the original data and cause a line trip between Buses 2 and 4. In the second part of the simulation, we will switch generator 6 with a battery using an inverter and perform the same fault.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/#Load-the-packages","page":"Inverter Modeling","title":"Load the packages","text":"","category":"section"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"using PowerSimulationsDynamics\nusing PowerSystemCaseBuilder\nusing PowerSystems\nconst PSY = PowerSystems\nusing PowerFlows\nusing Logging\nusing Sundials\nusing Plots","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Create the system using PowerSystemCaseBuilder.jl:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"sys = build_system(PSIDSystems, \"14 Bus Base Case\")","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"PowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Define Simulation Problem with a 20 second simulation period and the branch trip at t = 1.0:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"sim = Simulation(\n    ResidualModel, #Type of model used\n    sys,         #system\n    mktempdir(),       #path for the simulation output\n    (0.0, 20.0), #time span\n    BranchTrip(1.0, Line, \"BUS 02-BUS 04-i_1\");\n    console_level = Logging.Info,\n)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Now that the system is initialized, we can verify the system states for potential issues.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"show_states_initial_value(sim)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"We execute the simulation with an additional tolerance for the solver set at 1e-8:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"execute!(sim, IDA(); abstol = 1e-8)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Using PowerSimulationsDynamics tools for exploring the results, we can plot all the voltage results for the buses:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"result = read_results(sim)\np = plot();\nfor b in get_components(ACBus, sys)\n    voltage_series = get_voltage_magnitude_series(result, get_number(b))\n    plot!(\n        p,\n        voltage_series;\n        xlabel = \"Time\",\n        ylabel = \"Voltage Magnitude [pu]\",\n        label = \"Bus - $(get_name(b))\",\n    );\nend","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"We can also explore the frequency of the different generators","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"p2 = plot();\nfor g in get_components(ThermalStandard, sys)\n    state_series = get_state_series(result, (get_name(g), :ω))\n    plot!(\n        p2,\n        state_series;\n        xlabel = \"Time\",\n        ylabel = \"Speed [pu]\",\n        label = \"$(get_name(g)) - ω\",\n    );\nend","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"It is also possible to explore the small signal stability of this system we created.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"res = small_signal_analysis(sim)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/#The-eigenvalues-can-be-explored","page":"Inverter Modeling","title":"The eigenvalues can be explored","text":"","category":"section"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"res.eigenvalues","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/#Modifying-the-system-and-adding-storage","page":"Inverter Modeling","title":"Modifying the system and adding storage","text":"","category":"section"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Reload the system for this example:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"sys = build_system(PSIDSystems, \"14 Bus Base Case\")\n\n# We want to remove the generator 6 and the dynamic component attached to it.\nthermal_gen = get_component(ThermalStandard, sys, \"generator-6-1\")\nremove_component!(sys, get_dynamic_injector(thermal_gen))\nremove_component!(sys, thermal_gen)\n\n# We can now define our storage device and add it to the system\nstorage = GenericBattery(\n    name = \"Battery\",\n    bus = get_component(Bus, sys, \"BUS 06\"),\n    available = true,\n    prime_mover = PrimeMovers.BA,\n    active_power = 0.6,\n    reactive_power = 0.16,\n    rating = 1.1,\n    base_power = 25.0,\n    initial_energy = 50.0,\n    state_of_charge_limits = (min = 5.0, max = 100.0),\n    input_active_power_limits = (min = 0.0, max = 1.0),\n    output_active_power_limits = (min = 0.0, max = 1.0),\n    reactive_power_limits = (min = -1.0, max = 1.0),\n    efficiency = (in = 0.80, out = 0.90),\n)\n\nadd_component!(sys, storage)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"A good sanity check it running a power flow on the system to make sure all the components are properly scaled and that the system is properly balanced. We can use PowerSystems to perform this check. We can get the results back and perform a sanity check.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"res = solve_powerflow(ACPowerFlow(), sys)\nres[\"bus_results\"]","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"After verifying that the system works, we can define our inverter dynamics and add it to the battery that has already been stored in the system.","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"inverter = DynamicInverter(\n    name = get_name(storage),\n    ω_ref = 1.0, # ω_ref,\n    converter = AverageConverter(rated_voltage = 138.0, rated_current = 100.0),\n    outer_control = OuterControl(\n        VirtualInertia(Ta = 2.0, kd = 400.0, kω = 20.0),\n        ReactivePowerDroop(kq = 0.2, ωf = 1000.0),\n    ),\n    inner_control = VoltageModeControl(\n        kpv = 0.59,     #Voltage controller proportional gain\n        kiv = 736.0,    #Voltage controller integral gain\n        kffv = 0.0,     #Binary variable enabling the voltage feed-forward in output of current controllers\n        rv = 0.0,       #Virtual resistance in pu\n        lv = 0.2,       #Virtual inductance in pu\n        kpc = 1.27,     #Current controller proportional gain\n        kic = 14.3,     #Current controller integral gain\n        kffi = 0.0,     #Binary variable enabling the current feed-forward in output of current controllers\n        ωad = 50.0,     #Active damping low pass filter cut-off frequency\n        kad = 0.2,\n    ),\n    dc_source = FixedDCSource(voltage = 600.0),\n    freq_estimator = KauraPLL(\n        ω_lp = 500.0, #Cut-off frequency for LowPass filter of PLL filter.\n        kp_pll = 0.084,  #PLL proportional gain\n        ki_pll = 4.69,   #PLL integral gain\n    ),\n    filter = LCLFilter(lf = 0.08, rf = 0.003, cf = 0.074, lg = 0.2, rg = 0.01),\n)\nadd_component!(sys, inverter, storage)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"These are the current system components:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"sys","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Define Simulation problem using the same parameters:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"sim = Simulation(\n    ResidualModel, #Type of model used\n    sys,         #system\n    mktempdir(),       #path for the simulation output\n    (0.0, 20.0), #time span\n    BranchTrip(1.0, Line, \"BUS 02-BUS 04-i_1\");\n    console_level = Logging.Info,\n)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"We can verify the small signal stability of the system before running the simulation:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"res = small_signal_analysis(sim)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Exploring the eigenvalues:","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"res.eigenvalues","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"We execute the simulation","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"execute!(sim, IDA(); abstol = 1e-8)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"Using PowerSimulationsDynamics tools for exploring the results, we can plot all the voltage results for the buses","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"result = read_results(sim)\np = plot();\nfor b in get_components(ACBus, sys)\n    voltage_series = get_voltage_magnitude_series(result, get_number(b))\n    plot!(\n        p,\n        voltage_series;\n        xlabel = \"Time\",\n        ylabel = \"Voltage Magnitude [pu]\",\n        label = \"Bus - $(get_name(b))\",\n    );\nend","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"We can also explore the frequency of the different static generators and storage","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"p2 = plot();\nfor g in get_components(ThermalStandard, sys)\n    state_series = get_state_series(result, (get_name(g), :ω))\n    plot!(\n        p2,\n        state_series;\n        xlabel = \"Time\",\n        ylabel = \"Speed [pu]\",\n        label = \"$(get_name(g)) - ω\",\n    );\nend\nstate_series = get_state_series(result, (\"Battery\", :ω_oc))\nplot!(p2, state_series; xlabel = \"Time\", ylabel = \"Speed [pu]\", label = \"Battery - ω\");","category":"page"},{"location":"tutorials/tutorial_inverter_modeling/","page":"Inverter Modeling","title":"Inverter Modeling","text":"(Image: plot)","category":"page"},{"location":"time_delays/#Delays","page":"Time Delays","title":"Delays","text":"","category":"section"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"PowerSimulationsDynamics supports models with constant delays in a mass matrix formulation:","category":"page"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"beginalign\nMfracdx(t)dt = f(x(t) x(t-tau_1)   x(t-tau_N))   \nendalign","category":"page"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"For more information on solving such models, refer to the documentation for DelayDiffEq.jl package.","category":"page"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"The following models include time delays:","category":"page"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"DEGOV","category":"page"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"There is currently limited support for including models with time delays. The following limitations apply:","category":"page"},{"location":"time_delays/","page":"Time Delays","title":"Time Delays","text":"Only constant delays are supported (state dependent delays are not).\nSystem models with delays must use MassMatrixModel  formulation (ResidualModel is not currently compatible).\nSystem models with delays are not compatible with small signal analysis tools.\nThe system formulation with delays is not compatible with automatic differentiation for calculating the gradient with respect to time. The setting autodiff=false should be set when passing the solver (e.g. MethodofSteps(Rodas5(autodiff=false))).","category":"page"},{"location":"component_models/dc_source/#DC-Source","page":"DC Sources","title":"DC Source","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This component can be used to model the dynamics of the DC side of the converter.","category":"page"},{"location":"component_models/dc_source/#Fixed-DC-Source-[FixedDCSource]","page":"DC Sources","title":"Fixed DC Source [FixedDCSource]","text":"","category":"section"},{"location":"component_models/dc_source/","page":"DC Sources","title":"DC Sources","text":"This is a model that set the DC voltage to a fixed value v_textdc = v_textdc^textfix.","category":"page"},{"location":"tutorials/tutorial_omib/#One-Machine-against-Infinite-Bus-(OMIB)-Simulation","page":"OMIB","title":"One Machine against Infinite Bus (OMIB) Simulation","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"Originally Contributed by: Rodrigo Henriquez-Auba and José Daniel Lara","category":"page"},{"location":"tutorials/tutorial_omib/#Introduction","page":"OMIB","title":"Introduction","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"This tutorial will introduce you to the functionality of PowerSimulationsDynamics for running power system dynamic simulations.","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"This tutorial presents a simulation of a two-bus system with an infinite bus (represented as a voltage source behind an impedance) at bus 1, and a classic machine on bus 2. The perturbation will be the trip of one of the two circuits (doubling its resistance and impedance) of the line that connects both buses.","category":"page"},{"location":"tutorials/tutorial_omib/#Dependencies","page":"OMIB","title":"Dependencies","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"using PowerSimulationsDynamics\nPSID = PowerSimulationsDynamics\nusing PowerSystemCaseBuilder\nusing PowerSystems\nconst PSY = PowerSystems\nusing Sundials\nusing Plots\ngr()","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"note: Note\nPowerSystemCaseBuilder.jl is a helper library that makes it easier to reproduce examples in the documentation and tutorials. Normally you would pass your local files to create the system data instead of calling the function build_system. For more details visit PowerSystemCaseBuilder Documentation","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"PowerSystems (abbreviated with PSY) is used to properly define the data structure and establish an equilibrium point initial condition with a power flow routine, while Sundials is used to solve the problem defined in PowerSimulationsDynamics.","category":"page"},{"location":"tutorials/tutorial_omib/#Load-the-system","page":"OMIB","title":"Load the system","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"We load the system using PowerSystemCaseBuilder.jl:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"omib_sys = build_system(PSIDSystems, \"OMIB System\")","category":"page"},{"location":"tutorials/tutorial_omib/#Build-the-simulation-and-initialize-the-problem","page":"OMIB","title":"Build the simulation and initialize the problem","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"The next step is to create the simulation structure. This will create the indexing of our system that will be used to formulate the differential-algebraic system of equations. To do so, it is required to specify the perturbation that will occur in the system. PowerSimulationsDynamics supports multiple types of perturbations. See Perturbations","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"Here, we will use a Branch Trip perturbation, that is modeled by modifying the specifying which line we want to trip. In this case we disconnect one of the lines that connects BUS 1 and BUS 2, named \"BUS 1-BUS 2-i_1\".","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"With this, we are ready to create our simulation structure:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"time_span = (0.0, 30.0)\nperturbation_trip = BranchTrip(1.0, Line, \"BUS 1-BUS 2-i_1\")\nsim = PSID.Simulation(\n    ResidualModel, # Type of formulation\n    omib_sys, # System\n    mktempdir(), # Output directory\n    time_span,\n    perturbation_trip)","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"This will automatically initialize the system by running a power flow and update V_ref, P_ref and hence eq_p (the internal voltage) to match the solution of the power flow. It will also initialize the states in the equilibrium, which can be printed with:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"show_states_initial_value(sim)","category":"page"},{"location":"tutorials/tutorial_omib/#Run-the-Simulation","page":"OMIB","title":"Run the Simulation","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"Finally, to run the simulation we simply use:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"execute!(\n    sim, #simulation structure\n    IDA(), #Sundials DAE Solver\n    dtmax = 0.02, #Arguments: Maximum timestep allowed\n);","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"In some cases, the dynamic time step used for the simulation may fail. In such case, the keyword argument dtmax can be used to limit the maximum time step allowed for the simulation.","category":"page"},{"location":"tutorials/tutorial_omib/#Exploring-the-solution","page":"OMIB","title":"Exploring the solution","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"First, we need to load the simulation results into memory:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"results = read_results(sim)","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"PowerSimulationsDynamics has two functions to obtain different states of the solution:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"get_state_series(results, (\"generator-102-1\", :δ)): can be used to obtain the solution as a tuple of time and the required state. In this case, we are obtaining the rotor angle :δ of the generator named \"generator-102-1\"`.","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"angle = get_state_series(results, (\"generator-102-1\", :δ));\nplot(angle, xlabel = \"time\", ylabel = \"rotor angle [rad]\", label = \"rotor angle\")","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"get_voltage_magnitude_series(results, 102): can be used to obtain the voltage magnitude as a tuple of time and voltage. In this case, we are obtaining the voltage magnitude at bus 102 (where the generator is located).","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"volt = get_voltage_magnitude_series(results, 102);\nplot(volt, xlabel = \"time\", ylabel = \"Voltage [pu]\", label = \"V_2\")","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"(Image: plot)","category":"page"},{"location":"tutorials/tutorial_omib/#Optional:-Small-Signal-Analysis","page":"OMIB","title":"Optional: Small Signal Analysis","text":"","category":"section"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"PowerSimulationsDynamics uses automatic differentiation to compute the reduced Jacobian of the system for the differential states. This can be used to analyze the local stability of the linearized system. We need to re-initialize our simulation:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"sim2 = Simulation(ResidualModel, omib_sys, mktempdir(), time_span)\nsmall_sig = small_signal_analysis(sim2)","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"The small_sig result can report the reduced jacobian for delta and omega,","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"small_sig.reduced_jacobian","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"and can also be used to report the eigenvalues of the reduced linearized system:","category":"page"},{"location":"tutorials/tutorial_omib/","page":"OMIB","title":"OMIB","text":"small_sig.eigenvalues","category":"page"},{"location":"api/internal/#Internal","page":"Internal API Reference","title":"Internal","text":"","category":"section"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"CurrentModule = PowerSimulationsDynamics\nDocTestSetup  = quote\n    using PowerSimulationsDynamics\nend","category":"page"},{"location":"api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [PowerSimulationsDynamics]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/internal/#PowerSimulationsDynamics.BUILD_STATUS","page":"Internal API Reference","title":"PowerSimulationsDynamics.BUILD_STATUS","text":"Defines the status of the simulation object\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.BranchWrapper","page":"Internal API Reference","title":"PowerSimulationsDynamics.BranchWrapper","text":"Wraps DynamicBranch devices from PowerSystems to handle changes in controls and connection status, and allocate the required indexes of the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.DynamicWrapper","page":"Internal API Reference","title":"PowerSimulationsDynamics.DynamicWrapper","text":"Wraps DynamicInjection devices from PowerSystems to handle changes in controls and connection status, and allocate the required indexes of the state space and parameter space. \n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.SimulationInputs-Tuple{Type{MassMatrixModel}, System, Union{ConstantFrequency, ReferenceBus}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.SimulationInputs","text":"SimulationInputs build function for MassMatrixModels\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.SimulationInputs-Tuple{Type{ResidualModel}, System, Union{ConstantFrequency, ReferenceBus}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.SimulationInputs","text":"SimulationInputs build function for ResidualModels\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.generator_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.generator_inner_vars","text":"Generator Inner Vars:\n\nτe_var :: Electric torque\nτm_var :: Mechanical torque\nVf_var :: Field voltage\nV_pss_var :: Additional PSS voltage\nVR_gen_var :: Real part of the terminal voltage\nVI_gen_var :: Imaginary part of the terminal voltage\nψd_var :: Stator Flux (if defined) in the d-axis\nψq_var :: Stator Flux (if defined) in the q-axis\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics.inverter_inner_vars","page":"Internal API Reference","title":"PowerSimulationsDynamics.inverter_inner_vars","text":"Inverter Inner Vars:\n\nmd_var :: Modulation signal on the d-component\nmq_var :: Modulation signal on the q-component\nVdc_var :: DC voltage supplied by the DC source\nVr_filter_var :: Voltage seen in the capacitor of the filter in the R-component\nVi_filter_var :: Voltage seen in the capacitor of the filter in the I-component\nθ_freq_estimator_var :: Angle estimated by the frequency estimator.\nω_freq_estimator_var :: Frequency estimated by the frequency estimator.\nV_oc_var :: Control voltage reference in the d-axis supplied from the outer loop control to the inner loop (for Voltage Mode Control)\nId_oc_var :: Control current reference in the d-axis supplied from the outer loop control to the inner loop (for Current Mode Control)\nIq_oc_var :: Control current reference in the q-axis supplied from the outer loop control to the inner loop (for Current Mode Control)\nId_ic_var :: Control current reference in the d-axis supplied from the inner loop control to the converter (for Generic Models)\nIq_ic_var :: Control current reference in the q-axis supplied from the inner loop control to the converter (for Generic Models)\nIr_cnv_var :: Control current reference in the R-axis supplied from the converter to the filter (for Generic Models)\nIi_cnv_var :: Control current reference in the I-axis supplied from the converter to the filter (for Generic Models)\nω_oc_var :: Control frequency supplied from the outer loop control the inner loop\nθ_oc_var :: Variation of the angle (PLL or VSM) of the inverter\nVr_inv_var :: Real terminal voltage on the inverter\nVi_inv_var :: Imaginary terminal voltage on the inverter\nVr_cnv_var :: Voltage supplied from the converter in the R-component\nVi_cnv_var :: Voltage supplied from the converter in the I-component\nP_ES_var :: Power supplied from the Energy Source side\n\n\n\n\n\n","category":"type"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Tuple{SalientPoleExponential, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator with machine type GENSAE.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Tuple{SalientPoleQuadratic, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator with machine type GENSAL.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Union{Tuple{M}, Tuple{M, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}} where M<:Machine","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator. It is dispatched via the machine type. By default, machine does not have support for field current\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_current-Union{Tuple{M}, Tuple{M, String, Vector{Float64}, Vector{Float64}, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}} where M<:Union{RoundRotorExponential, RoundRotorQuadratic}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_current","text":"Function to obtain the field current time series of a Dynamic Generator with machine type GENROU/GENROE.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{AVRFixed, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr AVRFixed.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{ESST1A, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr ESST1A.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{SCRX, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr SCRX.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Tuple{Union{ESAC1A, EXAC1}, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avr ESAC1A and EXAC1.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._field_voltage-Union{Tuple{A}, Tuple{A, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}} where A<:AVR","page":"Internal API Reference","title":"PowerSimulationsDynamics._field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator with avrs that have  the field voltage as a state. By default it is assumed that the models have that state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{F}, Tuple{OuterControl{ActivePowerDroop, ReactivePowerDroop}, F, String, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where {F<:FrequencyEstimator, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a droop grid forming inverter out of the DAE Solution. It is dispatched via the OuterControl type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{F}, Tuple{OuterControl{ActiveVirtualOscillator, ReactiveVirtualOscillator}, F, String, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where {F<:FrequencyEstimator, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a VOC grid forming inverter out of the DAE Solution. It is dispatched via the OuterControl type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{F}, Tuple{OuterControl{VirtualInertia, ReactivePowerDroop}, F, String, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where {F<:FrequencyEstimator, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a virtual inertia grid forming inverter out of the DAE Solution. It is dispatched via the OuterControl type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{OuterControl{ActivePowerPI, ReactivePowerPI}, KauraPLL, String, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a grid-following inverter with KauraPLL out of the DAE Solution. It is dispatched via the OuterControl and FrequencyEstimator type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._frequency-Union{Tuple{G}, Tuple{OuterControl{ActivePowerPI, ReactivePowerPI}, ReducedOrderPLL, String, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics._frequency","text":"Function to obtain the frequency time series of a grid-following inverter with ReducedOrderPLL out of the DAE Solution. It is dispatched via the OuterControl and FrequencyEstimator type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{BaseMachine, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a Classic Machine model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{OneDOneQMachine, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a One-D-One-Q model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{SauerPaiMachine, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a SauerPaiMachine model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{AndersonFouadMachine, MarconatoMachine}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a Marconato or AndersonFouad model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{RoundRotorExponential, RoundRotorQuadratic}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a GENROU/GENROE model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{SalientPoleExponential, SalientPoleQuadratic}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a GENSAL/GENSAE model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._machine_current-Tuple{Union{SimpleAFMachine, SimpleMarconatoMachine}, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._machine_current","text":"Function to obtain the output current time series of a SimpleMarconato or SimpleAndersonFouad model out of the DAE Solution. It is dispatched via the machine type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._make_reduced_jacobian_index-Tuple{Any, Any}","page":"Internal API Reference","title":"PowerSimulationsDynamics._make_reduced_jacobian_index","text":"Finds the location of the differential states in the reduced Jacobian\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{DEGOV, String, SimulationResults, Union{Nothing, Float64}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with DEGOV Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{GasTG, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with GasTG (GAST) Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{HydroTurbineGov, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with HydroTurbineGov (HYGOV) Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{SteamTurbineGov1, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with SteamTurbineGov1 (TGOV1) Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{TGFixed, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with TGFixed Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{TGTypeI, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with TGTypeI Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._mechanical_torque-Tuple{TGTypeII, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator with TGTypeII Turbine Governor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._output_current-Union{Tuple{G}, Tuple{C}, Tuple{LCLFilter, C, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where {C<:Converter, G<:DynamicInverter}","page":"Internal API Reference","title":"PowerSimulationsDynamics._output_current","text":"Function to obtain the output current time series of a LCL Filter model out of the DAE Solution. It is dispatched via the Filter type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._output_current-Union{Tuple{G}, Tuple{RLFilter, RenewableEnergyConverterTypeA, String, Vector{Float64}, Vector{Float64}, Float64, SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics._output_current","text":"Function to obtain the output current time series of a REGCA converter model out of the DAE Solution. It is dispatched via the Converter type.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._post_proc_state_series-Tuple{Any, Int64, Nothing}","page":"Internal API Reference","title":"PowerSimulationsDynamics._post_proc_state_series","text":"Internal function to obtain as a Vector of Float64 of a specific state. It receives the solution and the global index for a state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._pss_output-Tuple{IEEEST, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._pss_output","text":"Function to obtain the pss output time series of a Dynamic Generator with pss IEEEST.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics._pss_output-Tuple{PSSFixed, String, SimulationResults, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics._pss_output","text":"Function to obtain the pss output time series of a Dynamic Generator with pss PSSFixed.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_current","text":"Function to obtain the field current time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_current","text":"Function to obtain the field current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It must return nothing since field current does not exists in inverters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_voltage-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_voltage","text":"Function to obtain the field voltage time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific voltage.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_field_voltage-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_field_voltage","text":"Function to obtain the field current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It must return nothing since field voltage does not exists in inverters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_frequency-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_frequency","text":"Function to obtain the output frequency time series of a DynamicGenerator\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_mechanical_torque-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific torque.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_mechanical_torque-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_mechanical_torque","text":"Function to obtain the mechanical torque time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It must return nothing since mechanical torque is not used in inverters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, AggregateDistributedGenerationA, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a AggregateDistributedGenerationA (DERA) model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, PeriodicVariableSource, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a PeriodicVariableSource model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current. computeoutputcurrent(::SimulationResults, ::PeriodicVariableSource, ::Vector{Float64}, ::Vector{Float64}, ::Nothing)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, PowerLoad, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a PowerLoad model. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, PowerSystems.ExponentialLoad, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a ExponentialLoad model. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, SimplifiedSingleCageInductionMachine, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a 3th Order Induction Machine model out of the DAE Solution.  It receives the simulation inputs, the dynamic device and bus voltage. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, SingleCageInductionMachine, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a 5th Order Induction Machine model out of the DAE Solution.  It receives the simulation inputs, the dynamic device and bus voltage. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Tuple{SimulationResults, StandardLoad, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a PowerLoad model. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{G}, Tuple{SimulationResults, G, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicInverter","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Function to obtain the output current time series of a Dynamic Inverter model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific current.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_output_current-Union{Tuple{I}, Tuple{SimulationResults, I, Vector{Float64}, Vector{Float64}, Union{Nothing, Float64, Vector{Float64}}}} where I<:DynamicInjection","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_output_current","text":"Default function to compute output current.  Returns an error\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.compute_pss_output-Union{Tuple{G}, Tuple{SimulationResults, G, Union{Nothing, Float64, Vector{Float64}}}} where G<:DynamicGenerator","page":"Internal API Reference","title":"PowerSimulationsDynamics.compute_pss_output","text":"Function to obtain the pss output time series of a Dynamic Generator model out of the DAE Solution. It receives the simulation inputs, the dynamic device and bus voltage. It is dispatched for device type to compute the specific output.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.configure_logging-Tuple{}","page":"Internal API Reference","title":"PowerSimulationsDynamics.configure_logging","text":"configure_logging(;\n    console_level = Logging.Error,\n    file_level = Logging.Info,\n    filename = \"power-simulations.log\",\n)\n\nCreates console and file loggers.\n\nNote: Log messages may not be written to the file until flush() or close() is called on the returned logger.\n\nArguments\n\nconsole_level = Logging.Error: level for console messages\nfile_level = Logging.Info: level for file messages\nfilename::String = power-simulations.log: log file\n\nExample\n\nlogger = configure_logging(console_level = Logging.Info)\n@info \"log message\"\nclose(logger)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{ActiveConstantPowerLoad}, Any, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of 12-state Active Constant Power Load in Julia. Based on the paper Malicious Control of an Active Load in an Islanded Mixed-Source Microgrid by C. Roberts, U. Markovic, D. Arnold and D. Callaway.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{CSVGN1}, Any, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of Static Shunt Compensator: CSVGN1.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{SimplifiedSingleCageInductionMachine}, Any, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of 3-state (SimplifiedSingleCageInductionMachine) induction motor in Julia. Based on the 3rd order model derived in Prabha Kundur's Book and the equations in \"Analysis of Electric Machinery and Drive Systems\" by Paul Krause, Oleg Wasynczuk and Scott Sudhoff.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.device!-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractArray{T}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, T, T, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.DynamicWrapper{SingleCageInductionMachine}, Any, Any}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.device!","text":"Model of 5-state (SingleCageInductionMachine) induction motor in Julia. Refer to \"Analysis of Electric Machinery and Drive Systems\" by Paul Krause, Oleg Wasynczuk and Scott Sudhoff for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{AndersonFouadMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{BaseMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 0-state synchronous (classic model) machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{MarconatoMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{OneDOneQMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SauerPaiMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 6-state (SauerPai) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleAFMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Anderson-Fouad) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.initialize_mach_shaft!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{Any, Any, StaticInjection, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleMarconatoMachine, S, A, TG, P}}, AbstractVector}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.initialize_mach_shaft!","text":"Initialitation of model of 4-state (Simple Marconato) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.low_pass_modified_mass_matrix-Union{Tuple{Z}, Tuple{W}, Tuple{V}, Tuple{Z, V, Float64, W, Float64}} where {V<:Union{Float64, ForwardDiff.Dual}, W<:Union{Float64, ForwardDiff.Dual}, Z<:Union{Float64, ForwardDiff.Dual}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.low_pass_modified_mass_matrix","text":"Low Pass Filter Modified      ┌─────────────┐      │      K      │ u -> │ ────────────│ -> y      │ K_den + sT  │      └─────────────┘\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mass_matrix_entries-Tuple{DynamicInjection}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mass_matrix_entries","text":"Default implementation of mass matrix entries. Keeps the default values in the identity matrix\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{AndersonFouadMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (AndersonFouadMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{BaseMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 0-state synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{MarconatoMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (MarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{OneDOneQMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 2-state (One d- and One q-) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SauerPaiMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 6-state (SauerPaiMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleAFMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleAFMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_machine_ode!-Union{Tuple{P}, Tuple{TG}, Tuple{A}, Tuple{S}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, PowerSimulationsDynamics.DynamicWrapper{DynamicGenerator{SimpleMarconatoMachine, S, A, TG, P}}, Any, Any}} where {S<:Shaft, A<:AVR, TG<:TurbineGov, P<:PSS}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_machine_ode!","text":"Model of 4-state (SimpleMarconatoMachine) synchronous machine in Julia. Refer to Power System Modelling and Scripting by F. Milano for the equations\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.mdl_zip_load!-Union{Tuple{T}, Tuple{AbstractArray{<:Union{Float64, ForwardDiff.Dual}}, T, T, AbstractArray{T}, AbstractArray{T}, PowerSimulationsDynamics.StaticLoadWrapper}} where T<:Union{Float64, ForwardDiff.Dual}","page":"Internal API Reference","title":"PowerSimulationsDynamics.mdl_zip_load!","text":"Model for ZIP Load model given by:\n\nPzip = Ppower + Pcurrent * (V / V0) + Pimpedance * (V / V0)^2 Qzip = Qpower + Qcurrent * (V / V0) + Qimpedance * (V / V0)^2\n\nwith V = sqrt(Vr^2 + Vi^2) and V0 the voltage magnitude from the power flow solution\n\nThe current taken for the load is computed as: Izip = (Pzip + j Qzip)^* / (Vr + j Vi)^* Izip = (Pzip - j Qzip) / (Vr - j Vi)\n\nFor constant impedance it is obtained: Izre = (1 / V0)^2 * (Vr * Pimpedance + Vi * Qimpedance) Izim = (1 / V0)^2 * (Vi * Pimpedance - Vr * Qimpedance)\n\nFor constant current it is obtained: Iire = (1 / V0) * ( (Vr * Pcurrent + Vi * Qcurrent) / V ) Iiim = (1 / V0) * ( (Vi * Pcurrent - Vr * Qcurrent) / V )\n\nFor constant power it is obtained: Ipre =  (Vr * Ppower + Vi * Qpower) / V^2 Ipim =  (Vi * Ppower - Vr * Qpower) / V^2\n\nModel for Exponential Load model given by:\n\nPexp = P0 * (V / V0)^α Qexp = Q0 * (V / V0)^β\n\nThe current taken for the load is computed as: Iexp = (Pexp + j Qexp)^* / (Vr + j Vi)^* Iexp = (Pexp - j Qexp) / (Vr - j Vi)\n\nIt results: Irexp = Vr * P0 * (V^(α - 2) / V0^α) + Vi * Q0 * (V^(β - 2)/ V0^β) Iiim  = Vi * P0 * (V^(α - 2) / V0^α) - Vr * Q0 * (V^(β - 2)/ V0^β)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_activepower_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_activepower_series","text":"Function to compute the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_branch_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_branch_series","text":"Function to compute the current flowing through an AC branch through their series element. The current is computed through the from bus into the to bus.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_field_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_field_current_series","text":"Function to compute the field current output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_field_voltage_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_field_voltage_series","text":"Function to compute the field voltage output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_frequency_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_frequency_series","text":"Function to compute the frequency of a Dynamic Injection component.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_imaginary_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_imaginary_current_series","text":"Function to compute the imaginary current output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_mechanical_torque_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_mechanical_torque_series","text":"Function to compute the mechanical torque output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_pss_output_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_pss_output_series","text":"Function to compute the pss output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_reactivepower_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_reactivepower_series","text":"Function to compute the active power output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_real_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_real_current_series","text":"Function to compute the real current output time series of a Dynamic Injection series out of the DAE Solution. It receives the solution and the string name of the Dynamic Injection device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_source_voltage_current_series","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_source_voltage_current_series","text":"Function to obtain voltage and output currents for a source. It receives the simulation resutls and      an optional argument of the time step of the results.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_state_series-Tuple{SimulationResults, Tuple{String, Symbol}, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_state_series","text":"Function to obtain the state time series of a specific state. It receives the simulation, and a tuple containing the name of the Dynamic Device and the symbol of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_voltage_current_series-Tuple{SimulationResults, String, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_voltage_current_series","text":"Function to obtain voltage and output currents for a dynamic device. It receives the simulation, and the name of the Dynamic Device.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.post_proc_voltage_series-Tuple{Any, Int64, Int64, Union{Nothing, Float64, Vector{Float64}}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.post_proc_voltage_series","text":"Function to obtain voltage using the bus index (and not the bus number). It receives the solution, the bus index and the total number of buses.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorExponential, SalientPoleExponential}, Union{Float64, ForwardDiff.Dual}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for exponential saturation models for machines\n    Se(x) = B * x^A\n\n\n\n\n\n","category":"method"},{"location":"api/internal/#PowerSimulationsDynamics.saturation_function-Tuple{Union{RoundRotorQuadratic, SalientPoleQuadratic}, Union{Float64, ForwardDiff.Dual}}","page":"Internal API Reference","title":"PowerSimulationsDynamics.saturation_function","text":"Saturation function for quadratic saturation models for machines\n    Se(x) = B * (x - A)^2 / x\n\n\n\n\n\n","category":"method"},{"location":"component_models/converter/#Converter","page":"Converter","title":"Converter","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This component can be used to model the dynamics of the switching process.","category":"page"},{"location":"component_models/converter/#Average-Model-[AverageConverter]","page":"Converter","title":"Average Model [AverageConverter]","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"The average model outputs the desired reference signal since:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\nv_d^textcv approx m_d v_textdc approx fracv_d^textref-signalv_textdc v_textdc approx v_d^textref-signal tag1a \nv_q^textcv approx m_q v_textdc approx fracv_q^textref-signalv_textdc v_textdc approx v_q^textref-signal tag1b\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"where m_dq is the modulation signal, and v_dq^textref-signal is the voltage reference signal from the inner loop control.","category":"page"},{"location":"component_models/converter/#Generic-Renewable-Converter-Type-A-[RenewableEnergyConverterTypeA]","page":"Converter","title":"Generic Renewable Converter Type A ```[RenewableEnergyConverterTypeA]","text":"","category":"section"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This block represents the REGCA model. The equations (without the limiters) are:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\n    dotI_p = frac1T_g (I_textpcmd - I_p) tag2a \n    dotI_q = frac1T_g (I_textqcmd - I_q) tag2b \n    dotV_textmeas = frac1T_fltr (V_t - V_textmeas tag2c)\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"on which I_textpcmd and I_textqcmd are the current commands from the inner control and V_t is the bus voltage magnitude. The additional terms and output current are computed as:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\n    I_q^textcv = -I_q - I_textqextra tag2d \n    I_textqextra = max(K_hv (V_t - V_textolim)) tag2e \n    I_p^textcv = G_lv I_p tag2f \nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"on which G_lv is the gain used for Low Voltage Active Current Management and I_textqextra is the additional current for High Voltage Reactive Current Management.","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"It is important to note that both current commands coming from the inner control were obtained by dividing the active (or reactive) power by the magnitude voltage instead of using the correct phasor formula I = (SV)^*. For that purpose, a correction factor must be applied to obtain the correct output currents in the network reference frame:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign*\n    I_r + jI_i = (I_p + jI_q) cdot V_t cdot frac1V_r + jV_i \n    = (I_p + jI_q) cdot fracV_tV_t e^jtheta \n    = (I_p + jI_q) cdot e^-jtheta\nendalign*","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This correction factor looks like a reference transformation that must be used to properly inject current into the grid. With that the output current is computed as:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign\n    I_r = I_p^textcv cos(theta) - I_q^textcv sin(theta) tag2g \n    I_i = I_p^textcv sin(theta) + I_q^textcv cos(theta) tag2h\nendalign","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"This current source is usually modeled as a Norton equivalent using a parallel impedance with values R_sorce and X_sorce provided in the .raw file. If an RL filter is used, a Voltage Source behind that RL filter (i.e. the converter output voltage) can be computed as:","category":"page"},{"location":"component_models/converter/","page":"Converter","title":"Converter","text":"beginalign*\n    Z_f = r_f + jl_f \n    Z_sorce = R_sorce + jX_sorce \n    I_cv = I_r + jI_i \n    v_r^textcv + jv_i^textcv = fracI_cv + fracv^textgridZ_ffrac1Z_sorce + frac1Z_f tag2i\nendalign*","category":"page"},{"location":"#PowerSimulationsDynamics.jl","page":"Welcome Page","title":"PowerSimulationsDynamics.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerSimulationsDynamics","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics.jl is a Julia package for doing Power Systems Dynamic Modeling with Low Inertia Energy Sources.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The synchronous machine components supported here are based on commercial models and the academic components are derived from Power System Modelling and Scripting.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"Inverter models support both commercial models, such as REPC, REEC and REGC type of models; and academic models obtained from grid-following and grid-forming literature such as in \"A Virtual Synchronous Machine implementation for distributed control of power converters in SmartGrids\"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The background work on PowerSimulationsDynamics.jl is explained in Revisiting Power Systems Time-domain Simulation Methods and Models","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"@article{lara2023revisiting,\ntitle={Revisiting Power Systems Time-domain Simulation Methods and Models},\nauthor={Lara, Jose Daniel and Henriquez-Auba, Rodrigo and Ramasubramanian, Deepak and Dhople, Sairaj and Callaway, Duncan S and Sanders, Seth},\njournal={arXiv preprint arXiv:2301.10043},\nyear={2023}\n}","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerSimulationsDynamics.jl can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerSimulationsDynamics#master","category":"page"},{"location":"#Structure","page":"Welcome Page","title":"Structure","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The following figure shows the interactions between PowerSimulationsDynamics.jl, PowerSystems.jl, ForwardDiff.jl, DiffEqBase.jl and the integrators. The architecture of PowerSimulationsDynamics.jl  is such that the power system models are all self-contained and return the model function evaluations. The Jacobian is calculated using automatic differentiation through ForwardDiff.jl, that is used for both numerical integration and small signal analysis. Considering that the resulting models are differential-algebraic equations (DAE), the implementation focuses on the use of implicit solvers, in particular BDF and Rosenbrock methods.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"<img src=\"./assets/SoftwareLoop.jpg\" width=\"65%\"/>","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"⠀","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerSimulationsDynamics.jl has been developed as part of the Scalable Integrated Infrastructure Planning (SIIP) initiative at the U.S. Department of Energy's National Renewable Energy Laboratory (NREL)","category":"page"},{"location":"generic/#Industrial-(Generic)-Renewable-Models","page":"Industrial Renewable Models","title":"Industrial (Generic) Renewable Models","text":"","category":"section"},{"location":"generic/#Connection-with-the-Inverter-Metamodel","page":"Industrial Renewable Models","title":"Connection with the Inverter Metamodel","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Generic Renewable Models for PV solar or battery devices used in industrial tools, such as PSS/E or PowerWorld, does not necessary resemble the proposed structure of our proposed metamodel. ","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"In general terms, a generic renewable model (for PV plant or battery) is typically a Grid Following inverter that uses a Renewable Energy Plant Controller (REPC), a Renewable Energy Electrical Controller (REEC) and a Renewable Energy Generic Converter (REGC) model. The following figure is useful to understand the general structure of such models:","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/generic_vsc.png\" width=\"100%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"In comparison to the proposed inverter metamodel it is clear that the REPC resembles the Outer Control. However, the REEC has a purpose of both Outer Control and Inner Control and the REGC has a similar purpose of the Converter and Filter in the proposed structure. For such purpose, it was necessary to split the REEC and part of its model was included in both Outer Control and Inner Control.","category":"page"},{"location":"generic/#Example-of-implementation-of-generic-models","page":"Industrial Renewable Models","title":"Example of implementation of generic models","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The following includes examples of the implementation of the proposed model in the inverter metamodel.","category":"page"},{"location":"generic/#Active-Renewable-Outer-Control","page":"Industrial Renewable Models","title":"Active Renewable Outer Control","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The following example join the active power controllers from REPCA and REECB as ActiveRenewableControllerAB in PowerSimulationsDynamics.jl","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/active_ren.png\" width=\"90%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"⠀","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"An important thing to consider with the industrial models, is that the change of Flags can significantly vary the model and purpose of the controller.","category":"page"},{"location":"generic/#Reactive-Renewable-Outer-Control","page":"Industrial Renewable Models","title":"Reactive Renewable Outer Control","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Similar to the active controller, the following figure presents the reactive controller part from REPCA and REECB as ReactiveRenewableControllerAB in PowerSimulationsDynamics.jl","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/reactive_ren.png\" width=\"90%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"⠀","category":"page"},{"location":"generic/#Inner-Controller","page":"Industrial Renewable Models","title":"Inner Controller","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Finally, the remaining part from REECB was included RECurrentControllerB","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"<img src=\"../assets/inner_reecb.png\" width=\"90%\"/>","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"⠀","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The REGCAmodel was directly included in a Converter Block, and the filter can be bypassed using an RLFilter block with rf = lf = 0.","category":"page"},{"location":"generic/#Current-availability-of-model-flags-in-PSID","page":"Industrial Renewable Models","title":"Current availability of model flags in PSID","text":"","category":"section"},{"location":"generic/#Active-Controller","page":"Industrial Renewable Models","title":"Active Controller","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"For the active controller, both Freq_Flag = 0 (ignoring frequency regulation) and Freq_Flag = 1 (considering frequency regulation) are available.","category":"page"},{"location":"generic/#Reactive-Controller","page":"Industrial Renewable Models","title":"Reactive Controller","text":"","category":"section"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"The following table describes the current available combination of flags in PSID:","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"REF_Flag PF_Flag V_Flag Q_Flag\n0 0 0 0\n0 0 1 0\n1 0 1 1\n1 0 0 0","category":"page"},{"location":"generic/","page":"Industrial Renewable Models","title":"Industrial Renewable Models","text":"Any combination outside of these cases may not converge to a feasible operating point. Check the following CAISO report for the description and compliance of each flag combination.","category":"page"}]
}
